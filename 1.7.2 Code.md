Below is **1.7 code**: DB migration + backend routes + frontend components + patches to make the ERD feel real:
‚úÖ edge hover/click + tooltip
‚úÖ issues drawer with jump-to focus
‚úÖ persist layout per instance (load + debounced save)

---

## A) App DB Migration ‚Äî `erd_layouts`

### `008_erd_layouts.sql`

```sql
CREATE TABLE erd_layouts (
  instance_id uuid NOT NULL REFERENCES checklist_instances(id) ON DELETE CASCADE,
  table_key   text NOT NULL,
  x           integer NOT NULL,
  y           integer NOT NULL,
  w           integer NOT NULL,
  h           integer NOT NULL,
  updated_at  timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (instance_id, table_key)
);

CREATE INDEX erd_layouts_instance_idx ON erd_layouts(instance_id);
```

---

## B) Backend (Fastify) ‚Äî layout routes + issues-with-target endpoint

### 1) `apps/api/src/routes/erdLayout.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { query } from '../sql';

const UUIDSchema = z.string().uuid();

export async function erdLayoutRoutes(app: FastifyInstance) {
  // GET layout
  app.get('/api/v1/checklist-instances/:instanceId/erd-layout', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    const rows = await query<any>(
      `SELECT table_key, x, y, w, h, updated_at
       FROM erd_layouts
       WHERE instance_id=$1`,
      [instanceId],
    );

    return {
      instanceId,
      layout: rows.map((r: any) => ({
        tableKey: r.table_key,
        x: r.x,
        y: r.y,
        w: r.w,
        h: r.h,
        updatedAt: r.updated_at,
      })),
    };
  });

  // PUT layout (batch upsert)
  app.put('/api/v1/checklist-instances/:instanceId/erd-layout', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    const Body = z.object({
      items: z.array(
        z.object({
          tableKey: z.string().min(1),
          x: z.number().int(),
          y: z.number().int(),
          w: z.number().int().min(120),
          h: z.number().int().min(120),
        }),
      ).min(1),
    });
    const body = Body.parse(req.body);

    // transaction + upsert
    const { pool } = await import('../db');
    const tx = await pool.connect();
    try {
      await tx.query('BEGIN');

      for (const it of body.items) {
        await tx.query(
          `
          INSERT INTO erd_layouts (instance_id, table_key, x, y, w, h, updated_at)
          VALUES ($1,$2,$3,$4,$5,$6, now())
          ON CONFLICT (instance_id, table_key)
          DO UPDATE SET x=EXCLUDED.x, y=EXCLUDED.y, w=EXCLUDED.w, h=EXCLUDED.h, updated_at=now()
          `,
          [instanceId, it.tableKey, it.x, it.y, it.w, it.h],
        );
      }

      await tx.query('COMMIT');
      return { ok: true };
    } catch (e) {
      await tx.query('ROLLBACK');
      throw e;
    } finally {
      tx.release();
    }
  });
}
```

### 2) Improve issues endpoint to include a focus target

Patch your existing issues helper to include a best-effort focus target.

#### `apps/api/src/checklist/issues.ts` (replace return mapping)

```ts
// ... inside getInstanceIssues()

return rows.map((r: any) => {
  const targets = r.target_ref?.targets ?? [];
  // pick the first target as focus hint
  const t = targets[0];

  let focus: any = null;
  if (t?.kind === 'table') {
    focus = { type: 'table', key: `${t.schema}.${t.table}` };
  } else if (t?.kind === 'relationship') {
    const childCols = (t.childCols ?? []).join(',');
    const parentCols = (t.parentCols ?? []).join(',');
    const key = `${t.childSchema}.${t.childTable}(${childCols})->${t.parentSchema ?? ''}.${t.parentTable ?? ''}(${parentCols})`;
    focus = { type: 'relationship', key };
  }

  return {
    resultId: r.result_id,
    severity: r.result_severity,
    status: r.result_status,
    code: r.code ?? 'CHECK',
    title: r.node_title,
    targetRef: r.target_ref,
    focus,
  };
});
```

### 3) Wire route into API

#### `apps/api/src/index.ts`

```ts
import { erdLayoutRoutes } from './routes/erdLayout';
// ...
await app.register(erdLayoutRoutes);
```

---

## C) Frontend ‚Äî API + Hooks

### 1) `apps/web/src/api/client.ts` (add)

```ts
export async function getErdLayout(instanceId: string) {
  return request<{ instanceId: string; layout: any[] }>(
    `/api/v1/checklist-instances/${instanceId}/erd-layout`,
  );
}

export async function putErdLayout(instanceId: string, items: { tableKey: string; x: number; y: number; w: number; h: number }[]) {
  return request<{ ok: true }>(`/api/v1/checklist-instances/${instanceId}/erd-layout`, {
    method: 'PUT',
    body: JSON.stringify({ items }),
  });
}

export async function getIssues(instanceId: string) {
  return request<{ instanceId: string; issues: any[] }>(
    `/api/v1/checklist-instances/${instanceId}/issues`,
  );
}
```

### 2) `apps/web/src/api/hooks.ts` (add)

```ts
import { useMutation, useQuery } from '@tanstack/react-query';
import { getErdLayout, putErdLayout, getIssues } from './client';

export function useErdLayout(instanceId: string, enabled: boolean) {
  return useQuery({
    queryKey: ['erdLayout', instanceId],
    enabled: enabled && !!instanceId,
    queryFn: async () => await getErdLayout(instanceId),
    staleTime: 10_000,
  });
}

export function useSaveErdLayout(instanceId: string) {
  return useMutation({
    mutationFn: async (items: { tableKey: string; x: number; y: number; w: number; h: number }[]) =>
      await putErdLayout(instanceId, items),
  });
}

export function useIssues(instanceId: string, enabled: boolean) {
  return useQuery({
    queryKey: ['issues', instanceId],
    enabled: enabled && !!instanceId,
    queryFn: async () => await getIssues(instanceId),
    staleTime: 5_000,
  });
}
```

---

## D) Frontend ‚Äî Store patch (hydration marker)

### `apps/web/src/stores/erdStore.ts` (add fields + methods)

Add to store type:

```ts
hydratedFromServer: boolean;
setHydratedFromServer: (v: boolean) => void;
setLayoutBulk: (items: { tableKey: string; x: number; y: number; w: number; h: number }[]) => void;
```

Add implementation inside `create()`:

```ts
hydratedFromServer: false,
setHydratedFromServer: (v) => set({ hydratedFromServer: v }),

setLayoutBulk: (items) => {
  const next = { ...get().layout };
  for (const it of items) {
    next[it.tableKey] = { x: it.x, y: it.y, w: it.w, h: it.h };
  }
  set({ layout: next });
},
```

---

## E) Frontend ‚Äî Issues Drawer component

### `apps/web/src/erd/IssuesDrawer.tsx`

```tsx
import { useMemo } from 'react';
import { useIssues } from '../api/hooks';
import { useErdStore } from '../stores/erdStore';

function sevPill(sev: string) {
  if (sev === 'blocking') return 'BLOCK';
  if (sev === 'error') return 'FAIL';
  if (sev === 'warning') return 'WARN';
  return sev?.toUpperCase?.() ?? 'ISSUE';
}

export function IssuesDrawer({ instanceId }: { instanceId: string }) {
  const { data, isLoading, isError, error } = useIssues(instanceId, true);
  const focusOn = useErdStore((s) => s.focusOn);

  const issues = useMemo(() => data?.issues ?? [], [data]);

  return (
    <aside className="w-[320px] shrink-0 border-r border-zinc-200 bg-white">
      <div className="p-4 border-b border-zinc-200">
        <div className="text-sm font-semibold">Issues</div>
        <div className="text-xs text-zinc-500">Click to focus ERD</div>
      </div>

      <div className="p-3 space-y-2 overflow-auto h-[calc(100vh-57px)]">
        {isLoading ? <div className="text-sm text-zinc-500">Loading‚Ä¶</div> : null}
        {isError ? <div className="text-sm text-red-600">{String(error)}</div> : null}

        {!isLoading && !issues.length ? (
          <div className="text-sm text-zinc-500">No issues üéâ</div>
        ) : null}

        {issues.map((it: any) => (
          <button
            key={it.resultId}
            className="w-full text-left rounded-2xl border border-zinc-200 bg-white hover:bg-zinc-50 p-3"
            onClick={() => {
              if (it.focus) focusOn(it.focus);
            }}
          >
            <div className="flex items-center justify-between gap-2">
              <div className="text-[11px] font-semibold px-2 py-0.5 rounded-full border border-zinc-200">
                {sevPill(it.severity)}
              </div>
              <div className="text-[11px] text-zinc-500">{it.code}</div>
            </div>
            <div className="mt-2 text-sm font-medium">{it.title}</div>
            {it.focus?.key ? (
              <div className="mt-1 text-xs text-zinc-500 truncate">{it.focus.key}</div>
            ) : null}
          </button>
        ))}
      </div>
    </aside>
  );
}
```

---

## F) Frontend ‚Äî Edge hover/click + tooltip + selection

### Patch `apps/web/src/erd/ErdCanvas.tsx`

Replace the SVG section in your existing `ErdCanvas` with this (keep the rest of your file the same):

```tsx
// Add near top:
import type { Rect } from '../stores/erdStore';

// inside component:
const [hoverEdge, setHoverEdge] = useState<{ key: string; x: number; y: number; label: string } | null>(null);

// change edgePaths memo to include label + endpoints:
const edgePaths = useMemo(() => {
  const paths: { key: string; d: string; severity?: string; mid: {x:number;y:number}; label: string }[] = [];
  for (const e of edges) {
    const child = layout[e.childKey];
    const parent = layout[e.parentKey];
    if (!child || !parent) continue;

    const a = centerRight(child);
    const b = centerLeft(parent);

    const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    const label = `${e.name} ‚Ä¢ ${e.childCols.join(', ')} ‚Üí ${e.parentCols.join(', ')}`;

    paths.push({ key: e.key, d: bezierPath(a, b), severity: e.severity, mid, label });
  }
  return paths;
}, [edges, layout]);

// add helper:
const setSel = (key: string) => setSelected({ type: 'relationship', key });

// ... inside return, replace the edges svg with interactive one:
<svg
  width={6000}
  height={6000}
  style={{ position: 'absolute', left: 0, top: 0 }}
>
  {edgePaths.map((p) => {
    const isSel = selected.type === 'relationship' && selected.key === p.key;
    const stroke = isSel ? 'black' : 'rgba(0,0,0,0.25)';
    const strokeWidth = isSel ? 2.75 : p.severity ? 2 : 1.25;

    return (
      <g key={p.key}>
        {/* hit area */}
        <path
          d={p.d}
          fill="none"
          stroke="transparent"
          strokeWidth={12}
          style={{ cursor: 'pointer' }}
          onMouseEnter={() => {
            setHoverEdge({ key: p.key, x: p.mid.x, y: p.mid.y, label: p.label });
          }}
          onMouseLeave={() => setHoverEdge(null)}
          onClick={(e) => {
            e.stopPropagation();
            setSel(p.key);
          }}
        />
        {/* visible edge */}
        <path d={p.d} fill="none" stroke={stroke} strokeWidth={strokeWidth} />
      </g>
    );
  })}
</svg>

// add tooltip overlay inside stage (after svg, before nodes):
{hoverEdge ? (
  <div
    style={{
      position: 'absolute',
      left: hoverEdge.x + 10,
      top: hoverEdge.y + 10,
      transform: 'translate(0, 0)',
      pointerEvents: 'none',
    }}
    className="px-3 py-2 rounded-xl bg-white border border-zinc-200 shadow-sm text-xs max-w-[360px]"
  >
    {hoverEdge.label}
  </div>
) : null}
```

Also update background click handler to clear relationship hover (optional):

```ts
setHoverEdge(null);
```

---

## G) Frontend ‚Äî Layout persistence hook (debounced)

### `apps/web/src/erd/usePersistLayout.ts`

```ts
import { useEffect, useMemo, useRef } from 'react';
import { useSaveErdLayout } from '../api/hooks';
import { useErdStore } from '../stores/erdStore';

export function usePersistLayout(instanceId: string, enabled: boolean) {
  const layout = useErdStore((s) => s.layout);
  const hydrated = useErdStore((s) => s.hydratedFromServer);
  const save = useSaveErdLayout(instanceId);

  const timer = useRef<number | null>(null);
  const lastPayload = useRef<string>('');

  const payload = useMemo(() => {
    const items = Object.entries(layout).map(([tableKey, r]) => ({
      tableKey,
      x: Math.round(r.x),
      y: Math.round(r.y),
      w: Math.round(r.w),
      h: Math.round(r.h),
    }));
    // stable order
    items.sort((a, b) => a.tableKey.localeCompare(b.tableKey));
    return items;
  }, [layout]);

  useEffect(() => {
    if (!enabled) return;
    if (!hydrated) return; // don‚Äôt overwrite server layout before hydration
    if (!payload.length) return;

    const str = JSON.stringify(payload);
    if (str === lastPayload.current) return;

    if (timer.current) window.clearTimeout(timer.current);
    timer.current = window.setTimeout(() => {
      lastPayload.current = str;
      save.mutate(payload);
    }, 650);

    return () => {
      if (timer.current) window.clearTimeout(timer.current);
    };
  }, [enabled, hydrated, payload, save]);
}
```

---

## H) Frontend ‚Äî ErdPage patch (load server layout + show drawer + persist)

### Patch `apps/web/src/pages/ErdPage.tsx`

1. Imports:

```tsx
import { useErdLayout } from '../api/hooks';
import { usePersistLayout } from '../erd/usePersistLayout';
import { IssuesDrawer } from '../erd/IssuesDrawer';
```

2. Pull layout query + hydrate:

```tsx
const setLayoutBulk = useErdStore((s) => s.setLayoutBulk);
const setHydratedFromServer = useErdStore((s) => s.setHydratedFromServer);

const layoutQ = useErdLayout(instanceId!, !!conn && !showConn);

useEffect(() => {
  if (!layoutQ.data?.layout) return;
  // hydrate positions from server if present
  if (layoutQ.data.layout.length) {
    setLayoutBulk(
      layoutQ.data.layout.map((it: any) => ({
        tableKey: it.tableKey,
        x: it.x,
        y: it.y,
        w: it.w,
        h: it.h,
      })),
    );
  }
  setHydratedFromServer(true);
}, [layoutQ.data?.layout]);
```

3. If there is *no* server layout, we still mark hydrated after auto layout:
   Right after your `autoLayout()` call effect (after graph loaded), add:

```tsx
useEffect(() => {
  if (!graph?.nodes?.length) return;
  // If server has no layout rows, autoLayout runs and then we allow persistence.
  if ((layoutQ.data?.layout?.length ?? 0) === 0) {
    setHydratedFromServer(true);
  }
}, [graph?.nodes?.length, layoutQ.data?.layout?.length]);
```

4. Enable persistence:

```tsx
usePersistLayout(instanceId!, !!conn && !showConn);
```

5. Render drawer (left side):
   Replace your body layout:

```tsx
<div className="flex flex-1 min-h-0">
  {instanceId ? <IssuesDrawer instanceId={instanceId} /> : null}

  <div className="flex-1 min-w-0">
    {/* existing canvas block */}
  </div>

  {graph ? <InspectorPanel nodes={graph.nodes} edges={graph.edges} /> : null}
</div>
```

---

## I) (Optional but recommended) Make edges selectable in Inspector

You already have relationship view in `InspectorPanel`. This now works because ERD sets `selected.relationship`.

---

# ‚úÖ 1.7 Definition of Done

* Edge hover shows tooltip; edge click selects relationship
* Issues drawer lists issues; click focuses ERD
* Layout persists per instance (GET on load, PUT debounced)

---

If you want the next upgrade after 1.7: **1.8 ‚ÄúRelationship-aware anchors‚Äù** (edges connect to exact column rows + edge routing improvements) or **1.9 ‚ÄúSchema lanes + minimap‚Äù**.
