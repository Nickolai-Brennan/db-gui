Perfect. We’ll **execute 0.1 step-by-step**, turning it into **actionable setup tasks you can literally check off today**.
I’ll treat this like a senior DBA / platform engineer kicking off a greenfield product.

---

# 0.1 Repo + Standards — EXECUTION CHECKLIST

## 0.1.1 Decide Repo Structure (FOUNDATIONAL – do this first)

### Decision

**Recommended:** ✅ **Monorepo**

Why (for *this* product):

* Shared types (checklists, ERD models, annotations)
* Shared validation logic (target_ref, severity enums)
* One CI pipeline
* Easier refactors early

### Structure

```
/db-gui
├─ apps/
│  ├─ web/          # React frontend
│  └─ api/          # Backend API
├─ packages/
│  ├─ shared/       # types, enums, utils
│  └─ ui/           # shared UI components (later)
├─ infra/           # docker, db, migrations
├─ scripts/
├─ .github/
└─ README.md
```

### Tasks

* [ ] Create repo
* [ ] Create folders: apps/, packages/, infra/
* [ ] Decide package manager: **pnpm** (recommended)

---

## 0.1.2 Package Manager & Tooling Baseline

### Tasks

* [ ] Install pnpm
* [ ] Create root `package.json`

```json
{
  "name": "db-gui",
  "private": true,
  "workspaces": ["apps/*", "packages/*"]
}
```

* [ ] Create `pnpm-workspace.yaml`

```yaml
packages:
  - apps/*
  - packages/*
```

---

## 0.1.3 Code Quality Standards (non-negotiable)

### ESLint

**One config shared across FE + BE**

Tasks:

* [ ] Install ESLint
* [ ] Create root `.eslintrc.cjs`
* [ ] Enforce:

  * no `any`
  * unused vars
  * consistent imports
  * explicit return types (backend)

### Prettier

Tasks:

* [ ] Install Prettier
* [ ] Create `.prettierrc`

```json
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all"
}
```

### EditorConfig

Tasks:

* [ ] Create `.editorconfig`

```
root = true
[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
```

---

## 0.1.4 Git Hygiene (this saves you later)

### Commit Convention

Use:

```
feat:
fix:
chore:
refactor:
docs:
```

Tasks:

* [ ] Create `CONTRIBUTING.md`
* [ ] Document commit rules
* [ ] (Optional) install commitlint

---

## 0.1.5 Git Hooks (early discipline)

### Tools

* **husky**
* **lint-staged**

Tasks:

* [ ] Install husky
* [ ] Install lint-staged
* [ ] Configure pre-commit hook:

  * ESLint
  * Prettier
  * Typecheck (optional early)

Example:

```json
"lint-staged": {
  "*.{ts,tsx}": ["eslint --fix", "prettier --write"]
}
```

---

## 0.1.6 CI Pipeline (MINIMUM VIABLE)

### GitHub Actions

Create `.github/workflows/ci.yml`

Pipeline steps:

* [ ] Install deps
* [ ] Lint
* [ ] Typecheck
* [ ] Build web
* [ ] Build api

You don’t need tests yet — just **fail fast on bad code**.

---

## 0.1.7 Environment Strategy (important early)

### Decide envs

* **local**
* **dev**
* **prod**

Tasks:

* [ ] Create `.env.example`
* [ ] Define required vars:

```
DATABASE_URL=
APP_ENV=
LOG_LEVEL=
```

* [ ] Add env validation (zod or similar) in backend

---

## 0.1.8 README (Vision Lock-In)

This prevents scope drift.

Tasks:

* [ ] Write README with:

  * What this product is
  * What it is NOT
  * Core principles:

    * Checklist-first
    * ERD is source of truth
    * Safe by default
    * Postgres-first

---

## 0.1 DONE Definition of Done

You are finished with **0.1** when:

✅ Repo exists
✅ Monorepo structure in place
✅ Lint + Prettier enforced
✅ CI runs on PR
✅ Env strategy documented

---

## NEXT STEP (0.2)

After 0.1, the **correct next step is 0.2: Product Decisions Lock File**, where we freeze:

* supported DBs
* unsafe operations
* v1 cutline (what is explicitly out)

If you want, next I can:

* walk you through **0.2 interactively**, or
* jump straight into **1.1 App DB migrations** and start writing real SQL.

Just tell me:
**“Continue 0.2”** or **“Skip to App DB”**
