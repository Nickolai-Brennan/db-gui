## 1.8 Relationship-aware anchors (edges connect to the *exact column row*) + smarter routing

This upgrade makes your ERD “pro”: FK lines attach to the **specific FK columns** inside the child/parent table card, not just center-left/right.

We’ll do it in a way that doesn’t require measuring each text node manually every frame.

---

# A) Frontend changes (no backend changes)

## 1.8.01 Add constants for row geometry

Create `apps/web/src/erd/metrics.ts`

```ts
export const CARD = {
  headerH: 44,
  padX: 12,
  padY: 12,
  rowH: 20,        // height per column row
  rowsMax: 14,     // must match TableNodeCard render slice
  colListTop: 44 + 12 + 18, // header + padding + "Columns" label space
};
```

> If you tweak TableNode UI spacing later, update these constants once.

---

## 1.8.02 Anchor functions by column name

Update `apps/web/src/erd/anchors.ts` (replace contents with this enhanced version):

```ts
import type { Rect } from '../stores/erdStore';
import { CARD } from './metrics';

export function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

export function edgeSide(a: Rect, b: Rect) {
  // Prefer left→right flow; if target is left, flip
  const aMid = a.x + a.w / 2;
  const bMid = b.x + b.w / 2;
  return aMid <= bMid ? 'lr' : 'rl';
}

export function columnRowIndex(visibleColumns: string[], targetCols: string[]) {
  // pick first FK col that is visible and use its row index
  for (const c of targetCols) {
    const idx = visibleColumns.indexOf(c);
    if (idx >= 0) return idx;
  }
  // fallback: middle row
  return Math.floor(visibleColumns.length / 2);
}

export function anchorOnTableColumn(
  rect: Rect,
  side: 'left' | 'right',
  visibleColumns: string[],
  targetCols: string[],
) {
  const idx = columnRowIndex(visibleColumns, targetCols);
  const rowY = CARD.colListTop + idx * CARD.rowH + CARD.rowH / 2;

  const y = rect.y + clamp(rowY, CARD.headerH + 10, rect.h - 10);
  const x = side === 'left' ? rect.x : rect.x + rect.w;
  return { x, y };
}

export function bezierPath(a: { x: number; y: number }, b: { x: number; y: number }) {
  const dx = Math.max(80, Math.abs(b.x - a.x) * 0.35);
  const c1 = { x: a.x + (a.x < b.x ? dx : -dx), y: a.y };
  const c2 = { x: b.x + (a.x < b.x ? -dx : dx), y: b.y };
  return `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
}
```

---

## 1.8.03 Make TableNode expose “visible column names”

Your `TableNode` already has `columns[]`. We’ll use the first `rowsMax` names as the “visible list”.

No code changes needed in `TableNodeCard`—we just need access to the array in `ErdCanvas`.

---

## 1.8.04 Add edge routing that avoids crossing through cards (basic obstacle nudge)

We’ll add a “dogleg” option when nodes overlap horizontally.

Create `apps/web/src/erd/routing.ts`

```ts
export function doglegPath(
  a: { x: number; y: number },
  b: { x: number; y: number },
  offset = 40,
) {
  // Right-angle-ish with soft curves using 2 beziers
  const midX = a.x + (a.x < b.x ? offset : -offset);
  const midX2 = b.x + (a.x < b.x ? -offset : offset);

  const c1 = { x: midX, y: a.y };
  const c2 = { x: midX2, y: b.y };

  return `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
}

export function shouldDogleg(a: { x: number; y: number }, b: { x: number; y: number }) {
  // If mostly vertical or too close horizontally, dogleg looks cleaner
  const dx = Math.abs(b.x - a.x);
  const dy = Math.abs(b.y - a.y);
  return dx < 220 && dy > 80;
}
```

---

## 1.8.05 Patch `ErdCanvas` to compute anchors per relationship columns

In `apps/web/src/erd/ErdCanvas.tsx`:

### 1) New imports

```tsx
import { anchorOnTableColumn, edgeSide, bezierPath } from './anchors';
import { CARD } from './metrics';
import { doglegPath, shouldDogleg } from './routing';
```

### 2) Replace your `edgePaths` memo with this relationship-aware version

```tsx
const nodesByKey = useMemo(() => {
  const m = new Map<string, TableNode>();
  for (const n of nodes) m.set(n.key, n);
  return m;
}, [nodes]);

const edgePaths = useMemo(() => {
  const paths: { key: string; d: string; severity?: string; mid: { x: number; y: number }; label: string }[] = [];

  for (const e of edges) {
    const childRect = layout[e.childKey];
    const parentRect = layout[e.parentKey];
    const childNode = nodesByKey.get(e.childKey);
    const parentNode = nodesByKey.get(e.parentKey);

    if (!childRect || !parentRect || !childNode || !parentNode) continue;

    const flow = edgeSide(childRect, parentRect);
    const childSide = flow === 'lr' ? 'right' : 'left';
    const parentSide = flow === 'lr' ? 'left' : 'right';

    const childVisibleCols = childNode.columns.slice(0, CARD.rowsMax).map((c) => c.name);
    const parentVisibleCols = parentNode.columns.slice(0, CARD.rowsMax).map((c) => c.name);

    const a = anchorOnTableColumn(childRect, childSide, childVisibleCols, e.childCols);
    const b = anchorOnTableColumn(parentRect, parentSide, parentVisibleCols, e.parentCols);

    const d = shouldDogleg(a, b) ? doglegPath(a, b, 70) : bezierPath(a, b);
    const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    const label = `${e.name} • ${e.childCols.join(', ')} → ${e.parentCols.join(', ')}`;

    paths.push({ key: e.key, d, severity: e.severity, mid, label });
  }

  return paths;
}, [edges, layout, nodesByKey]);
```

That’s it—your interactive SVG edge layer from 1.7 will keep working because it consumes `edgePaths`.

---

# B) Optional: Column highlighting on hover (feels premium)

When hovering an edge, highlight the specific FK columns in both tables.

## 1.8.06 Store hoverEdge metadata

In `ErdCanvas` when you set hoverEdge, include:

* `childKey`, `parentKey`, `childCols`, `parentCols`

Update hover state type:

```tsx
const [hoverEdge, setHoverEdge] = useState<null | {
  key: string;
  x: number;
  y: number;
  label: string;
  childKey: string;
  parentKey: string;
  childCols: string[];
  parentCols: string[];
}>(null);
```

In the edge `onMouseEnter`, set those fields.

## 1.8.07 Pass highlight props to TableNodeCard

Patch `TableNodeCard` to accept optional highlight columns:

`TableNode.tsx`:

```tsx
export function TableNodeCard({ node, highlightCols }: { node: TableNode; highlightCols?: string[] }) {
  // ...
  const isHighlighted = (colName: string) => (highlightCols ?? []).includes(colName);
  // ...
  {node.columns.slice(0, 14).map((c) => (
    <div key={c.name} className="flex items-center justify-between gap-2">
      <div className="truncate">
        <span className={['font-medium', isHighlighted(c.name) ? 'underline' : ''].join(' ')}>
          {c.name}
        </span>
        ...
      </div>
      ...
    </div>
  ))}
```

Then, in `ErdCanvas` nodes layer:

```tsx
{nodes.map((n) => {
  const hl =
    hoverEdge && (hoverEdge.childKey === n.key || hoverEdge.parentKey === n.key)
      ? (hoverEdge.childKey === n.key ? hoverEdge.childCols : hoverEdge.parentCols)
      : undefined;

  return <TableNodeCard key={n.key} node={n} highlightCols={hl} />;
})}
```

---

# C) What you get after 1.8

* FK edges attach to **specific column row** inside the table cards
* Edges route more cleanly when tables are stacked
* (optional) FK columns highlight on hover

---

## Next upgrade after 1.8 (pick one)

* **1.9 Minimap + schema lanes + hide isolated tables**
* **2.0 Auto-layout using dagre/elkjs** for big databases (500+ tables)
