## 1.5 Postgres Introspection Snapshot API (for ERD rendering)

Goal: your frontend can call **one endpoint** and get everything needed to draw the ERD + populate the Inspector:

* tables
* columns
* primary keys + unique constraints
* foreign keys (relationships)
* indexes
* table sizes + row estimates (nice for UI)

We’ll build:

* `POST /api/v1/introspect/postgres/snapshot`
* `POST /api/v1/introspect/postgres/table-detail` (optional but great for Inspector)

> v1 approach: client passes `targetDatabaseUrl` (same as 1.4). Later: use `connectionId` + encrypted secrets.

---

# 1.5.01 Response model (normalize once)

Create `apps/api/src/introspect/types.ts`

```ts
export type PgSnapshot = {
  generatedAt: string;
  schemas: string[];

  tables: PgTable[];
  columns: PgColumn[];
  primaryKeys: PgPrimaryKey[];
  uniqueConstraints: PgUniqueConstraint[];
  foreignKeys: PgForeignKey[];
  indexes: PgIndex[];
};

export type PgTable = {
  schema: string;
  name: string;
  oid: number;
  kind: 'table' | 'partitioned_table';
  rowEstimate: number | null;
  totalBytes: number | null;
  tableBytes: number | null;
  indexBytes: number | null;
};

export type PgColumn = {
  schema: string;
  table: string;
  name: string;
  ordinal: number;
  dataType: string;
  isNullable: boolean;
  defaultExpr: string | null;
  isIdentity: boolean;
};

export type PgPrimaryKey = {
  schema: string;
  table: string;
  name: string;
  columns: string[];
};

export type PgUniqueConstraint = {
  schema: string;
  table: string;
  name: string;
  columns: string[];
  isPrimary: boolean;
};

export type PgForeignKey = {
  name: string;
  childSchema: string;
  childTable: string;
  childCols: string[];
  parentSchema: string;
  parentTable: string;
  parentCols: string[];
  onDelete: string;
  onUpdate: string;
  deferrable: boolean;
  initiallyDeferred: boolean;
};

export type PgIndex = {
  schema: string;
  table: string;
  name: string;
  method: string;
  isUnique: boolean;
  isPrimary: boolean;
  isValid: boolean;
  columns: string[];      // leading columns in order (best-effort)
  predicate: string | null;
  definition: string;     // pg_get_indexdef
};
```

---

# 1.5.02 Introspection queries (Postgres)

Create `apps/api/src/introspect/pgQueries.ts`

```ts
export const qTables = `
SELECT
  n.nspname AS schema,
  c.relname AS name,
  c.oid     AS oid,
  CASE c.relkind
    WHEN 'r' THEN 'table'
    WHEN 'p' THEN 'partitioned_table'
    ELSE 'table'
  END       AS kind,
  c.reltuples::bigint AS row_estimate,

  pg_total_relation_size(c.oid)::bigint AS total_bytes,
  pg_relation_size(c.oid)::bigint AS table_bytes,
  pg_indexes_size(c.oid)::bigint AS index_bytes
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = ANY($1::text[])
  AND c.relkind IN ('r','p') -- ordinary + partitioned tables
ORDER BY n.nspname, c.relname;
`;

export const qColumns = `
SELECT
  n.nspname AS schema,
  c.relname AS table,
  a.attname AS name,
  a.attnum  AS ordinal,
  pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
  NOT a.attnotnull AS is_nullable,
  pg_get_expr(ad.adbin, ad.adrelid) AS default_expr,
  a.attidentity IN ('a','d') AS is_identity
FROM pg_attribute a
JOIN pg_class c ON c.oid = a.attrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
WHERE n.nspname = ANY($1::text[])
  AND c.relkind IN ('r','p')
  AND a.attnum > 0
  AND NOT a.attisdropped
ORDER BY n.nspname, c.relname, a.attnum;
`;

export const qPrimaryKeys = `
SELECT
  n.nspname AS schema,
  c.relname AS table,
  con.conname AS name,
  array_agg(a.attname ORDER BY x.ord) AS columns
FROM pg_constraint con
JOIN pg_class c ON c.oid = con.conrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN LATERAL unnest(con.conkey) WITH ORDINALITY AS x(attnum, ord) ON true
JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = x.attnum
WHERE n.nspname = ANY($1::text[])
  AND con.contype = 'p'
GROUP BY n.nspname, c.relname, con.conname
ORDER BY n.nspname, c.relname, con.conname;
`;

export const qUniqueConstraints = `
SELECT
  n.nspname AS schema,
  c.relname AS table,
  con.conname AS name,
  con.contype = 'p' AS is_primary,
  array_agg(a.attname ORDER BY x.ord) AS columns
FROM pg_constraint con
JOIN pg_class c ON c.oid = con.conrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN LATERAL unnest(con.conkey) WITH ORDINALITY AS x(attnum, ord) ON true
JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = x.attnum
WHERE n.nspname = ANY($1::text[])
  AND con.contype IN ('u','p')
GROUP BY n.nspname, c.relname, con.conname, con.contype
ORDER BY n.nspname, c.relname, con.contype, con.conname;
`;

export const qForeignKeys = `
SELECT
  con.conname AS name,
  n_child.nspname AS child_schema,
  c_child.relname AS child_table,
  array_agg(a_child.attname ORDER BY x.ord) AS child_cols,

  n_parent.nspname AS parent_schema,
  c_parent.relname AS parent_table,
  array_agg(a_parent.attname ORDER BY x.ord) AS parent_cols,

  con.confdeltype AS on_delete_code,
  con.confupdtype AS on_update_code,
  con.condeferrable AS deferrable,
  con.condeferred  AS initially_deferred
FROM pg_constraint con
JOIN pg_class c_child ON c_child.oid = con.conrelid
JOIN pg_namespace n_child ON n_child.oid = c_child.relnamespace
JOIN pg_class c_parent ON c_parent.oid = con.confrelid
JOIN pg_namespace n_parent ON n_parent.oid = c_parent.relnamespace
JOIN LATERAL unnest(con.conkey) WITH ORDINALITY AS x(attnum, ord) ON true
JOIN pg_attribute a_child ON a_child.attrelid = c_child.oid AND a_child.attnum = x.attnum
JOIN LATERAL unnest(con.confkey) WITH ORDINALITY AS y(attnum, ord) ON y.ord = x.ord
JOIN pg_attribute a_parent ON a_parent.attrelid = c_parent.oid AND a_parent.attnum = y.attnum
WHERE con.contype = 'f'
  AND n_child.nspname = ANY($1::text[])
GROUP BY
  con.conname,
  n_child.nspname, c_child.relname,
  n_parent.nspname, c_parent.relname,
  con.confdeltype, con.confupdtype,
  con.condeferrable, con.condeferred
ORDER BY n_child.nspname, c_child.relname, con.conname;
`;

export const qIndexes = `
SELECT
  n.nspname AS schema,
  c.relname AS table,
  ic.relname AS name,
  am.amname  AS method,
  i.indisunique AS is_unique,
  i.indisprimary AS is_primary,
  i.indisvalid AS is_valid,
  pg_get_expr(i.indpred, i.indrelid) AS predicate,
  pg_get_indexdef(i.indexrelid) AS definition,

  -- best-effort leading columns
  array_remove(array_agg(a.attname ORDER BY x.ord), NULL) AS columns
FROM pg_index i
JOIN pg_class c ON c.oid = i.indrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN pg_class ic ON ic.oid = i.indexrelid
JOIN pg_am am ON am.oid = ic.relam
LEFT JOIN LATERAL unnest(i.indkey) WITH ORDINALITY AS x(attnum, ord) ON true
LEFT JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = x.attnum
WHERE n.nspname = ANY($1::text[])
  AND c.relkind IN ('r','p')
GROUP BY
  n.nspname, c.relname, ic.relname, am.amname,
  i.indisunique, i.indisprimary, i.indisvalid, i.indpred, i.indrelid, i.indexrelid
ORDER BY n.nspname, c.relname, ic.relname;
`;
```

We need to map `confdeltype/confupdtype` codes to readable strings.

Create `apps/api/src/introspect/pgMaps.ts`

```ts
export function fkAction(code: string): string {
  // Postgres codes: a=NO ACTION, r=RESTRICT, c=CASCADE, n=SET NULL, d=SET DEFAULT
  switch (code) {
    case 'a': return 'NO ACTION';
    case 'r': return 'RESTRICT';
    case 'c': return 'CASCADE';
    case 'n': return 'SET NULL';
    case 'd': return 'SET DEFAULT';
    default: return code;
  }
}
```

---

# 1.5.03 Snapshot service (one call returns everything)

Create `apps/api/src/introspect/pgSnapshot.ts`

```ts
import type { Pool } from 'pg';
import { createTargetPool } from '../targetDb';
import {
  qTables, qColumns, qPrimaryKeys, qUniqueConstraints, qForeignKeys, qIndexes
} from './pgQueries';
import { fkAction } from './pgMaps';
import type { PgSnapshot } from './types';

export async function getPgSnapshot(targetDatabaseUrl: string, schemas: string[]): Promise<PgSnapshot> {
  const pool: Pool = createTargetPool(targetDatabaseUrl);

  try {
    const [tables, columns, pks, uniques, fksRaw, indexes] = await Promise.all([
      pool.query(qTables, [schemas]),
      pool.query(qColumns, [schemas]),
      pool.query(qPrimaryKeys, [schemas]),
      pool.query(qUniqueConstraints, [schemas]),
      pool.query(qForeignKeys, [schemas]),
      pool.query(qIndexes, [schemas]),
    ]);

    const foreignKeys = fksRaw.rows.map((r: any) => ({
      name: r.name,
      childSchema: r.child_schema,
      childTable: r.child_table,
      childCols: r.child_cols,
      parentSchema: r.parent_schema,
      parentTable: r.parent_table,
      parentCols: r.parent_cols,
      onDelete: fkAction(r.on_delete_code),
      onUpdate: fkAction(r.on_update_code),
      deferrable: r.deferrable,
      initiallyDeferred: r.initially_deferred,
    }));

    return {
      generatedAt: new Date().toISOString(),
      schemas,
      tables: tables.rows.map((r: any) => ({
        schema: r.schema,
        name: r.name,
        oid: Number(r.oid),
        kind: r.kind,
        rowEstimate: r.row_estimate != null ? Number(r.row_estimate) : null,
        totalBytes: r.total_bytes != null ? Number(r.total_bytes) : null,
        tableBytes: r.table_bytes != null ? Number(r.table_bytes) : null,
        indexBytes: r.index_bytes != null ? Number(r.index_bytes) : null,
      })),
      columns: columns.rows.map((r: any) => ({
        schema: r.schema,
        table: r.table,
        name: r.name,
        ordinal: Number(r.ordinal),
        dataType: r.data_type,
        isNullable: Boolean(r.is_nullable),
        defaultExpr: r.default_expr ?? null,
        isIdentity: Boolean(r.is_identity),
      })),
      primaryKeys: pks.rows.map((r: any) => ({
        schema: r.schema,
        table: r.table,
        name: r.name,
        columns: r.columns,
      })),
      uniqueConstraints: uniques.rows.map((r: any) => ({
        schema: r.schema,
        table: r.table,
        name: r.name,
        columns: r.columns,
        isPrimary: Boolean(r.is_primary),
      })),
      foreignKeys,
      indexes: indexes.rows.map((r: any) => ({
        schema: r.schema,
        table: r.table,
        name: r.name,
        method: r.method,
        isUnique: Boolean(r.is_unique),
        isPrimary: Boolean(r.is_primary),
        isValid: Boolean(r.is_valid),
        columns: r.columns ?? [],
        predicate: r.predicate ?? null,
        definition: r.definition,
      })),
    };
  } finally {
    await pool.end().catch(() => {});
  }
}
```

---

# 1.5.04 Add routes

Create `apps/api/src/routes/introspect.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { getPgSnapshot } from '../introspect/pgSnapshot';

export async function introspectRoutes(app: FastifyInstance) {
  app.post('/api/v1/introspect/postgres/snapshot', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      schemas: z.array(z.string().min(1)).min(1),
    });
    const body = Body.parse(req.body);

    const snapshot = await getPgSnapshot(body.targetDatabaseUrl, body.schemas);
    return { snapshot };
  });
}
```

Wire into `apps/api/src/index.ts`:

```ts
import { introspectRoutes } from './routes/introspect';
await app.register(introspectRoutes);
```

---

# 1.5.05 Optional: Table detail endpoint (nice Inspector)

This gives richer per-table detail without shipping entire snapshot.

Add to `apps/api/src/routes/introspect.ts`:

```ts
import { createTargetPool } from '../targetDb';
import { qColumns, qIndexes } from '../introspect/pgQueries';

app.post('/api/v1/introspect/postgres/table-detail', async (req) => {
  const Body = z.object({
    targetDatabaseUrl: z.string().min(10),
    schema: z.string().min(1),
    table: z.string().min(1),
  });
  const body = Body.parse(req.body);

  const pool = createTargetPool(body.targetDatabaseUrl);
  try {
    const schemas = [body.schema];

    const [colsRes, idxRes] = await Promise.all([
      pool.query(qColumns, [schemas]),
      pool.query(qIndexes, [schemas]),
    ]);

    const columns = colsRes.rows.filter((r: any) => r.schema === body.schema && r.table === body.table);
    const indexes = idxRes.rows.filter((r: any) => r.schema === body.schema && r.table === body.table);

    return { schema: body.schema, table: body.table, columns, indexes };
  } finally {
    await pool.end().catch(() => {});
  }
});
```

---

# 1.5.06 Smoke test

POST `/api/v1/introspect/postgres/snapshot`

```json
{
  "targetDatabaseUrl": "postgresql://user:pass@localhost:5432/target_db",
  "schemas": ["public"]
}
```

You should get:

* `snapshot.tables[]`
* `snapshot.columns[]`
* `snapshot.foreignKeys[]`
* `snapshot.indexes[]`

This is enough to render:

* table boxes (columns list)
* FK edges
* table badges (from annotations endpoint in 1.4)
* index indicators (FK indexed check visuals)

---

# 1.5 Definition of Done

* [ ] Snapshot endpoint returns full ERD dataset for selected schemas
* [ ] Foreign keys include child/parent cols and actions
* [ ] Indexes include leading columns and validity
* [ ] Frontend can render ERD graph from snapshot + overlay annotations

---

## Next step (1.6) recommended

**Frontend ERD v1 rendering** (React + canvas + pan/zoom + inspector) + overlay annotations.

Say **“1.6”** and I’ll give you the full frontend blueprint (routes, state, components, data flow, and a minimal ERD renderer plan).
