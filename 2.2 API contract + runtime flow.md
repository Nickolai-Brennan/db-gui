Got it — next most important is the **API contract + runtime flow**, so frontend can build the Builder/Dashboard/ERD binding immediately, and backend can implement in a straight line.

Below is the **minimum set of endpoints + payloads + compute rules** to start development now.

---

## 1) Development Sequence I recommend (fastest path to a working product)

### Sprint 1: Template Builder (no DB introspection yet)

1. Templates list/create
2. Version create (draft)
3. Node tree CRUD (add/move/delete)
4. Publish version (lock)

✅ Result: you can build and save checklists

### Sprint 2: Instances + Dashboard (still no DB checks)

5. Create instance from published template
6. Manual item check/uncheck + notes
7. Compute status rollups (counts + blocked/warn)
8. Dashboard UI reading instance summary

✅ Result: dashboard becomes real

### Sprint 3: Auto checks + ERD annotations

9. Run automatic checks (builtin first: missing PK, FK not indexed)
10. Save results with target_ref
11. ERD highlights + “Fix” actions

✅ Result: checklist truly becomes the control plane

---

## 2) Minimal API Contract (REST, clean and buildable)

Base: `/api/v1`

### 2.1 Templates

**GET** `/workspaces/:wsId/checklist-templates`
Returns list.

**POST** `/workspaces/:wsId/checklist-templates`

```json
{ "slug":"erd-health", "title":"ERD Health", "description":"Core integrity checks" }
```

**GET** `/checklist-templates/:templateId`
Returns template metadata + latest versions.

---

### 2.2 Versions

**POST** `/checklist-templates/:templateId/versions`

```json
{ "version":"1.0.0", "status":"draft" }
```

**POST** `/checklist-template-versions/:versionId/publish`

* sets status=published, published_at=now
* makes nodes immutable

---

### 2.3 Nodes (Tree CRUD)

**GET** `/checklist-template-versions/:versionId/nodes`
Returns a **nested tree** (frontend needs this).

**POST** `/checklist-template-versions/:versionId/nodes`
Create node.

```json
{
  "parentId": null,
  "sortOrder": 10,
  "nodeType": "group",
  "title": "Relationships",
  "description": ""
}
```

**PATCH** `/checklist-nodes/:nodeId`
Update fields (title, severity, sql_template, etc.)

**POST** `/checklist-template-versions/:versionId/nodes/reorder`
Batch move/reorder (drag+drop).

```json
{
  "moves": [
    { "nodeId":"...", "newParentId":"...", "newSortOrder":20 }
  ]
}
```

**DELETE** `/checklist-nodes/:nodeId`

---

## 3) Tree Response Shape (Nested, UI-ready)

**GET** `/checklist-template-versions/:versionId/nodes`

```json
{
  "versionId":"...",
  "templateId":"...",
  "root": {
    "id":"root",
    "children":[
      {
        "id":"sec-1",
        "nodeType":"group",
        "title":"ERD Integrity",
        "children":[
          {
            "id":"sub-1",
            "nodeType":"group",
            "title":"Primary Keys",
            "children":[
              {
                "id":"item-1",
                "nodeType":"item",
                "title":"All tables have a primary key",
                "itemType":"automatic",
                "severity":"blocking",
                "blocksAction":true,
                "scopeType":"table",
                "targetSelector":{"mode":"all_tables"},
                "checkKind":"BUILTIN",
                "checkRef":"NO_PRIMARY_KEY",
                "children":[]
              }
            ]
          }
        ]
      }
    ]
  }
}
```

Frontend can render this directly into the builder tree.

---

## 4) Instances API (what powers the Dashboard)

### 4.1 Create instance

**POST** `/workspaces/:wsId/checklist-instances`

```json
{
  "connectionId":"...",
  "templateVersionId":"...",
  "scopeType":"diagram",
  "scopeRef": { "schemas":["public","stats"], "diagramId":"diag-123" }
}
```

Returns instance summary with counts.

### 4.2 Get instance summary (dashboard card)

**GET** `/checklist-instances/:instanceId`

```json
{
  "id":"...",
  "status":"blocked",
  "blockingCount":2,
  "warningCount":1,
  "failCount":0,
  "lastRunAt":"2026-02-06T12:00:00Z",
  "scopeRef": { "schemas":["public","stats"], "diagramId":"diag-123" }
}
```

### 4.3 Get instance tree with computed statuses (for the checklist UI)

**GET** `/checklist-instances/:instanceId/tree`
Returns the same nested shape as templates, but each node includes:

* `computedStatus`
* `counts`
* item result payload

### 4.4 List “issues queue” (dashboard work queue)

**GET** `/checklist-instances/:instanceId/issues?severity=blocking,warning`
Returns flattened list with deep links + fix actions.

```json
[
  {
    "resultId":"res-1",
    "severity":"blocking",
    "status":"blocked",
    "code":"FK_HAS_VIOLATIONS",
    "title":"FK violations exist",
    "sectionPath":["ERD Integrity","Relationships","Integrity"],
    "targetRef":{"kind":"relationship","childSchema":"stats","childTable":"game","childCols":["player_id"],"parentSchema":"stats","parentTable":"player","parentCols":["id"]},
    "suggestedFix":{"label":"Open violating rows","actionId":"OPEN_VIOLATIONS"},
    "deepLink":{"page":"erd","focus":"relationship","ref":{...}}
  }
]
```

---

## 5) Results API (manual checks + evidence)

### 5.1 Update a manual item

**PATCH** `/checklist-instance-results/:resultId`

```json
{
  "status":"pass",
  "note":"Reviewed manually; OK for dev",
  "checkedBy":"nick"
}
```

### 5.2 Add evidence

**POST** `/checklist-instance-results/:resultId/evidence`

```json
{ "kind":"sql", "label":"Precheck query", "content":"SELECT ..." }
```

---

## 6) Running Automatic Checks (builtin first)

### 6.1 Run all checks

**POST** `/checklist-instances/:instanceId/run`

```json
{ "mode":"all" }
```

### 6.2 Run subset (selected items)

**POST** `/checklist-instances/:instanceId/run`

```json
{ "mode":"items", "nodeIds":["item-1","item-7"] }
```

Backend behavior:

* Loads template version nodes
* For each automatic item:

  * if BUILTIN → execute builtin check logic
  * if SQL_TEMPLATE → run query with variables (schemas, etc.)
* Writes `checklist_instance_results`
* Recomputes rollups on instance

---

## 7) Status Computation Rules (backend truth)

### Item result → item status

* automatic check returns 0 rows => `pass`
* returns rows > 0:

  * if severity=blocking => `blocked`
  * else severity=warning => `warning`
  * else => `fail`

### Group computedStatus

* if any descendant `blocked` => `blocked`
* else if any `fail` => `fail`
* else if any `warning` => `warning`
* else if all leaves `pass` => `pass`
* else `incomplete`

### Instance status

Same rule across all results.

---

## 8) ERD Binding Endpoint (so canvas can paint issues fast)

**GET** `/checklist-instances/:instanceId/annotations`
Returns only what the ERD needs:

```json
{
  "tables": [
    { "schema":"stats","table":"game","severity":"warning","count":1 }
  ],
  "relationships": [
    {
      "childSchema":"stats","childTable":"game","childCols":["player_id"],
      "parentSchema":"stats","parentTable":"player","parentCols":["id"],
      "severity":"blocking",
      "codes":["FK_HAS_VIOLATIONS"],
      "fix":{"label":"View violations","actionId":"OPEN_VIOLATIONS"}
    }
  ]
}
```

The ERD paints this without loading full checklist trees.

---

## 9) “Fix Actions” Contract (optional but powerful now)

Fix actions are consistent objects so UI can render buttons:

```json
{ "actionId":"AUTO_CREATE_INDEX", "payload":{"schema":"stats","table":"game","columns":["player_id"]}}
```

Actions to implement first:

* `AUTO_CREATE_INDEX`
* `OPEN_VIOLATIONS`
* `OPEN_RELATIONSHIP_EDITOR`
* `OPEN_TABLE_KEYS_EDITOR`

---

## Next build artifact I recommend

A **frontend state model + component list** so you can start building screens immediately:

* ChecklistBuilderTree
* NodeEditorPanel
* InstanceWorkQueue
* DashboardCards
* ERDAnnotationLayer

If you want, I’ll output:

* the component inventory
* route map
* minimal state atoms/stores (Zustand/Redux)
* and the exact UI interactions (drag/drop, keyboard)

Say **“Frontend blueprint”** and I’ll deliver it.
