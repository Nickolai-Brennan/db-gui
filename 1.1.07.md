## Step 1.1.07 — Built‑in Checks Registry (Automatic Checklist Engine) (exact)

Goal: implement the **check runtime** that evaluates catalog state and returns
normalized checklist results.

Reference: _Master Checklist §4.3 Builtin checks. fileciteturn2file0

---

# 1.1.07a) Check interface (authoritative)

```ts
export interface CheckContext {
  snapshot: CatalogSnapshot;
  connectionId: string;
  schemaScope: string[];
}

export interface CheckResult {
  code: string;
  severity: "info" | "warning" | "error" | "blocking";
  title: string;
  detail?: string;
  targetRef: TargetRef;
  stats?: Record<string, number>;
}

export interface BuiltinCheck {
  id: string;
  run(ctx: CheckContext): CheckResult[];
}
```

---

# 1.1.07b) Required built‑in checks (v1)

Implement exactly these IDs:

- `NO_PRIMARY_KEY`
- `FK_NOT_INDEXED`
- `FK_HAS_VIOLATIONS`
- `FK_BROKEN`
- `FK_REFERENCES_NON_UNIQUE_PARENT`
- `RISKY_CASCADE`

Each check:
- runs purely on snapshot + optional sampled SQL
- returns **0+ results**
- never mutates state

---

# 1.1.07c) Example: NO_PRIMARY_KEY

Logic:
- iterate tables
- if `primaryKey` missing → emit result

```ts
{
  code: "NO_PRIMARY_KEY",
  severity: "blocking",
  title: "Table has no primary key",
  targetRef: { kind:"table", schema, table }
}
```

---

# 1.1.07d) Registry wiring

Create a registry map:

```ts
const registry: Record<string, BuiltinCheck> = {
  NO_PRIMARY_KEY,
  FK_NOT_INDEXED,
  ...
};
```

Checklist runner:
- resolves `checkId`
- invokes `run(ctx)`
- maps results to `checklist_instance_result`

---

# Done criteria for 1.1.07

✅ All required checks registered  
✅ Checks return stable, deterministic results  
✅ Results map cleanly to TargetRef  
✅ Same snapshot → same results

---
