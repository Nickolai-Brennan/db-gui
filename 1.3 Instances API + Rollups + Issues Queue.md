## 1.3 Instances API + Rollups + Issues Queue (Fastify) — exact routes + logic

Goal: you can **create an instance** from a published template version, **run/track manual results**, **compute rollups**, and power the **Dashboard** with an issues queue.

We’ll implement:

* Create instance
* Get instance summary
* Get instance tree (nodes + computed statuses)
* Issues queue (flattened)
* Update manual result
* (Stub) Run checks endpoint (we’ll wire to engine in 1.4)

---

# 1.3.01 Add shared status computation helpers

Create `apps/api/src/checklist/compute.ts`

```ts
import type { ResultStatus, Severity } from '@db-gui/shared';

export function statusFromSeverity(sev: Severity): ResultStatus {
  if (sev === 'blocking') return 'blocked';
  if (sev === 'warning') return 'warning';
  if (sev === 'error') return 'fail';
  return 'fail';
}

// Roll up many leaf statuses to a group status
export function rollupStatus(statuses: ResultStatus[]): ResultStatus {
  if (statuses.includes('blocked')) return 'blocked';
  if (statuses.includes('fail')) return 'fail';
  if (statuses.includes('warning')) return 'warning';
  // if every leaf is pass -> pass
  if (statuses.length > 0 && statuses.every((s) => s === 'pass')) return 'pass';
  // otherwise incomplete (unchecked exists)
  return 'unchecked';
}

export function instanceStatusFromCounts(blocking: number, fail: number, warning: number) {
  if (blocking > 0) return 'blocked';
  if (fail > 0) return 'fail';
  if (warning > 0) return 'warning';
  return 'pass';
}
```

---

# 1.3.02 Add “ensure result rows exist” helper

Create `apps/api/src/checklist/ensureResults.ts`

```ts
import { query } from '../sql';
import type { UUID } from '../types';

export async function ensureInstanceResults(instanceId: UUID) {
  // Insert missing result rows for every item node in the template version
  // Default to unchecked/manual until run.
  await query(
    `
    INSERT INTO checklist_instance_results (instance_id, node_id, status, severity, run_type)
    SELECT
      i.id AS instance_id,
      n.id AS node_id,
      'unchecked' AS status,
      COALESCE(n.severity, 'warning') AS severity,
      COALESCE(n.item_type, 'manual') AS run_type
    FROM checklist_instances i
    JOIN checklist_template_versions v ON v.id = i.template_version_id
    JOIN checklist_nodes n ON n.template_version_id = v.id
    WHERE i.id = $1
      AND n.node_type = 'item'
      AND NOT EXISTS (
        SELECT 1 FROM checklist_instance_results r
        WHERE r.instance_id = i.id AND r.node_id = n.id
      )
    `,
    [instanceId],
  );
}
```

---

# 1.3.03 Add Issues query helper (flattened queue)

Create `apps/api/src/checklist/issues.ts`

```ts
import { query } from '../sql';
import type { UUID } from '../types';

export async function getInstanceIssues(instanceId: UUID, severities?: string[]) {
  const sevFilter = severities?.length ? severities : null;

  const rows = await query<any>(
    `
    SELECT
      r.id            AS result_id,
      r.status        AS result_status,
      r.severity      AS result_severity,
      r.target_ref    AS target_ref,
      n.title         AS node_title,
      n.check_ref     AS code,
      n.template_version_id,
      n.id            AS node_id
    FROM checklist_instance_results r
    JOIN checklist_nodes n ON n.id = r.node_id
    WHERE r.instance_id = $1
      AND r.status IN ('blocked','fail','warning')
      AND ($2::text[] IS NULL OR r.severity = ANY($2::text[]))
    ORDER BY
      CASE r.status
        WHEN 'blocked' THEN 1
        WHEN 'fail' THEN 2
        WHEN 'warning' THEN 3
        ELSE 9
      END,
      r.updated_at DESC
    LIMIT 500
    `,
    [instanceId, sevFilter],
  );

  return rows.map((r: any) => ({
    resultId: r.result_id,
    severity: r.result_severity,
    status: r.result_status,
    code: r.code ?? 'CHECK',
    title: r.node_title,
    targetRef: r.target_ref,
    // sectionPath: filled in 1.3.06 (tree path computation)
  }));
}
```

---

# 1.3.04 Add Rollup updater (instance counts/status)

Create `apps/api/src/checklist/rollup.ts`

```ts
import { queryOne } from '../sql';
import type { UUID } from '../types';
import { instanceStatusFromCounts } from './compute';

export async function recomputeInstanceRollup(instanceId: UUID) {
  const counts = await queryOne<{
    blocking_count: number;
    fail_count: number;
    warning_count: number;
  }>(
    `
    SELECT
      SUM(CASE WHEN status = 'blocked' THEN 1 ELSE 0 END)::int AS blocking_count,
      SUM(CASE WHEN status = 'fail' THEN 1 ELSE 0 END)::int AS fail_count,
      SUM(CASE WHEN status = 'warning' THEN 1 ELSE 0 END)::int AS warning_count
    FROM checklist_instance_results
    WHERE instance_id = $1
    `,
    [instanceId],
  );

  const status = instanceStatusFromCounts(counts.blocking_count, counts.fail_count, counts.warning_count);

  await queryOne<any>(
    `
    UPDATE checklist_instances
    SET status = $2,
        blocking_count = $3,
        fail_count = $4,
        warning_count = $5,
        last_run_at = now()
    WHERE id = $1
    RETURNING id
    `,
    [instanceId, status, counts.blocking_count, counts.fail_count, counts.warning_count],
  );

  return { status, ...counts };
}
```

---

# 1.3.05 Instance routes

Create `apps/api/src/routes/instances.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { query, queryOne } from '../sql';
import type { UUID } from '../types';
import { ensureInstanceResults } from '../checklist/ensureResults';
import { recomputeInstanceRollup } from '../checklist/rollup';
import { getInstanceIssues } from '../checklist/issues';

const UUIDSchema = z.string().uuid();

export async function instancesRoutes(app: FastifyInstance) {
  // -------------------------
  // Create instance
  // -------------------------
  app.post('/api/v1/workspaces/:wsId/checklist-instances', async (req) => {
    const wsId = UUIDSchema.parse((req.params as any).wsId);

    const Body = z.object({
      connectionId: z.string().uuid().nullable().optional(),
      templateVersionId: z.string().uuid(),
      scopeType: z.enum(['diagram', 'schema', 'table', 'migration_step']),
      scopeRef: z.record(z.any()),
      createdBy: z.string().max(200).optional(),
    });
    const body = Body.parse(req.body);

    // Enforce published template version
    const ver = await queryOne<any>(
      `SELECT id, status FROM checklist_template_versions WHERE id=$1`,
      [body.templateVersionId],
    );
    if (ver.status !== 'published') {
      return app.httpErrors.conflict('Template version must be published to create an instance.');
    }

    const row = await queryOne<any>(
      `
      INSERT INTO checklist_instances (
        workspace_id, connection_id, template_version_id,
        scope_type, scope_ref, status,
        created_by
      )
      VALUES ($1, $2, $3, $4, $5, 'incomplete', $6)
      RETURNING *
      `,
      [
        wsId,
        body.connectionId ?? null,
        body.templateVersionId,
        body.scopeType,
        body.scopeRef,
        body.createdBy ?? null,
      ],
    );

    // Ensure result rows for all items exist (unchecked)
    await ensureInstanceResults(row.id);
    await recomputeInstanceRollup(row.id);

    return { instance: row };
  });

  // -------------------------
  // Get instance summary
  // -------------------------
  app.get('/api/v1/checklist-instances/:instanceId', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    const row = await queryOne<any>(
      `SELECT *
       FROM checklist_instances
       WHERE id=$1`,
      [instanceId],
    );

    return { instance: row };
  });

  // -------------------------
  // Instance tree (nodes + results)
  // -------------------------
  app.get('/api/v1/checklist-instances/:instanceId/tree', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    // load instance
    const inst = await queryOne<any>(
      `SELECT id, template_version_id FROM checklist_instances WHERE id=$1`,
      [instanceId],
    );

    // ensure result rows exist (in case template changed later, etc.)
    await ensureInstanceResults(instanceId);

    const nodes = await query<any>(
      `
      SELECT
        n.*,
        r.id          AS result_id,
        r.status      AS result_status,
        r.severity    AS result_severity,
        r.target_ref  AS result_target_ref,
        r.output_summary,
        r.output_stats,
        r.output_rows,
        r.note,
        r.checked_by,
        r.updated_at
      FROM checklist_nodes n
      LEFT JOIN checklist_instance_results r
        ON r.node_id = n.id AND r.instance_id = $1
      WHERE n.template_version_id = $2
      ORDER BY n.sort_order ASC, n.created_at ASC
      `,
      [instanceId, inst.template_version_id],
    );

    // Build tree
    const byId = new Map<string, any>();
    const childrenByParent = new Map<string | null, any[]>();

    for (const n of nodes) {
      const node = {
        id: n.id,
        parentId: n.parent_id,
        sortOrder: n.sort_order,
        nodeType: n.node_type,
        title: n.title,
        description: n.description,

        // item props
        itemType: n.item_type,
        severity: n.severity,
        blocksAction: n.blocks_action,
        required: n.required,
        scopeType: n.scope_type,
        targetSelector: n.target_selector,
        checkKind: n.check_kind,
        checkRef: n.check_ref,
        sqlTemplate: n.sql_template,
        resultMapping: n.result_mapping,
        passFailRule: n.pass_fail_rule,
        fixKind: n.fix_kind,
        fixInstructions: n.fix_instructions,
        fixSqlTemplate: n.fix_sql_template,

        // result (if item)
        result: n.node_type === 'item'
          ? {
              id: n.result_id,
              status: n.result_status,
              severity: n.result_severity,
              targetRef: n.result_target_ref,
              outputSummary: n.output_summary,
              outputStats: n.output_stats,
              outputRows: n.output_rows,
              note: n.note,
              checkedBy: n.checked_by,
              updatedAt: n.updated_at,
            }
          : null,

        children: [] as any[],
      };

      byId.set(node.id, node);
      const key = node.parentId ?? null;
      const list = childrenByParent.get(key) ?? [];
      list.push(node);
      childrenByParent.set(key, list);
    }

    for (const node of byId.values()) {
      node.children = (childrenByParent.get(node.id) ?? []).sort((a, b) => a.sortOrder - b.sortOrder);
    }

    const roots = (childrenByParent.get(null) ?? []).sort((a, b) => a.sortOrder - b.sortOrder);

    return { instanceId, roots };
  });

  // -------------------------
  // Issues queue
  // -------------------------
  app.get('/api/v1/checklist-instances/:instanceId/issues', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    const Query = z.object({
      severity: z.string().optional(), // e.g. "blocking,warning"
    });
    const q = Query.parse(req.query);

    const severities = q.severity ? q.severity.split(',').map((s) => s.trim()) : undefined;
    const issues = await getInstanceIssues(instanceId, severities);

    return { instanceId, issues };
  });

  // -------------------------
  // Update a manual result (status + note)
  // -------------------------
  app.patch('/api/v1/checklist-instance-results/:resultId', async (req) => {
    const resultId = UUIDSchema.parse((req.params as any).resultId);

    const Body = z.object({
      status: z.enum(['unchecked','pass','warning','fail','blocked']).optional(),
      note: z.string().max(10000).nullable().optional(),
      checkedBy: z.string().max(200).nullable().optional(),
    });
    const body = Body.parse(req.body);

    // update
    const fields: string[] = [];
    const values: any[] = [];
    let i = 1;

    const set = (col: string, val: any) => {
      fields.push(`${col}=$${i++}`);
      values.push(val);
    };

    if (body.status !== undefined) set('status', body.status);
    if (body.note !== undefined) set('note', body.note);
    if (body.checkedBy !== undefined) set('checked_by', body.checkedBy);

    if (fields.length === 0) return { ok: true };

    // always bump updated_at and ran_at for manual touches
    fields.push(`updated_at=now()`);
    values.push(resultId);

    const updated = await queryOne<any>(
      `UPDATE checklist_instance_results
       SET ${fields.join(', ')}, ran_at = COALESCE(ran_at, now())
       WHERE id=$${i}
       RETURNING instance_id`,
      values,
    );

    // recompute instance rollup
    const rollup = await recomputeInstanceRollup(updated.instance_id);

    return { ok: true, rollup };
  });

  // -------------------------
  // Run checks (stub for now)
  // -------------------------
  app.post('/api/v1/checklist-instances/:instanceId/run', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    // 1.4 will implement actual execution.
    // For now, just ensure rows exist and recompute (no-op).
    await ensureInstanceResults(instanceId);
    const rollup = await recomputeInstanceRollup(instanceId);

    return { ok: true, rollup, message: 'Runner not implemented yet (see 1.4).' };
  });
}
```

---

# 1.3.06 Wire instances routes into API

Edit `apps/api/src/index.ts`:

```ts
import './env';
import Fastify from 'fastify';
import fastifySensible from '@fastify/sensible';
import { templatesRoutes } from './routes/templates';
import { instancesRoutes } from './routes/instances';

const app = Fastify({ logger: true });
await app.register(fastifySensible);

await app.register(templatesRoutes);
await app.register(instancesRoutes);

app.get('/health', async () => ({ ok: true }));

const port = Number(process.env.PORT ?? 3001);
const host = process.env.HOST ?? '0.0.0.0';
await app.listen({ port, host });
```

---

# Quick Smoke Test (manual)

1. Find workspace + template version:

```sql
SELECT id FROM workspaces LIMIT 1;

SELECT v.id, t.slug, v.status
FROM checklist_template_versions v
JOIN checklist_templates t ON t.id=v.template_id
ORDER BY t.slug, v.created_at DESC;
```

2. Create instance (example)
   POST `/api/v1/workspaces/:wsId/checklist-instances`

```json
{
  "connectionId": null,
  "templateVersionId": "PUT_ERD_PUBLISHED_VERSION_ID",
  "scopeType": "diagram",
  "scopeRef": { "schemas": ["public","stats"], "diagramId": "diag-1" },
  "createdBy": "nick"
}
```

3. Get issues:
   GET `/api/v1/checklist-instances/:instanceId/issues?severity=blocking,warning`

4. Get instance tree:
   GET `/api/v1/checklist-instances/:instanceId/tree`

---

# 1.3 Definition of Done

* [ ] Create instance from published template
* [ ] Instance auto-creates result rows for item nodes
* [ ] Tree endpoint returns nodes + results
* [ ] Issues endpoint returns failing/warning items
* [ ] Manual result update recomputes rollups

---

## Next (1.4) recommendation — the real payoff

**Checklist Runner v1**: implement built-in checks:

* NO_PRIMARY_KEY
* FK_NOT_INDEXED
* FK_HAS_VIOLATIONS

…and populate `target_ref`, `output_stats`, `output_rows`, plus ERD annotations endpoint.

Say **“1.4”** and I’ll deliver the check runner + Postgres introspection queries.
