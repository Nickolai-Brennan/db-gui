Below is **2.2 issues filters code** for a real shipping-quality **Issues Queue** endpoint:

✅ filters: `severity`, `status`, `sectionId`, `schema`, `table`
✅ sorting: **blocking first**, then error, then warning (and within that: blocked → fail → warning → unchecked/pass)
✅ uses `target_ref.targets[]` (table/relationship/column) to filter schema/table
✅ supports pagination (`limit`, `offset`)
✅ returns `focus` object that your ERD can jump to

---

# 1) Route: `GET /api/v1/checklist-instances/:instanceId/issues`

### `apps/api/src/routes/issues.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { query } from '../sql';

const UUID = z.string().uuid();

function parseCsv(v?: string | string[]) {
  if (!v) return [];
  const s = Array.isArray(v) ? v.join(',') : v;
  return s
    .split(',')
    .map((x) => x.trim())
    .filter(Boolean);
}

function focusFromTargetRef(targetRef: any) {
  const t = targetRef?.targets?.[0];
  if (!t) return null;

  if (t.kind === 'table') {
    return { type: 'table', key: `${t.schema}.${t.table}` };
  }

  if (t.kind === 'column') {
    return { type: 'table', key: `${t.schema}.${t.table}` }; // focus table for column issues
  }

  if (t.kind === 'relationship') {
    const childCols = (t.childCols ?? []).join(',');
    const parentCols = (t.parentCols ?? []).join(',');
    return {
      type: 'relationship',
      key: `${t.childSchema}.${t.childTable}(${childCols})->${t.parentSchema ?? ''}.${t.parentTable ?? ''}(${parentCols})`,
    };
  }

  return null;
}

export async function issuesRoutes(app: FastifyInstance) {
  app.get('/api/v1/checklist-instances/:instanceId/issues', async (req) => {
    const instanceId = UUID.parse((req.params as any).instanceId);

    const Q = z.object({
      severity: z.string().optional(), // csv blocking,error,warning
      status: z.string().optional(),   // csv blocked,fail,warning,unchecked,pass
      sectionId: z.string().uuid().optional(),
      schema: z.string().optional(),
      table: z.string().optional(),
      limit: z.coerce.number().int().min(1).max(500).default(200),
      offset: z.coerce.number().int().min(0).default(0),
    });

    const q = Q.parse(req.query ?? {});
    const severities = parseCsv(q.severity);
    const statuses = parseCsv(q.status);

    // Build WHERE dynamically (parameterized)
    const where: string[] = [`r.instance_id = $1`];
    const params: any[] = [instanceId];
    let p = 1;

    // severity filter
    if (severities.length) {
      params.push(severities);
      p += 1;
      where.push(`r.severity = ANY($${p}::text[])`);
    }

    // status filter
    if (statuses.length) {
      params.push(statuses);
      p += 1;
      where.push(`r.status = ANY($${p}::text[])`);
    }

    // schema/table filter using target_ref.targets
    // Supports issues where targets include:
    // - table {schema, table}
    // - column {schema, table, column}
    // - relationship {childSchema, childTable, parentSchema, parentTable}
    if (q.schema) {
      params.push(q.schema);
      p += 1;
      where.push(`
        EXISTS (
          SELECT 1
          FROM jsonb_array_elements(COALESCE(r.target_ref->'targets','[]'::jsonb)) t
          WHERE
            (t->>'schema' = $${p})
            OR (t->>'childSchema' = $${p})
            OR (t->>'parentSchema' = $${p})
        )
      `);
    }

    if (q.table) {
      params.push(q.table);
      p += 1;
      where.push(`
        EXISTS (
          SELECT 1
          FROM jsonb_array_elements(COALESCE(r.target_ref->'targets','[]'::jsonb)) t
          WHERE
            (t->>'table' = $${p})
            OR (t->>'childTable' = $${p})
            OR (t->>'parentTable' = $${p})
        )
      `);
    }

    // sectionId filter: include all descendant nodes of that section/group
    // We scope descendants to the SAME template_version_id as the instance.
    if (q.sectionId) {
      params.push(q.sectionId);
      p += 1;

      where.push(`
        r.node_id IN (
          WITH RECURSIVE inst AS (
            SELECT template_version_id
            FROM checklist_instances
            WHERE id = $1
          ),
          subtree AS (
            SELECT n.id
            FROM checklist_nodes n
            JOIN inst i ON i.template_version_id = n.template_version_id
            WHERE n.id = $${p}
            UNION ALL
            SELECT c.id
            FROM checklist_nodes c
            JOIN subtree s ON s.id = c.parent_id
          )
          SELECT id FROM subtree
        )
      `);
    }

    // Sort rules:
    // 1) severity: blocking -> error -> warning
    // 2) status: blocked -> fail -> warning -> unchecked -> pass
    // 3) most recent first
    const sql = `
      SELECT
        r.id AS result_id,
        r.node_id,
        r.status AS result_status,
        r.severity AS result_severity,
        r.output_summary,
        r.output_stats,
        r.target_ref,
        r.updated_at,

        n.title AS node_title,
        n.check_ref,
        n.node_type,
        n.parent_id,

        -- helpful for UI grouping
        i.template_version_id

      FROM checklist_instance_results r
      JOIN checklist_nodes n ON n.id = r.node_id
      JOIN checklist_instances i ON i.id = r.instance_id

      WHERE ${where.join('\n AND ')}

      ORDER BY
        CASE r.severity
          WHEN 'blocking' THEN 0
          WHEN 'error' THEN 1
          WHEN 'warning' THEN 2
          ELSE 9
        END ASC,
        CASE r.status
          WHEN 'blocked' THEN 0
          WHEN 'fail' THEN 1
          WHEN 'warning' THEN 2
          WHEN 'unchecked' THEN 3
          WHEN 'pass' THEN 4
          ELSE 9
        END ASC,
        r.updated_at DESC

      LIMIT ${q.limit} OFFSET ${q.offset}
    `;

    const rows = await query<any>(sql, params);

    const issues = rows.map((r: any) => ({
      resultId: r.result_id,
      nodeId: r.node_id,
      code: r.check_ref ?? 'SQL',
      title: r.node_title,
      severity: r.result_severity,
      status: r.result_status,
      updatedAt: r.updated_at,
      outputSummary: r.output_summary ?? null,
      outputStats: r.output_stats ?? null,
      targetRef: r.target_ref ?? null,
      focus: focusFromTargetRef(r.target_ref),
    }));

    return {
      instanceId,
      filters: {
        severity: severities,
        status: statuses,
        sectionId: q.sectionId ?? null,
        schema: q.schema ?? null,
        table: q.table ?? null,
        limit: q.limit,
        offset: q.offset,
      },
      issues,
    };
  });
}
```

---

# 2) Wire it up

### `apps/api/src/index.ts`

```ts
import { issuesRoutes } from './routes/issues';
// ...
await app.register(issuesRoutes);
```

---

# 3) Example calls

### Blocking + error, only in `public` schema

`GET /api/v1/checklist-instances/:id/issues?severity=blocking,error&schema=public`

### Only issues for a given section subtree

`GET /api/v1/checklist-instances/:id/issues?sectionId=<uuid>`

### Only table-specific issues

`GET /api/v1/checklist-instances/:id/issues?table=users`

---

# 4) Small but important note (UI expectation)

This endpoint returns **all results** by default (including pass/unchecked).
If you want “issues only” behavior, add a default `status IN ('blocked','fail','warning')` when no status filter is provided.

Here’s that tweak (drop into code after `statuses` parse):

```ts
const statuses = parseCsv(q.status);
if (!statuses.length) statuses.push('blocked', 'fail', 'warning');
```

---

If you want the next upgrade after this: **2.2 section labels** (return parent section path for each issue so UI can show `Schema → Keys → FK Not Indexed`).


Here’s **Section Labels** (a clean “section path” for each issue), implemented in a way that’s fast and UI-friendly.

You’ll get for every issue:

* `sectionPath`: `[{id,title}]` from root → … → parent section/group → item
* `sectionTitle`: a single string like `"Schema → Keys → Foreign Keys"`

---

## 1) Add section-path CTE and return it per issue

### Patch `apps/api/src/routes/issues.ts`

Replace the big `sql = ...` with this version (same filters/sorting as before, but now includes `section_path`):

```ts
const sql = `
  WITH
  inst AS (
    SELECT template_version_id
    FROM checklist_instances
    WHERE id = $1
  ),

  -- Base filtered results (keeps your existing WHERE + ORDER + LIMIT)
  base AS (
    SELECT
      r.id AS result_id,
      r.node_id,
      r.status AS result_status,
      r.severity AS result_severity,
      r.output_summary,
      r.output_stats,
      r.target_ref,
      r.updated_at,

      n.title AS node_title,
      n.check_ref,
      n.node_type,
      n.parent_id

    FROM checklist_instance_results r
    JOIN checklist_nodes n ON n.id = r.node_id
    WHERE ${where.join('\n AND ')}

    ORDER BY
      CASE r.severity
        WHEN 'blocking' THEN 0
        WHEN 'error' THEN 1
        WHEN 'warning' THEN 2
        ELSE 9
      END ASC,
      CASE r.status
        WHEN 'blocked' THEN 0
        WHEN 'fail' THEN 1
        WHEN 'warning' THEN 2
        WHEN 'unchecked' THEN 3
        WHEN 'pass' THEN 4
        ELSE 9
      END ASC,
      r.updated_at DESC

    LIMIT ${q.limit} OFFSET ${q.offset}
  ),

  -- Walk upwards from each base.node_id to the root to build a path
  chain AS (
    SELECT
      b.result_id,
      n.id,
      n.parent_id,
      n.title,
      n.node_type,
      0 AS depth
    FROM base b
    JOIN checklist_nodes n ON n.id = b.node_id

    UNION ALL

    SELECT
      c.result_id,
      p.id,
      p.parent_id,
      p.title,
      p.node_type,
      c.depth + 1
    FROM chain c
    JOIN checklist_nodes p ON p.id = c.parent_id
    WHERE c.parent_id IS NOT NULL
  ),

  -- Aggregate each chain into an ordered JSON array (root → leaf)
  paths AS (
    SELECT
      result_id,
      jsonb_agg(
        jsonb_build_object(
          'id', id,
          'title', title,
          'nodeType', node_type
        )
        ORDER BY depth DESC
      ) AS section_path
    FROM chain
    GROUP BY result_id
  )

  SELECT
    b.*,
    COALESCE(p.section_path, '[]'::jsonb) AS section_path
  FROM base b
  LEFT JOIN paths p ON p.result_id = b.result_id
`;
```

---

## 2) Return `sectionPath` + `sectionTitle` in the response

Patch the mapper in `issues.ts`:

```ts
const issues = rows.map((r: any) => {
  const sectionPath = (r.section_path ?? []) as Array<{ id: string; title: string; nodeType: string }>;

  // Turn it into a nice label string; optionally exclude the leaf item title if you want
  const sectionTitle = sectionPath
    .filter((x) => x.nodeType !== 'item') // keep only section/group nodes for label
    .map((x) => x.title)
    .join(' → ');

  return {
    resultId: r.result_id,
    nodeId: r.node_id,
    code: r.check_ref ?? 'SQL',
    title: r.node_title,
    severity: r.result_severity,
    status: r.result_status,
    updatedAt: r.updated_at,
    outputSummary: r.output_summary ?? null,
    outputStats: r.output_stats ?? null,
    targetRef: r.target_ref ?? null,
    focus: focusFromTargetRef(r.target_ref),

    sectionPath,
    sectionTitle: sectionTitle || null,
  };
});
```

---

## 3) Optional: also return `itemTitle` separately (nice for UI)

If your UI wants:

* `sectionTitle` = `"Schema → Keys"`
* `itemTitle` = `"FK columns missing index"`

Add:

```ts
const itemTitle = sectionPath.length ? sectionPath[sectionPath.length - 1]?.title : r.node_title;
```

---

## 4) Performance notes (so this scales)

* This approach computes paths only for the **paged `base` results**, not for the whole instance → stays fast even with thousands of nodes.
* Make sure you have indexes:

  * `checklist_instance_results(instance_id, severity, status, updated_at)`
  * `checklist_nodes(id)` is PK, plus `checklist_nodes(parent_id)` index helps recursion.

---

If you want the UI-ready “breadcrumb” formatting too (with clickable parents), I can add a tiny helper that converts `sectionPath` into a **breadcrumb array** where every crumb has a `nodeId` so the frontend can open that subtree in the checklist panel.
