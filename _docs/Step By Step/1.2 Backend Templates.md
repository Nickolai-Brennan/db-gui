## 1.2 Backend Templates API (Fastify) — exact routes + SQL + shapes

Goal: you can **list templates**, **create versions**, **CRUD nodes**, and **fetch a nested tree** for the Builder UI.

I’ll assume:

* Postgres App DB
* `APP_DATABASE_URL`
* Fastify API in `apps/api`

---

# 1.2.01 Add DB client + env

## Install deps

```bash
pnpm --filter api add pg zod
pnpm --filter api add -D @types/pg
```

## Create `apps/api/src/db.ts`

```ts
import { Pool } from 'pg';

const connectionString = process.env.APP_DATABASE_URL;
if (!connectionString) throw new Error('APP_DATABASE_URL is required');

export const pool = new Pool({ connectionString });
```

## Create `apps/api/src/env.ts`

```ts
import { z } from 'zod';

const EnvSchema = z.object({
  APP_DATABASE_URL: z.string().min(1),
  PORT: z.string().optional(),
  HOST: z.string().optional(),
});

export const env = EnvSchema.parse(process.env);
```

Update `apps/api/src/index.ts` to import env first:

```ts
import './env';
import Fastify from 'fastify';

const app = Fastify({ logger: true });

app.get('/health', async () => ({ ok: true }));

const port = Number(process.env.PORT ?? 3001);
const host = process.env.HOST ?? '0.0.0.0';

await app.listen({ port, host });
```

---

# 1.2.02 Data types (minimal)

Create `apps/api/src/types.ts`

```ts
export type UUID = string;

export type Template = {
  id: UUID;
  workspaceId: UUID;
  slug: string;
  title: string;
  description: string | null;
  isSystem: boolean;
  createdAt: string;
};

export type TemplateVersion = {
  id: UUID;
  templateId: UUID;
  version: string;
  status: 'draft' | 'published' | 'archived';
  createdBy: string | null;
  createdAt: string;
  publishedAt: string | null;
};

export type ChecklistNode = {
  id: UUID;
  templateVersionId: UUID;
  parentId: UUID | null;
  sortOrder: number;
  nodeType: 'group' | 'item';
  title: string;
  description: string | null;

  itemType: 'manual' | 'automatic' | 'hybrid' | null;
  severity: 'info' | 'warning' | 'error' | 'blocking' | null;
  blocksAction: boolean | null;
  required: boolean | null;

  scopeType:
    | 'diagram'
    | 'schema'
    | 'table'
    | 'column'
    | 'relationship'
    | 'migration_step'
    | null;

  targetSelector: any | null;

  checkKind: string | null;
  checkRef: string | null;
  sqlTemplate: string | null;
  resultMapping: any | null;
  passFailRule: any | null;

  fixKind: 'none' | 'manual' | 'auto_sql' | null;
  fixInstructions: string | null;
  fixSqlTemplate: string | null;

  createdAt: string;
};
```

---

# 1.2.03 SQL helpers (safe + reusable)

Create `apps/api/src/sql.ts`

```ts
import { pool } from './db';

export async function query<T>(text: string, params: any[] = []): Promise<T[]> {
  const res = await pool.query(text, params);
  return res.rows as T[];
}

export async function queryOne<T>(text: string, params: any[] = []): Promise<T> {
  const rows = await query<T>(text, params);
  if (rows.length !== 1) throw new Error(`Expected 1 row, got ${rows.length}`);
  return rows[0];
}
```

---

# 1.2.04 Routes: Templates + Versions + Nodes

Create `apps/api/src/routes/templates.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { query, queryOne } from '../sql';
import type { ChecklistNode, Template, TemplateVersion, UUID } from '../types';

const UUIDSchema = z.string().uuid();

export async function templatesRoutes(app: FastifyInstance) {
  // -------------------------
  // TEMPLATES
  // -------------------------

  // GET /api/v1/workspaces/:wsId/checklist-templates
  app.get('/api/v1/workspaces/:wsId/checklist-templates', async (req) => {
    const wsId = UUIDSchema.parse((req.params as any).wsId);

    const rows = await query<{
      id: UUID;
      workspace_id: UUID;
      slug: string;
      title: string;
      description: string | null;
      is_system: boolean;
      created_at: string;
    }>(
      `SELECT id, workspace_id, slug, title, description, is_system, created_at
       FROM checklist_templates
       WHERE workspace_id = $1
       ORDER BY is_system DESC, title ASC`,
      [wsId],
    );

    const templates: Template[] = rows.map((r) => ({
      id: r.id,
      workspaceId: r.workspace_id,
      slug: r.slug,
      title: r.title,
      description: r.description,
      isSystem: r.is_system,
      createdAt: r.created_at,
    }));

    return { templates };
  });

  // POST /api/v1/workspaces/:wsId/checklist-templates
  app.post('/api/v1/workspaces/:wsId/checklist-templates', async (req) => {
    const wsId = UUIDSchema.parse((req.params as any).wsId);

    const Body = z.object({
      slug: z.string().min(2).max(80),
      title: z.string().min(2).max(200),
      description: z.string().max(2000).optional(),
    });
    const body = Body.parse(req.body);

    const row = await queryOne<{
      id: UUID;
      workspace_id: UUID;
      slug: string;
      title: string;
      description: string | null;
      is_system: boolean;
      created_at: string;
    }>(
      `INSERT INTO checklist_templates (workspace_id, slug, title, description, is_system)
       VALUES ($1, $2, $3, $4, false)
       RETURNING id, workspace_id, slug, title, description, is_system, created_at`,
      [wsId, body.slug, body.title, body.description ?? null],
    );

    const template: Template = {
      id: row.id,
      workspaceId: row.workspace_id,
      slug: row.slug,
      title: row.title,
      description: row.description,
      isSystem: row.is_system,
      createdAt: row.created_at,
    };

    return { template };
  });

  // GET /api/v1/checklist-templates/:templateId
  app.get('/api/v1/checklist-templates/:templateId', async (req) => {
    const templateId = UUIDSchema.parse((req.params as any).templateId);

    const templateRow = await queryOne<any>(
      `SELECT id, workspace_id, slug, title, description, is_system, created_at
       FROM checklist_templates
       WHERE id = $1`,
      [templateId],
    );

    const versionsRows = await query<any>(
      `SELECT id, template_id, version, status, created_by, created_at, published_at
       FROM checklist_template_versions
       WHERE template_id = $1
       ORDER BY created_at DESC`,
      [templateId],
    );

    return {
      template: {
        id: templateRow.id,
        workspaceId: templateRow.workspace_id,
        slug: templateRow.slug,
        title: templateRow.title,
        description: templateRow.description,
        isSystem: templateRow.is_system,
        createdAt: templateRow.created_at,
      } satisfies Template,
      versions: versionsRows.map((v: any) => ({
        id: v.id,
        templateId: v.template_id,
        version: v.version,
        status: v.status,
        createdBy: v.created_by,
        createdAt: v.created_at,
        publishedAt: v.published_at,
      })) satisfies TemplateVersion[],
    };
  });

  // -------------------------
  // VERSIONS
  // -------------------------

  // POST /api/v1/checklist-templates/:templateId/versions
  app.post('/api/v1/checklist-templates/:templateId/versions', async (req) => {
    const templateId = UUIDSchema.parse((req.params as any).templateId);

    const Body = z.object({
      version: z.string().min(1).max(40),
      createdBy: z.string().max(200).optional(),
    });
    const body = Body.parse(req.body);

    const row = await queryOne<any>(
      `INSERT INTO checklist_template_versions (template_id, version, status, created_by)
       VALUES ($1, $2, 'draft', $3)
       RETURNING id, template_id, version, status, created_by, created_at, published_at`,
      [templateId, body.version, body.createdBy ?? null],
    );

    return {
      version: {
        id: row.id,
        templateId: row.template_id,
        version: row.version,
        status: row.status,
        createdBy: row.created_by,
        createdAt: row.created_at,
        publishedAt: row.published_at,
      } satisfies TemplateVersion,
    };
  });

  // POST /api/v1/checklist-template-versions/:versionId/publish
  app.post('/api/v1/checklist-template-versions/:versionId/publish', async (req) => {
    const versionId = UUIDSchema.parse((req.params as any).versionId);

    // Make published immutable in app logic (frontend should hide editing; backend enforces)
    const row = await queryOne<any>(
      `UPDATE checklist_template_versions
       SET status='published', published_at=now()
       WHERE id=$1 AND status='draft'
       RETURNING id, template_id, version, status, created_by, created_at, published_at`,
      [versionId],
    );

    return {
      version: {
        id: row.id,
        templateId: row.template_id,
        version: row.version,
        status: row.status,
        createdBy: row.created_by,
        createdAt: row.created_at,
        publishedAt: row.published_at,
      } satisfies TemplateVersion,
    };
  });

  // -------------------------
  // NODES
  // -------------------------

  // GET /api/v1/checklist-template-versions/:versionId/nodes  (nested)
  app.get('/api/v1/checklist-template-versions/:versionId/nodes', async (req) => {
    const versionId = UUIDSchema.parse((req.params as any).versionId);

    const rows = await query<any>(
      `SELECT
         id, template_version_id, parent_id, sort_order,
         node_type, title, description,
         item_type, severity, blocks_action, required,
         scope_type, target_selector,
         check_kind, check_ref, sql_template, result_mapping, pass_fail_rule,
         fix_kind, fix_instructions, fix_sql_template,
         created_at
       FROM checklist_nodes
       WHERE template_version_id = $1
       ORDER BY sort_order ASC, created_at ASC`,
      [versionId],
    );

    const nodes: ChecklistNode[] = rows.map((r: any) => ({
      id: r.id,
      templateVersionId: r.template_version_id,
      parentId: r.parent_id,
      sortOrder: r.sort_order,
      nodeType: r.node_type,
      title: r.title,
      description: r.description,

      itemType: r.item_type,
      severity: r.severity,
      blocksAction: r.blocks_action,
      required: r.required,

      scopeType: r.scope_type,
      targetSelector: r.target_selector,

      checkKind: r.check_kind,
      checkRef: r.check_ref,
      sqlTemplate: r.sql_template,
      resultMapping: r.result_mapping,
      passFailRule: r.pass_fail_rule,

      fixKind: r.fix_kind,
      fixInstructions: r.fix_instructions,
      fixSqlTemplate: r.fix_sql_template,

      createdAt: r.created_at,
    }));

    // Build nested tree
    const byId = new Map<string, any>();
    const childrenByParent = new Map<string | null, any[]>();

    for (const n of nodes) {
      const node = { ...n, children: [] as any[] };
      byId.set(n.id, node);
      const key = n.parentId ?? null;
      const list = childrenByParent.get(key) ?? [];
      list.push(node);
      childrenByParent.set(key, list);
    }

    // attach children
    for (const n of nodes) {
      const node = byId.get(n.id);
      node.children = (childrenByParent.get(n.id) ?? []).sort((a, b) => a.sortOrder - b.sortOrder);
    }

    const roots = (childrenByParent.get(null) ?? []).sort((a, b) => a.sortOrder - b.sortOrder);

    // If multiple roots exist, return them all. Frontend can show a "virtual root".
    return { versionId, roots };
  });

  // POST /api/v1/checklist-template-versions/:versionId/nodes
  app.post('/api/v1/checklist-template-versions/:versionId/nodes', async (req) => {
    const versionId = UUIDSchema.parse((req.params as any).versionId);

    // Prevent edits if published
    const ver = await queryOne<any>(
      `SELECT status FROM checklist_template_versions WHERE id=$1`,
      [versionId],
    );
    if (ver.status !== 'draft') {
      return app.httpErrors.conflict('Version is not draft (cannot edit).');
    }

    const Body = z.object({
      parentId: z.string().uuid().nullable().optional(),
      sortOrder: z.number().int().optional(),
      nodeType: z.enum(['group', 'item']),
      title: z.string().min(1).max(200),
      description: z.string().max(5000).nullable().optional(),

      itemType: z.enum(['manual','automatic','hybrid']).nullable().optional(),
      severity: z.enum(['info','warning','error','blocking']).nullable().optional(),
      blocksAction: z.boolean().nullable().optional(),
      required: z.boolean().nullable().optional(),

      scopeType: z.enum(['diagram','schema','table','column','relationship','migration_step']).nullable().optional(),
      targetSelector: z.any().nullable().optional(),

      checkKind: z.string().nullable().optional(),
      checkRef: z.string().nullable().optional(),
      sqlTemplate: z.string().nullable().optional(),
      resultMapping: z.any().nullable().optional(),
      passFailRule: z.any().nullable().optional(),

      fixKind: z.enum(['none','manual','auto_sql']).nullable().optional(),
      fixInstructions: z.string().nullable().optional(),
      fixSqlTemplate: z.string().nullable().optional(),
    });

    const body = Body.parse(req.body);

    const row = await queryOne<any>(
      `INSERT INTO checklist_nodes (
         template_version_id, parent_id, sort_order,
         node_type, title, description,
         item_type, severity, blocks_action, required,
         scope_type, target_selector,
         check_kind, check_ref, sql_template, result_mapping, pass_fail_rule,
         fix_kind, fix_instructions, fix_sql_template
       ) VALUES (
         $1, $2, COALESCE($3, 0),
         $4, $5, $6,
         $7, $8, $9, $10,
         $11, $12,
         $13, $14, $15, $16, $17,
         $18, $19, $20
       )
       RETURNING *`,
      [
        versionId,
        body.parentId ?? null,
        body.sortOrder ?? 0,
        body.nodeType,
        body.title,
        body.description ?? null,

        body.itemType ?? null,
        body.severity ?? null,
        body.blocksAction ?? null,
        body.required ?? null,

        body.scopeType ?? null,
        body.targetSelector ?? null,

        body.checkKind ?? null,
        body.checkRef ?? null,
        body.sqlTemplate ?? null,
        body.resultMapping ?? null,
        body.passFailRule ?? null,

        body.fixKind ?? null,
        body.fixInstructions ?? null,
        body.fixSqlTemplate ?? null,
      ],
    );

    return { node: row };
  });

  // PATCH /api/v1/checklist-nodes/:nodeId
  app.patch('/api/v1/checklist-nodes/:nodeId', async (req) => {
    const nodeId = UUIDSchema.parse((req.params as any).nodeId);

    // load node + version status
    const node = await queryOne<any>(
      `SELECT n.*, v.status AS version_status
       FROM checklist_nodes n
       JOIN checklist_template_versions v ON v.id = n.template_version_id
       WHERE n.id = $1`,
      [nodeId],
    );
    if (node.version_status !== 'draft') {
      return app.httpErrors.conflict('Version is not draft (cannot edit).');
    }

    const Patch = z.object({
      title: z.string().min(1).max(200).optional(),
      description: z.string().max(5000).nullable().optional(),
      sortOrder: z.number().int().optional(),
      parentId: z.string().uuid().nullable().optional(),

      itemType: z.enum(['manual','automatic','hybrid']).nullable().optional(),
      severity: z.enum(['info','warning','error','blocking']).nullable().optional(),
      blocksAction: z.boolean().nullable().optional(),
      required: z.boolean().nullable().optional(),

      scopeType: z.enum(['diagram','schema','table','column','relationship','migration_step']).nullable().optional(),
      targetSelector: z.any().nullable().optional(),

      checkKind: z.string().nullable().optional(),
      checkRef: z.string().nullable().optional(),
      sqlTemplate: z.string().nullable().optional(),
      resultMapping: z.any().nullable().optional(),
      passFailRule: z.any().nullable().optional(),

      fixKind: z.enum(['none','manual','auto_sql']).nullable().optional(),
      fixInstructions: z.string().nullable().optional(),
      fixSqlTemplate: z.string().nullable().optional()
    });

    const patch = Patch.parse(req.body);

    // Build dynamic update
    const fields: string[] = [];
    const values: any[] = [];
    let i = 1;

    const set = (col: string, val: any) => {
      fields.push(`${col}=$${i++}`);
      values.push(val);
    };

    if (patch.title !== undefined) set('title', patch.title);
    if (patch.description !== undefined) set('description', patch.description);
    if (patch.sortOrder !== undefined) set('sort_order', patch.sortOrder);
    if (patch.parentId !== undefined) set('parent_id', patch.parentId);

    if (patch.itemType !== undefined) set('item_type', patch.itemType);
    if (patch.severity !== undefined) set('severity', patch.severity);
    if (patch.blocksAction !== undefined) set('blocks_action', patch.blocksAction);
    if (patch.required !== undefined) set('required', patch.required);

    if (patch.scopeType !== undefined) set('scope_type', patch.scopeType);
    if (patch.targetSelector !== undefined) set('target_selector', patch.targetSelector);

    if (patch.checkKind !== undefined) set('check_kind', patch.checkKind);
    if (patch.checkRef !== undefined) set('check_ref', patch.checkRef);
    if (patch.sqlTemplate !== undefined) set('sql_template', patch.sqlTemplate);
    if (patch.resultMapping !== undefined) set('result_mapping', patch.resultMapping);
    if (patch.passFailRule !== undefined) set('pass_fail_rule', patch.passFailRule);

    if (patch.fixKind !== undefined) set('fix_kind', patch.fixKind);
    if (patch.fixInstructions !== undefined) set('fix_instructions', patch.fixInstructions);
    if (patch.fixSqlTemplate !== undefined) set('fix_sql_template', patch.fixSqlTemplate);

    if (fields.length === 0) return { node };

    values.push(nodeId);

    const updated = await queryOne<any>(
      `UPDATE checklist_nodes SET ${fields.join(', ')}
       WHERE id=$${i}
       RETURNING *`,
      values,
    );

    return { node: updated };
  });

  // DELETE /api/v1/checklist-nodes/:nodeId
  app.delete('/api/v1/checklist-nodes/:nodeId', async (req) => {
    const nodeId = UUIDSchema.parse((req.params as any).nodeId);

    const node = await queryOne<any>(
      `SELECT n.id, v.status AS version_status
       FROM checklist_nodes n
       JOIN checklist_template_versions v ON v.id = n.template_version_id
       WHERE n.id=$1`,
      [nodeId],
    );
    if (node.version_status !== 'draft') {
      return app.httpErrors.conflict('Version is not draft (cannot edit).');
    }

    await query(`DELETE FROM checklist_nodes WHERE id=$1`, [nodeId]);
    return { ok: true };
  });

  // POST /api/v1/checklist-template-versions/:versionId/nodes/reorder
  app.post('/api/v1/checklist-template-versions/:versionId/nodes/reorder', async (req) => {
    const versionId = UUIDSchema.parse((req.params as any).versionId);

    const ver = await queryOne<any>(
      `SELECT status FROM checklist_template_versions WHERE id=$1`,
      [versionId],
    );
    if (ver.status !== 'draft') {
      return app.httpErrors.conflict('Version is not draft (cannot edit).');
    }

    const Body = z.object({
      moves: z.array(
        z.object({
          nodeId: z.string().uuid(),
          newParentId: z.string().uuid().nullable(),
          newSortOrder: z.number().int(),
        }),
      ).min(1),
    });
    const body = Body.parse(req.body);

    // Basic batch update (transaction)
    const client = await app.pg?.connect?.(); // if you later decorate fastify with pg
    // We'll do plain pool transaction here:
    const { pool } = await import('../db');

    const tx = await pool.connect();
    try {
      await tx.query('BEGIN');

      for (const m of body.moves) {
        await tx.query(
          `UPDATE checklist_nodes
           SET parent_id=$1, sort_order=$2
           WHERE id=$3 AND template_version_id=$4`,
          [m.newParentId, m.newSortOrder, m.nodeId, versionId],
        );
      }

      await tx.query('COMMIT');
    } catch (e) {
      await tx.query('ROLLBACK');
      throw e;
    } finally {
      tx.release();
    }

    return { ok: true };
  });
}
```

---

# 1.2.05 Wire routes into API

Edit `apps/api/src/index.ts`:

```ts
import './env';
import Fastify from 'fastify';
import { templatesRoutes } from './routes/templates';

const app = Fastify({ logger: true });

// Add httpErrors (for conflict responses)
import fastifySensible from '@fastify/sensible';
await app.register(fastifySensible);

await app.register(templatesRoutes);

app.get('/health', async () => ({ ok: true }));

const port = Number(process.env.PORT ?? 3001);
const host = process.env.HOST ?? '0.0.0.0';
await app.listen({ port, host });
```

Install sensible:

```bash
pnpm --filter api add @fastify/sensible
```

---

# 1.2.06 Quick test calls (manual)

Assuming you seeded workspace “Default”, grab its id:

```sql
SELECT id FROM workspaces ORDER BY created_at DESC LIMIT 1;
```

Then:

* GET templates:

  * `/api/v1/workspaces/:wsId/checklist-templates`
* GET template detail:

  * `/api/v1/checklist-templates/:templateId`
* GET nodes for version:

  * `/api/v1/checklist-template-versions/:versionId/nodes`

---

# 1.2 Definition of Done

* [ ] You can list templates for a workspace
* [ ] You can create a draft version
* [ ] You can create/update/delete nodes (draft only)
* [ ] You can fetch nested nodes tree
* [ ] You can publish version (draft → published)

---

## Next (1.3) recommendation

**Instances API** (create instance + computed tree + issues queue).
That unlocks Dashboard + Runtime checklist UI fast.

Say **“1.3”** and I’ll ship the full Instances routes + rollup computation + issues endpoint.
