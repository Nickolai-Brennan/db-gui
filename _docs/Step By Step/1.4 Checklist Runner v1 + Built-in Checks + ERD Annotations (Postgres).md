## 1.4 Checklist Runner v1 + Built-in Checks + ERD Annotations (Postgres)

This gets you a *real* end-to-end loop:

✅ Instance → run checks → results saved → rollups updated → ERD highlights available.

We will implement **three built-ins** first:

* `NO_PRIMARY_KEY`
* `FK_NOT_INDEXED`
* `FK_HAS_VIOLATIONS`

…and add:

* `GET /api/v1/checklist-instances/:instanceId/annotations`

---

# 1.4.00 One important v1 decision (Target DB credentials)

Your **App DB** is separate from the **Target DB** being inspected.

For v1 runner, do this (fastest + safe):

* The **run endpoint** accepts `targetDatabaseUrl` in the body **OR**
* You pass `connectionId` and your backend resolves to a URL (later via encrypted secrets table)

We’ll implement the simplest v1 approach:

✅ `POST /run` includes `"targetDatabaseUrl"`

Later we’ll replace this with a proper secrets manager.

---

# 1.4.01 Target DB client (separate from App DB)

Create `apps/api/src/targetDb.ts`

```ts
import { Pool } from 'pg';

export function createTargetPool(targetDatabaseUrl: string) {
  return new Pool({
    connectionString: targetDatabaseUrl,
    // keep it conservative for checks
    max: 3,
    idleTimeoutMillis: 30_000,
    connectionTimeoutMillis: 10_000,
  });
}
```

---

# 1.4.02 Built-in check: NO_PRIMARY_KEY

Create `apps/api/src/checks/noPrimaryKey.ts`

```ts
import type { Pool } from 'pg';

export type NoPrimaryKeyRow = { schema: string; table: string };

export async function checkNoPrimaryKey(
  pool: Pool,
  schemas: string[],
): Promise<{ violations: NoPrimaryKeyRow[] }> {
  const res = await pool.query<NoPrimaryKeyRow>(
    `
    WITH tbl AS (
      SELECT c.oid, n.nspname AS schema, c.relname AS table
      FROM pg_class c
      JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE c.relkind = 'r'
        AND n.nspname = ANY($1::text[])
    ),
    pk AS (
      SELECT conrelid
      FROM pg_constraint
      WHERE contype = 'p'
    )
    SELECT t.schema, t.table
    FROM tbl t
    LEFT JOIN pk ON pk.conrelid = t.oid
    WHERE pk.conrelid IS NULL
    ORDER BY t.schema, t.table;
    `,
    [schemas],
  );

  return { violations: res.rows };
}
```

---

# 1.4.03 Built-in check: FK metadata query (shared)

We need FK metadata for **FK_NOT_INDEXED** + **FK_HAS_VIOLATIONS**.

Create `apps/api/src/checks/fkMeta.ts`

```ts
import type { Pool } from 'pg';

export type FkMeta = {
  fk_name: string;
  child_schema: string;
  child_table: string;
  child_cols: string[];
  parent_schema: string;
  parent_table: string;
  parent_cols: string[];
};

export async function getForeignKeys(pool: Pool, schemas: string[]): Promise<FkMeta[]> {
  const res = await pool.query<FkMeta>(
    `
    SELECT
      con.conname AS fk_name,
      n_child.nspname AS child_schema,
      c_child.relname AS child_table,
      array_agg(a_child.attname ORDER BY x.ord) AS child_cols,
      n_parent.nspname AS parent_schema,
      c_parent.relname AS parent_table,
      array_agg(a_parent.attname ORDER BY x.ord) AS parent_cols
    FROM pg_constraint con
    JOIN pg_class c_child ON c_child.oid = con.conrelid
    JOIN pg_namespace n_child ON n_child.oid = c_child.relnamespace
    JOIN pg_class c_parent ON c_parent.oid = con.confrelid
    JOIN pg_namespace n_parent ON n_parent.oid = c_parent.relnamespace
    JOIN LATERAL unnest(con.conkey) WITH ORDINALITY AS x(attnum, ord) ON true
    JOIN pg_attribute a_child ON a_child.attrelid = c_child.oid AND a_child.attnum = x.attnum
    JOIN LATERAL unnest(con.confkey) WITH ORDINALITY AS y(attnum, ord) ON y.ord = x.ord
    JOIN pg_attribute a_parent ON a_parent.attrelid = c_parent.oid AND a_parent.attnum = y.attnum
    WHERE con.contype = 'f'
      AND n_child.nspname = ANY($1::text[])
    GROUP BY con.conname, n_child.nspname, c_child.relname, n_parent.nspname, c_parent.relname
    ORDER BY n_child.nspname, c_child.relname, con.conname;
    `,
    [schemas],
  );

  return res.rows;
}
```

---

# 1.4.04 Built-in check: FK_NOT_INDEXED

Logic: FK columns must be the **leading columns** of some index on the child table.

Create `apps/api/src/checks/fkNotIndexed.ts`

```ts
import type { Pool } from 'pg';

export type FkNotIndexedRow = {
  fk_name: string;
  child_schema: string;
  child_table: string;
  child_cols: string[];
};

export async function checkFkNotIndexed(
  pool: Pool,
  schemas: string[],
): Promise<{ violations: FkNotIndexedRow[] }> {
  const res = await pool.query<FkNotIndexedRow>(
    `
    WITH fk AS (
      SELECT
        con.oid AS con_oid,
        con.conname AS fk_name,
        c_child.oid AS child_oid,
        n_child.nspname AS child_schema,
        c_child.relname AS child_table,
        con.conkey AS child_attnums
      FROM pg_constraint con
      JOIN pg_class c_child ON c_child.oid = con.conrelid
      JOIN pg_namespace n_child ON n_child.oid = c_child.relnamespace
      WHERE con.contype='f'
        AND n_child.nspname = ANY($1::text[])
    ),
    fk_cols AS (
      SELECT
        fk.con_oid,
        fk.fk_name,
        fk.child_oid,
        fk.child_schema,
        fk.child_table,
        array_agg(a.attname ORDER BY x.ord) AS child_cols,
        fk.child_attnums AS child_attnums
      FROM fk
      JOIN LATERAL unnest(fk.child_attnums) WITH ORDINALITY AS x(attnum, ord) ON true
      JOIN pg_attribute a ON a.attrelid = fk.child_oid AND a.attnum = x.attnum
      GROUP BY fk.con_oid, fk.fk_name, fk.child_oid, fk.child_schema, fk.child_table, fk.child_attnums
    ),
    idx AS (
      SELECT
        i.indrelid AS child_oid,
        i.indkey::int[] AS indkey
      FROM pg_index i
      WHERE i.indisvalid = true AND i.indisready = true
    ),
    matches AS (
      SELECT
        fk_cols.con_oid,
        EXISTS (
          SELECT 1
          FROM idx
          WHERE idx.child_oid = fk_cols.child_oid
            AND idx.indkey[1:array_length(fk_cols.child_attnums,1)] = fk_cols.child_attnums
        ) AS has_index
      FROM fk_cols
    )
    SELECT
      fk_cols.fk_name,
      fk_cols.child_schema,
      fk_cols.child_table,
      fk_cols.child_cols
    FROM fk_cols
    JOIN matches ON matches.con_oid = fk_cols.con_oid
    WHERE matches.has_index = false
    ORDER BY fk_cols.child_schema, fk_cols.child_table, fk_cols.fk_name;
    `,
    [schemas],
  );

  return { violations: res.rows };
}
```

---

# 1.4.05 Built-in check: FK_HAS_VIOLATIONS (per FK, with sample rows)

We generate a parameterized query per FK. We only need a **count + sample**.

Create `apps/api/src/checks/fkHasViolations.ts`

```ts
import type { Pool } from 'pg';
import type { FkMeta } from './fkMeta';

export type FkViolation = {
  fk: FkMeta;
  violatingCount: number;
  sample: Record<string, any>[];
};

function qIdent(s: string) {
  // minimal identifier quoting
  return '"' + s.replace(/"/g, '""') + '"';
}

export async function checkFkHasViolations(
  pool: Pool,
  fks: FkMeta[],
  sampleLimit = 25,
): Promise<{ violations: FkViolation[] }> {
  const out: FkViolation[] = [];

  for (const fk of fks) {
    const child = `${qIdent(fk.child_schema)}.${qIdent(fk.child_table)}`;
    const parent = `${qIdent(fk.parent_schema)}.${qIdent(fk.parent_table)}`;

    const joinPred = fk.child_cols
      .map((c, i) => `c.${qIdent(c)} = p.${qIdent(fk.parent_cols[i])}`)
      .join(' AND ');

    const notNullPred = fk.child_cols.map((c) => `c.${qIdent(c)} IS NOT NULL`).join(' AND ');
    const isOrphanPred = `p.${qIdent(fk.parent_cols[0])} IS NULL`;

    const countSql = `
      SELECT COUNT(*)::bigint AS cnt
      FROM ${child} c
      LEFT JOIN ${parent} p ON ${joinPred}
      WHERE (${notNullPred})
        AND ${isOrphanPred};
    `;

    const sampleSql = `
      SELECT c.*
      FROM ${child} c
      LEFT JOIN ${parent} p ON ${joinPred}
      WHERE (${notNullPred})
        AND ${isOrphanPred}
      LIMIT $1;
    `;

    const cntRes = await pool.query<{ cnt: string }>(countSql);
    const cnt = Number(cntRes.rows[0]?.cnt ?? 0);

    if (cnt > 0) {
      const sampleRes = await pool.query(sampleSql, [sampleLimit]);
      out.push({
        fk,
        violatingCount: cnt,
        sample: sampleRes.rows,
      });
    }
  }

  return { violations: out };
}
```

---

# 1.4.06 Runner implementation (execute built-ins, write results)

Create `apps/api/src/checklist/runner.ts`

```ts
import type { Pool } from 'pg';
import { createTargetPool } from '../targetDb';
import { query, queryOne } from '../sql';
import type { UUID } from '../types';
import { ensureInstanceResults } from './ensureResults';
import { recomputeInstanceRollup } from './rollup';

import { checkNoPrimaryKey } from '../checks/noPrimaryKey';
import { checkFkNotIndexed } from '../checks/fkNotIndexed';
import { getForeignKeys } from '../checks/fkMeta';
import { checkFkHasViolations } from '../checks/fkHasViolations';

type RunInput = {
  instanceId: UUID;
  targetDatabaseUrl: string;
  schemas: string[];
  mode: 'all' | 'items';
  nodeIds?: UUID[];
};

function nowMs() {
  return Date.now();
}

function statusFor(severity: string, violationsCount: number) {
  if (violationsCount <= 0) return 'pass';
  if (severity === 'blocking') return 'blocked';
  if (severity === 'warning') return 'warning';
  return 'fail';
}

export async function runChecklist(input: RunInput) {
  const { instanceId, targetDatabaseUrl, schemas, mode, nodeIds } = input;

  // ensure results rows exist for all items
  await ensureInstanceResults(instanceId);

  // load instance template version
  const inst = await queryOne<any>(
    `SELECT id, template_version_id FROM checklist_instances WHERE id=$1`,
    [instanceId],
  );

  // load automatic item nodes (optionally restricted)
  const params: any[] = [inst.template_version_id];
  let where = `WHERE n.template_version_id=$1 AND n.node_type='item' AND n.item_type IN ('automatic','hybrid')`;

  if (mode === 'items') {
    params.push(nodeIds ?? []);
    where += ` AND n.id = ANY($2::uuid[])`;
  }

  const items = await query<any>(
    `
    SELECT n.id AS node_id, n.check_ref, n.severity
    FROM checklist_nodes n
    ${where}
    `,
    params,
  );

  const targetPool: Pool = createTargetPool(targetDatabaseUrl);

  try {
    // cache FK metadata once per run
    const fks = await getForeignKeys(targetPool, schemas);

    for (const item of items) {
      const start = nowMs();
      const checkRef = item.check_ref as string | null;
      const severity = (item.severity ?? 'warning') as string;

      let violationsCount = 0;
      let outputSummary: string | null = null;
      let outputStats: any = null;
      let outputRows: any = null;
      let targetRefs: any[] = [];

      if (!checkRef) continue;

      if (checkRef === 'NO_PRIMARY_KEY') {
        const res = await checkNoPrimaryKey(targetPool, schemas);
        violationsCount = res.violations.length;
        outputSummary = `${violationsCount} tables missing primary key`;
        outputStats = { violationsCount };
        outputRows = res.violations.slice(0, 50);

        targetRefs = res.violations.map((v) => ({
          kind: 'table',
          schema: v.schema,
          table: v.table,
        }));
      }

      if (checkRef === 'FK_NOT_INDEXED') {
        const res = await checkFkNotIndexed(targetPool, schemas);
        violationsCount = res.violations.length;
        outputSummary = `${violationsCount} foreign keys missing a supporting index`;
        outputStats = { violationsCount };
        outputRows = res.violations.slice(0, 50);

        targetRefs = res.violations.map((v) => ({
          kind: 'relationship',
          fkName: v.fk_name,
          childSchema: v.child_schema,
          childTable: v.child_table,
          childCols: v.child_cols,
          // parent fields not needed for this check’s highlight
        }));
      }

      if (checkRef === 'FK_HAS_VIOLATIONS') {
        const res = await checkFkHasViolations(targetPool, fks, 25);
        violationsCount = res.violations.length;
        outputSummary = `${violationsCount} foreign keys have violating rows`;
        outputStats = {
          violatingRelationships: violationsCount,
          totalViolatingRows: res.violations.reduce((a, v) => a + v.violatingCount, 0),
        };
        outputRows = res.violations.slice(0, 20).map((v) => ({
          fk: v.fk,
          violatingCount: v.violatingCount,
          sample: v.sample,
        }));

        targetRefs = res.violations.map((v) => ({
          kind: 'relationship',
          fkName: v.fk.fk_name,
          childSchema: v.fk.child_schema,
          childTable: v.fk.child_table,
          childCols: v.fk.child_cols,
          parentSchema: v.fk.parent_schema,
          parentTable: v.fk.parent_table,
          parentCols: v.fk.parent_cols,
        }));
      }

      const status = statusFor(severity, violationsCount);
      const durationMs = nowMs() - start;

      // Write result row (single per item). Store a compact “targets” array in target_ref for UI.
      await queryOne<any>(
        `
        UPDATE checklist_instance_results r
        SET
          status=$3,
          severity=$4,
          run_type='automatic',
          ran_at=now(),
          duration_ms=$5,
          output_summary=$6,
          output_stats=$7,
          output_rows=$8,
          target_ref=$9,
          updated_at=now()
        WHERE r.instance_id=$1 AND r.node_id=$2
        RETURNING r.id
        `,
        [
          instanceId,
          item.node_id,
          status,
          severity,
          durationMs,
          outputSummary,
          outputStats,
          outputRows,
          { targets: targetRefs }, // standardized payload
        ],
      );
    }

    const rollup = await recomputeInstanceRollup(instanceId);
    return { ok: true, rollup };
  } finally {
    await targetPool.end().catch(() => {});
  }
}
```

---

# 1.4.07 Update the `/run` endpoint to call the runner

Edit the stub in `apps/api/src/routes/instances.ts` and replace the run handler with:

```ts
import { runChecklist } from '../checklist/runner';

app.post('/api/v1/checklist-instances/:instanceId/run', async (req) => {
  const instanceId = UUIDSchema.parse((req.params as any).instanceId);

  const Body = z.object({
    targetDatabaseUrl: z.string().min(10),
    schemas: z.array(z.string().min(1)).min(1),
    mode: z.enum(['all','items']).default('all'),
    nodeIds: z.array(z.string().uuid()).optional()
  });

  const body = Body.parse(req.body);

  const result = await runChecklist({
    instanceId,
    targetDatabaseUrl: body.targetDatabaseUrl,
    schemas: body.schemas,
    mode: body.mode,
    nodeIds: body.nodeIds,
  });

  return result;
});
```

---

# 1.4.08 ERD Annotations endpoint (table badges + relationship dots)

Create `apps/api/src/routes/annotations.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { query } from '../sql';

const UUIDSchema = z.string().uuid();

function sevRank(sev: string) {
  return sev === 'blocking' ? 3 : sev === 'error' ? 2 : sev === 'warning' ? 1 : 0;
}

export async function annotationsRoutes(app: FastifyInstance) {
  app.get('/api/v1/checklist-instances/:instanceId/annotations', async (req) => {
    const instanceId = UUIDSchema.parse((req.params as any).instanceId);

    // Pull only failing/warning/blocked rows with target_ref.targets array
    const rows = await query<any>(
      `
      SELECT status, severity, target_ref
      FROM checklist_instance_results
      WHERE instance_id = $1
        AND status IN ('blocked','fail','warning')
      `,
      [instanceId],
    );

    const tableMap = new Map<string, { severity: string; count: number }>();
    const relMap = new Map<string, { severity: string; codes: string[]; count: number; ref: any }>();

    for (const r of rows) {
      const targets = r.target_ref?.targets ?? [];
      for (const t of targets) {
        if (t.kind === 'table') {
          const key = `${t.schema}.${t.table}`;
          const existing = tableMap.get(key);
          if (!existing) {
            tableMap.set(key, { severity: r.severity, count: 1 });
          } else {
            // keep max severity, increment count
            if (sevRank(r.severity) > sevRank(existing.severity)) existing.severity = r.severity;
            existing.count += 1;
          }
        }

        if (t.kind === 'relationship') {
          // signature (stable enough v1)
          const childCols = (t.childCols ?? []).join(',');
          const parentCols = (t.parentCols ?? []).join(',');
          const key = `${t.childSchema}.${t.childTable}(${childCols})->${t.parentSchema ?? ''}.${t.parentTable ?? ''}(${parentCols})`;

          const existing = relMap.get(key);
          const ref = {
            childSchema: t.childSchema,
            childTable: t.childTable,
            childCols: t.childCols ?? [],
            parentSchema: t.parentSchema,
            parentTable: t.parentTable,
            parentCols: t.parentCols ?? [],
            fkName: t.fkName,
          };

          if (!existing) {
            relMap.set(key, { severity: r.severity, codes: [], count: 1, ref });
          } else {
            if (sevRank(r.severity) > sevRank(existing.severity)) existing.severity = r.severity;
            existing.count += 1;
          }
        }
      }
    }

    const tables = Array.from(tableMap.entries()).map(([k, v]) => {
      const [schema, table] = k.split('.');
      return { schema, table, severity: v.severity, count: v.count };
    });

    const relationships = Array.from(relMap.values()).map((v) => ({
      ...v.ref,
      severity: v.severity,
      count: v.count,
      // you can add fix actions later based on code/severity
    }));

    return { instanceId, tables, relationships };
  });
}
```

Wire it into `apps/api/src/index.ts`:

```ts
import { annotationsRoutes } from './routes/annotations';
await app.register(annotationsRoutes);
```

---

# 1.4.09 How to call runner (example)

POST:
`/api/v1/checklist-instances/:instanceId/run`

```json
{
  "targetDatabaseUrl": "postgresql://user:pass@localhost:5432/target_db",
  "schemas": ["public", "stats"],
  "mode": "all"
}
```

Then:

* `GET /api/v1/checklist-instances/:instanceId/issues`
* `GET /api/v1/checklist-instances/:instanceId/annotations`

---

# 1.4 Definition of Done

* [ ] Running checks updates `checklist_instance_results`
* [ ] Instance rollup counts/status update
* [ ] Issues endpoint returns blocking/warn rows
* [ ] Annotations endpoint returns table + relationship highlights
* [ ] ERD UI can paint badges/dots

---

## Next best step (1.5)

**Postgres Introspection Snapshot API** for ERD rendering (tables/cols/fks/indexes), so your ERD page can draw the graph from the target DB.

Say **“1.5”** and I’ll provide the introspection queries + endpoints + normalized response model.
