Awesome — here’s **2.3 SQL runner code** (the engine) with:

* ✅ **Safe interpolation** (`{{schemas}}`, `{{schema}}`, `{{table}}`, `{{threshold.x}}`, `{{vars.any}}`)
* ✅ **Hard limits**: statement timeout + row cap (auto LIMIT)
* ✅ **Result mapping → `target_ref.targets[]`** (table/relationship/column)
* ✅ **Integration into `/run`** so SQL-based checklist items work alongside built-ins

Everything below is TypeScript for the **Node + Fastify + pg** backend.

---

# 1) SQL Template Interpolator (safe + minimal)

### `apps/api/src/sqlrunner/interpolate.ts`

```ts
export type InterpContext = {
  schemas: string[];
  schema?: string;
  table?: string;
  thresholds?: Record<string, number>;
  vars?: Record<string, any>;
};

export class SqlInterpolationError extends Error {
  code = 'SQL_INTERPOLATION_ERROR';
}

function getPath(obj: any, path: string): any {
  const parts = path.split('.').filter(Boolean);
  let cur = obj;
  for (const p of parts) {
    if (cur == null || typeof cur !== 'object' || !(p in cur)) return undefined;
    cur = cur[p];
  }
  return cur;
}

function quoteIdent(s: string) {
  // identifier quoting (schema/table/column)
  return `"${String(s).replace(/"/g, '""')}"`;
}

function quoteLiteral(s: string) {
  // string literal quoting for SQL
  const v = String(s);
  return `'${v.replace(/'/g, "''")}'`;
}

function listLiteral(items: string[]) {
  // returns: ('a','b','c')
  return `(${items.map(quoteLiteral).join(',')})`;
}

export function interpolateSql(template: string, ctx: InterpContext): string {
  // allow only {{ ... }} tokens with a restricted grammar
  // tokens allowed:
  //  - schemas             => ('public','stats')
  //  - schema              => "public" (identifier)
  //  - table               => "users"  (identifier)
  //  - threshold.<name>    => numeric
  //  - vars.<path>         => literal (string/number/bool/null)

  const tokenRe = /\{\{\s*([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z0-9_]+)*)\s*\}\}/g;

  const out = template.replace(tokenRe, (_m, tokenPath) => {
    const root = tokenPath.split('.')[0];

    if (tokenPath === 'schemas') {
      if (!ctx.schemas?.length) throw new SqlInterpolationError('Missing ctx.schemas');
      return listLiteral(ctx.schemas);
    }

    if (tokenPath === 'schema') {
      if (!ctx.schema) throw new SqlInterpolationError('Missing ctx.schema');
      return quoteIdent(ctx.schema);
    }

    if (tokenPath === 'table') {
      if (!ctx.table) throw new SqlInterpolationError('Missing ctx.table');
      return quoteIdent(ctx.table);
    }

    if (root === 'threshold') {
      const name = tokenPath.slice('threshold.'.length);
      const val = ctx.thresholds?.[name];
      if (typeof val !== 'number' || Number.isNaN(val)) {
        throw new SqlInterpolationError(`Missing threshold.${name}`);
      }
      return String(val);
    }

    if (root === 'vars') {
      const path = tokenPath.slice('vars.'.length);
      const val = getPath(ctx.vars ?? {}, path);
      if (val === undefined) throw new SqlInterpolationError(`Missing vars.${path}`);

      if (val === null) return 'NULL';
      if (typeof val === 'number') return String(val);
      if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
      // default string
      return quoteLiteral(String(val));
    }

    throw new SqlInterpolationError(`Unknown token: ${tokenPath}`);
  });

  // Reject any remaining {{ }} tokens (unknown/malformed)
  if (/\{\{|\}\}/.test(out)) {
    throw new SqlInterpolationError('Unresolved template tokens remain in SQL');
  }

  return out;
}
```

---

# 2) SQL Guardrails (timeout, row cap, single statement)

### `apps/api/src/sqlrunner/limits.ts`

```ts
export type SqlLimits = {
  timeoutMs: number; // statement timeout
  rowCap: number;    // max rows to return
};

export class SqlLimitError extends Error {
  code = 'SQL_LIMIT_ERROR';
}

export function ensureSingleStatement(sql: string) {
  // Simple: disallow semicolons except possibly trailing whitespace
  const trimmed = sql.trim();
  const parts = trimmed.split(';').map((p) => p.trim()).filter(Boolean);
  if (parts.length > 1) throw new SqlLimitError('Multiple statements are not allowed');
  return parts[0] ?? trimmed;
}

export function applyRowCap(sql: string, rowCap: number) {
  // naive: if SQL already has LIMIT, keep it; else append LIMIT
  // v1 best-effort; good enough for shipping
  const hasLimit = /\blimit\b/i.test(sql);
  if (hasLimit) return sql;
  return `${sql}\nLIMIT ${Math.max(1, Math.min(rowCap, 500))}`;
}
```

---

# 3) Mapping: rows → `target_ref.targets[]`

This is what lets **Issues** and **Annotations** jump to tables/relationships/columns.

### `apps/api/src/sqlrunner/mapping.ts`

```ts
export type TargetKind = 'table' | 'relationship' | 'column';

export type ResultMapping = {
  targetKind: TargetKind;
  // Map field names in SQL result rows -> target fields
  // Example for table:
  // { targetKind:'table', fields:{ schema:'schema', table:'table' } }
  // Example relationship:
  // { targetKind:'relationship', fields:{ childSchema:'child_schema', childTable:'child_table', childCols:'child_cols', parentSchema:'parent_schema', parentTable:'parent_table', parentCols:'parent_cols' } }
  fields: Record<string, string>;
};

export function normalizeStringArray(v: any): string[] {
  if (Array.isArray(v)) return v.map(String);
  if (typeof v === 'string') {
    // allow comma-separated
    return v.split(',').map((s) => s.trim()).filter(Boolean);
  }
  return [];
}

export function buildTargetsFromRows(rows: any[], mapping: ResultMapping | null, sampleMax = 200) {
  if (!mapping) return { targets: [] as any[] };

  const targets: any[] = [];
  const seen = new Set<string>();

  const pick = (row: any, key: string) => row?.[mapping.fields[key]];

  for (const row of rows.slice(0, sampleMax)) {
    if (mapping.targetKind === 'table') {
      const schema = String(pick(row, 'schema') ?? '');
      const table = String(pick(row, 'table') ?? '');
      if (!schema || !table) continue;

      const sig = `table:${schema}.${table}`;
      if (seen.has(sig)) continue;
      seen.add(sig);

      targets.push({ kind: 'table', schema, table });
    }

    if (mapping.targetKind === 'column') {
      const schema = String(pick(row, 'schema') ?? '');
      const table = String(pick(row, 'table') ?? '');
      const column = String(pick(row, 'column') ?? '');
      if (!schema || !table || !column) continue;

      const sig = `col:${schema}.${table}.${column}`;
      if (seen.has(sig)) continue;
      seen.add(sig);

      targets.push({ kind: 'column', schema, table, column });
    }

    if (mapping.targetKind === 'relationship') {
      const childSchema = String(pick(row, 'childSchema') ?? '');
      const childTable = String(pick(row, 'childTable') ?? '');
      const parentSchema = String(pick(row, 'parentSchema') ?? '');
      const parentTable = String(pick(row, 'parentTable') ?? '');

      const childCols = normalizeStringArray(pick(row, 'childCols'));
      const parentCols = normalizeStringArray(pick(row, 'parentCols'));

      if (!childSchema || !childTable) continue;

      const sig = `rel:${childSchema}.${childTable}(${childCols.join(',')})->${parentSchema}.${parentTable}(${parentCols.join(',')})`;
      if (seen.has(sig)) continue;
      seen.add(sig);

      targets.push({
        kind: 'relationship',
        childSchema,
        childTable,
        childCols,
        parentSchema: parentSchema || undefined,
        parentTable: parentTable || undefined,
        parentCols: parentCols.length ? parentCols : undefined,
        fkName: mapping.fields['fkName'] ? String(pick(row, 'fkName') ?? '') : undefined,
      });
    }
  }

  return { targets };
}
```

---

# 4) SQL Runner (exec with timeout + mapping + stats)

### `apps/api/src/sqlrunner/runSqlCheck.ts`

```ts
import type { Pool } from 'pg';
import { interpolateSql, type InterpContext } from './interpolate';
import { ensureSingleStatement, applyRowCap, type SqlLimits } from './limits';
import { buildTargetsFromRows, type ResultMapping } from './mapping';

export type SqlCheckRunInput = {
  pool: Pool;
  template: string;              // sql_template from node
  ctx: InterpContext;            // injection context
  limits: SqlLimits;
  mapping: ResultMapping | null; // node.result_mapping
};

export type SqlCheckRunOutput = {
  sqlFinal: string;
  rows: any[];
  columns: { name: string; dataTypeId?: number }[];
  stats: { rowCount: number };
  targetRef: { targets: any[] };
};

export class SqlRunError extends Error {
  code = 'SQL_RUN_ERROR';
}

export async function runSqlCheck(input: SqlCheckRunInput): Promise<SqlCheckRunOutput> {
  const { pool, template, ctx, limits, mapping } = input;

  // 1) interpolate (safe)
  const interpolated = interpolateSql(template, ctx);

  // 2) single statement + row cap
  const single = ensureSingleStatement(interpolated);
  const capped = applyRowCap(single, limits.rowCap);

  // 3) run with statement timeout on this session
  // Use a dedicated client so SET LOCAL is scoped
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await client.query(`SET LOCAL statement_timeout = $1`, [limits.timeoutMs]);

    const res = await client.query(capped);

    await client.query('COMMIT');

    const columns = (res.fields ?? []).map((f: any) => ({
      name: f.name,
      dataTypeId: f.dataTypeID,
    }));

    const rows = res.rows ?? [];
    const targetRef = buildTargetsFromRows(rows, mapping);

    return {
      sqlFinal: capped,
      rows,
      columns,
      stats: { rowCount: rows.length },
      targetRef,
    };
  } catch (e: any) {
    try { await client.query('ROLLBACK'); } catch {}
    throw new SqlRunError(e?.message ?? 'SQL run failed');
  } finally {
    client.release();
  }
}
```

---

# 5) Pass/Fail evaluation helper (rowCount rule)

### `apps/api/src/sqlrunner/evaluate.ts`

```ts
export type PassFailRule =
  | { type: 'rowCount'; max: number } // pass if rows <= max
  | { type: 'rowCount'; min: number } // pass if rows >= min
  | { type: 'alwaysFail' }
  | { type: 'alwaysPass' };

export function evaluateRule(rule: any, rowCount: number) {
  const r = rule as PassFailRule | null;

  if (!r) return { passed: rowCount === 0, reason: 'default rowCount==0' };

  if (r.type === 'alwaysPass') return { passed: true, reason: 'alwaysPass' };
  if (r.type === 'alwaysFail') return { passed: false, reason: 'alwaysFail' };

  if (r.type === 'rowCount' && 'max' in r) {
    return { passed: rowCount <= r.max, reason: `rowCount<=${r.max}` };
  }
  if (r.type === 'rowCount' && 'min' in r) {
    return { passed: rowCount >= r.min, reason: `rowCount>=${r.min}` };
  }

  return { passed: rowCount === 0, reason: 'fallback rowCount==0' };
}
```

---

# 6) Integrate SQL checks into the Checklist Runner

Patch your runner from **1.4** (`apps/api/src/checklist/runner.ts`) to add an `else if` branch for `check_kind='sql'` (or `sql_template` present).

### 6.1 Make sure you SELECT node SQL fields

Update the items query in `runner.ts` to pull these columns from `checklist_nodes`:

```sql
SELECT
  n.id AS node_id,
  n.check_ref,
  n.severity,
  n.check_kind,
  n.sql_template,
  n.pass_fail_rule,
  n.result_mapping
FROM checklist_nodes n
...
```

### 6.2 Add the SQL branch in the loop

Inside your `for (const item of items)` loop:

```ts
import { runSqlCheck } from '../sqlrunner/runSqlCheck';
import { evaluateRule } from '../sqlrunner/evaluate';
```

Then add this block **after** your built-in checks, or as a fallback:

```ts
      // SQL check
      if (item.check_kind === 'sql' || item.sql_template) {
        const template = item.sql_template as string | null;
        if (!template) {
          violationsCount = 0;
          outputSummary = 'No SQL template configured';
          outputStats = { rowCount: 0 };
          outputRows = [];
          targetRefs = [];
        } else {
          const mapping = (item.result_mapping ?? null) as any; // ResultMapping
          const limits = { timeoutMs: 2500, rowCap: 50 };

          // ctx for interpolation: v1 includes schemas only
          // Later: table-scoped iteration can set ctx.schema/ctx.table
          const ctx = { schemas, thresholds: {}, vars: {} };

          const res = await runSqlCheck({
            pool: targetPool,
            template,
            ctx,
            limits,
            mapping,
          });

          // Determine pass/fail from pass_fail_rule (default: pass if rowCount==0)
          const evalRes = evaluateRule(item.pass_fail_rule, res.rows.length);
          const passed = evalRes.passed;

          violationsCount = passed ? 0 : res.rows.length;

          outputSummary = passed
            ? `PASS (${res.rows.length} rows, ${evalRes.reason})`
            : `FAIL (${res.rows.length} rows, ${evalRes.reason})`;

          outputStats = {
            rowCount: res.rows.length,
            reason: evalRes.reason,
          };

          outputRows = res.rows.slice(0, 50);
          targetRefs = res.targetRef.targets ?? [];
        }
      }
```

**Important:** If you want SQL checks to *only* run when `check_ref` is null, wrap it with:

```ts
if (!checkRef && (item.check_kind === 'sql' || item.sql_template)) { ... }
```

…but I recommend letting `check_kind` decide.

---

# 7) Node schema: `result_mapping` examples

### Table-target mapping (typical)

```json
{
  "targetKind": "table",
  "fields": { "schema": "schema", "table": "table" }
}
```

### Relationship-target mapping

```json
{
  "targetKind": "relationship",
  "fields": {
    "childSchema": "child_schema",
    "childTable": "child_table",
    "childCols": "child_cols",
    "parentSchema": "parent_schema",
    "parentTable": "parent_table",
    "parentCols": "parent_cols"
  }
}
```

### Column-target mapping

```json
{
  "targetKind": "column",
  "fields": { "schema": "schema", "table": "table", "column": "column" }
}
```

---

# 8) A built-in SQL check template you can ship immediately

**NO_PK via SQL** (targets tables)

```sql
SELECT
  n.nspname AS schema,
  c.relname AS table
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_constraint con
  ON con.conrelid = c.oid AND con.contype='p'
WHERE c.relkind='r'
  AND n.nspname IN {{schemas}}
  AND con.oid IS NULL
ORDER BY 1,2
```

With mapping:

```json
{ "targetKind": "table", "fields": { "schema": "schema", "table": "table" } }
```

Pass/fail:

```json
{ "type": "rowCount", "max": 0 }
```

---

## Next piece (since you’re shipping a SQL builder)

Say **“2.3 SQL test endpoint code”** and I’ll add:

* `POST /api/v1/sql/test`
* inferred `mappingSuggestions`
* optional “dry-run explain” mode for optimizer/explainer later
