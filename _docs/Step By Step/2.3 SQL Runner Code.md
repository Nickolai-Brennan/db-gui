Awesome — here’s **2.3 SQL runner code** (the engine) with:

* ✅ **Safe interpolation** (`{{schemas}}`, `{{schema}}`, `{{table}}`, `{{threshold.x}}`, `{{vars.any}}`)
* ✅ **Hard limits**: statement timeout + row cap (auto LIMIT)
* ✅ **Result mapping → `target_ref.targets[]`** (table/relationship/column)
* ✅ **Integration into `/run`** so SQL-based checklist items work alongside built-ins

Everything below is TypeScript for the **Node + Fastify + pg** backend.

---

# 1) SQL Template Interpolator (safe + minimal)

### `apps/api/src/sqlrunner/interpolate.ts`

```ts
export type InterpContext = {
  schemas: string[];
  schema?: string;
  table?: string;
  thresholds?: Record<string, number>;
  vars?: Record<string, any>;
};

export class SqlInterpolationError extends Error {
  code = 'SQL_INTERPOLATION_ERROR';
}

function getPath(obj: any, path: string): any {
  const parts = path.split('.').filter(Boolean);
  let cur = obj;
  for (const p of parts) {
    if (cur == null || typeof cur !== 'object' || !(p in cur)) return undefined;
    cur = cur[p];
  }
  return cur;
}

function quoteIdent(s: string) {
  // identifier quoting (schema/table/column)
  return `"${String(s).replace(/"/g, '""')}"`;
}

function quoteLiteral(s: string) {
  // string literal quoting for SQL
  const v = String(s);
  return `'${v.replace(/'/g, "''")}'`;
}

function listLiteral(items: string[]) {
  // returns: ('a','b','c')
  return `(${items.map(quoteLiteral).join(',')})`;
}

export function interpolateSql(template: string, ctx: InterpContext): string {
  // allow only {{ ... }} tokens with a restricted grammar
  // tokens allowed:
  //  - schemas             => ('public','stats')
  //  - schema              => "public" (identifier)
  //  - table               => "users"  (identifier)
  //  - threshold.<name>    => numeric
  //  - vars.<path>         => literal (string/number/bool/null)

  const tokenRe = /\{\{\s*([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z0-9_]+)*)\s*\}\}/g;

  const out = template.replace(tokenRe, (_m, tokenPath) => {
    const root = tokenPath.split('.')[0];

    if (tokenPath === 'schemas') {
      if (!ctx.schemas?.length) throw new SqlInterpolationError('Missing ctx.schemas');
      return listLiteral(ctx.schemas);
    }

    if (tokenPath === 'schema') {
      if (!ctx.schema) throw new SqlInterpolationError('Missing ctx.schema');
      return quoteIdent(ctx.schema);
    }

    if (tokenPath === 'table') {
      if (!ctx.table) throw new SqlInterpolationError('Missing ctx.table');
      return quoteIdent(ctx.table);
    }

    if (root === 'threshold') {
      const name = tokenPath.slice('threshold.'.length);
      const val = ctx.thresholds?.[name];
      if (typeof val !== 'number' || Number.isNaN(val)) {
        throw new SqlInterpolationError(`Missing threshold.${name}`);
      }
      return String(val);
    }

    if (root === 'vars') {
      const path = tokenPath.slice('vars.'.length);
      const val = getPath(ctx.vars ?? {}, path);
      if (val === undefined) throw new SqlInterpolationError(`Missing vars.${path}`);

      if (val === null) return 'NULL';
      if (typeof val === 'number') return String(val);
      if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
      // default string
      return quoteLiteral(String(val));
    }

    throw new SqlInterpolationError(`Unknown token: ${tokenPath}`);
  });

  // Reject any remaining {{ }} tokens (unknown/malformed)
  if (/\{\{|\}\}/.test(out)) {
    throw new SqlInterpolationError('Unresolved template tokens remain in SQL');
  }

  return out;
}
```

---

# 2) SQL Guardrails (timeout, row cap, single statement)

### `apps/api/src/sqlrunner/limits.ts`

```ts
export type SqlLimits = {
  timeoutMs: number; // statement timeout
  rowCap: number;    // max rows to return
};

export class SqlLimitError extends Error {
  code = 'SQL_LIMIT_ERROR';
}

export function ensureSingleStatement(sql: string) {
  // Simple: disallow semicolons except possibly trailing whitespace
  const trimmed = sql.trim();
  const parts = trimmed.split(';').map((p) => p.trim()).filter(Boolean);
  if (parts.length > 1) throw new SqlLimitError('Multiple statements are not allowed');
  return parts[0] ?? trimmed;
}

export function applyRowCap(sql: string, rowCap: number) {
  // naive: if SQL already has LIMIT, keep it; else append LIMIT
  // v1 best-effort; good enough for shipping
  const hasLimit = /\blimit\b/i.test(sql);
  if (hasLimit) return sql;
  return `${sql}\nLIMIT ${Math.max(1, Math.min(rowCap, 500))}`;
}
```

---

# 3) Mapping: rows → `target_ref.targets[]`

This is what lets **Issues** and **Annotations** jump to tables/relationships/columns.

### `apps/api/src/sqlrunner/mapping.ts`

```ts
export type TargetKind = 'table' | 'relationship' | 'column';

export type ResultMapping = {
  targetKind: TargetKind;
  // Map field names in SQL result rows -> target fields
  // Example for table:
  // { targetKind:'table', fields:{ schema:'schema', table:'table' } }
  // Example relationship:
  // { targetKind:'relationship', fields:{ childSchema:'child_schema', childTable:'child_table', childCols:'child_cols', parentSchema:'parent_schema', parentTable:'parent_table', parentCols:'parent_cols' } }
  fields: Record<string, string>;
};

export function normalizeStringArray(v: any): string[] {
  if (Array.isArray(v)) return v.map(String);
  if (typeof v === 'string') {
    // allow comma-separated
    return v.split(',').map((s) => s.trim()).filter(Boolean);
  }
  return [];
}

export function buildTargetsFromRows(rows: any[], mapping: ResultMapping | null, sampleMax = 200) {
  if (!mapping) return { targets: [] as any[] };

  const targets: any[] = [];
  const seen = new Set<string>();

  const pick = (row: any, key: string) => row?.[mapping.fields[key]];

  for (const row of rows.slice(0, sampleMax)) {
    if (mapping.targetKind === 'table') {
      const schema = String(pick(row, 'schema') ?? '');
      const table = String(pick(row, 'table') ?? '');
      if (!schema || !table) continue;

      const sig = `table:${schema}.${table}`;
      if (seen.has(sig)) continue;
      seen.add(sig);

      targets.push({ kind: 'table', schema, table });
    }

    if (mapping.targetKind === 'column') {
      const schema = String(pick(row, 'schema') ?? '');
      const table = String(pick(row, 'table') ?? '');
      const column = String(pick(row, 'column') ?? '');
      if (!schema || !table || !column) continue;

      const sig = `col:${schema}.${table}.${column}`;
      if (seen.has(sig)) continue;
      seen.add(sig);

      targets.push({ kind: 'column', schema, table, column });
    }

    if (mapping.targetKind === 'relationship') {
      const childSchema = String(pick(row, 'childSchema') ?? '');
      const childTable = String(pick(row, 'childTable') ?? '');
      const parentSchema = String(pick(row, 'parentSchema') ?? '');
      const parentTable = String(pick(row, 'parentTable') ?? '');

      const childCols = normalizeStringArray(pick(row, 'childCols'));
      const parentCols = normalizeStringArray(pick(row, 'parentCols'));

      if (!childSchema || !childTable) continue;

      const sig = `rel:${childSchema}.${childTable}(${childCols.join(',')})->${parentSchema}.${parentTable}(${parentCols.join(',')})`;
      if (seen.has(sig)) continue;
      seen.add(sig);

      targets.push({
        kind: 'relationship',
        childSchema,
        childTable,
        childCols,
        parentSchema: parentSchema || undefined,
        parentTable: parentTable || undefined,
        parentCols: parentCols.length ? parentCols : undefined,
        fkName: mapping.fields['fkName'] ? String(pick(row, 'fkName') ?? '') : undefined,
      });
    }
  }

  return { targets };
}
```

---

# 4) SQL Runner (exec with timeout + mapping + stats)

### `apps/api/src/sqlrunner/runSqlCheck.ts`

```ts
import type { Pool } from 'pg';
import { interpolateSql, type InterpContext } from './interpolate';
import { ensureSingleStatement, applyRowCap, type SqlLimits } from './limits';
import { buildTargetsFromRows, type ResultMapping } from './mapping';

export type SqlCheckRunInput = {
  pool: Pool;
  template: string;              // sql_template from node
  ctx: InterpContext;            // injection context
  limits: SqlLimits;
  mapping: ResultMapping | null; // node.result_mapping
};

export type SqlCheckRunOutput = {
  sqlFinal: string;
  rows: any[];
  columns: { name: string; dataTypeId?: number }[];
  stats: { rowCount: number };
  targetRef: { targets: any[] };
};

export class SqlRunError extends Error {
  code = 'SQL_RUN_ERROR';
}

export async function runSqlCheck(input: SqlCheckRunInput): Promise<SqlCheckRunOutput> {
  const { pool, template, ctx, limits, mapping } = input;

  // 1) interpolate (safe)
  const interpolated = interpolateSql(template, ctx);

  // 2) single statement + row cap
  const single = ensureSingleStatement(interpolated);
  const capped = applyRowCap(single, limits.rowCap);

  // 3) run with statement timeout on this session
  // Use a dedicated client so SET LOCAL is scoped
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await client.query(`SET LOCAL statement_timeout = $1`, [limits.timeoutMs]);

    const res = await client.query(capped);

    await client.query('COMMIT');

    const columns = (res.fields ?? []).map((f: any) => ({
      name: f.name,
      dataTypeId: f.dataTypeID,
    }));

    const rows = res.rows ?? [];
    const targetRef = buildTargetsFromRows(rows, mapping);

    return {
      sqlFinal: capped,
      rows,
      columns,
      stats: { rowCount: rows.length },
      targetRef,
    };
  } catch (e: any) {
    try { await client.query('ROLLBACK'); } catch {}
    throw new SqlRunError(e?.message ?? 'SQL run failed');
  } finally {
    client.release();
  }
}
```

---

# 5) Pass/Fail evaluation helper (rowCount rule)

### `apps/api/src/sqlrunner/evaluate.ts`

```ts
export type PassFailRule =
  | { type: 'rowCount'; max: number } // pass if rows <= max
  | { type: 'rowCount'; min: number } // pass if rows >= min
  | { type: 'alwaysFail' }
  | { type: 'alwaysPass' };

export function evaluateRule(rule: any, rowCount: number) {
  const r = rule as PassFailRule | null;

  if (!r) return { passed: rowCount === 0, reason: 'default rowCount==0' };

  if (r.type === 'alwaysPass') return { passed: true, reason: 'alwaysPass' };
  if (r.type === 'alwaysFail') return { passed: false, reason: 'alwaysFail' };

  if (r.type === 'rowCount' && 'max' in r) {
    return { passed: rowCount <= r.max, reason: `rowCount<=${r.max}` };
  }
  if (r.type === 'rowCount' && 'min' in r) {
    return { passed: rowCount >= r.min, reason: `rowCount>=${r.min}` };
  }

  return { passed: rowCount === 0, reason: 'fallback rowCount==0' };
}
```

---

# 6) Integrate SQL checks into the Checklist Runner

Patch your runner from **1.4** (`apps/api/src/checklist/runner.ts`) to add an `else if` branch for `check_kind='sql'` (or `sql_template` present).

### 6.1 Make sure you SELECT node SQL fields

Update the items query in `runner.ts` to pull these columns from `checklist_nodes`:

```sql
SELECT
  n.id AS node_id,
  n.check_ref,
  n.severity,
  n.check_kind,
  n.sql_template,
  n.pass_fail_rule,
  n.result_mapping
FROM checklist_nodes n
...
```

### 6.2 Add the SQL branch in the loop

Inside your `for (const item of items)` loop:

```ts
import { runSqlCheck } from '../sqlrunner/runSqlCheck';
import { evaluateRule } from '../sqlrunner/evaluate';
```

Then add this block **after** your built-in checks, or as a fallback:

```ts
      // SQL check
      if (item.check_kind === 'sql' || item.sql_template) {
        const template = item.sql_template as string | null;
        if (!template) {
          violationsCount = 0;
          outputSummary = 'No SQL template configured';
          outputStats = { rowCount: 0 };
          outputRows = [];
          targetRefs = [];
        } else {
          const mapping = (item.result_mapping ?? null) as any; // ResultMapping
          const limits = { timeoutMs: 2500, rowCap: 50 };

          // ctx for interpolation: v1 includes schemas only
          // Later: table-scoped iteration can set ctx.schema/ctx.table
          const ctx = { schemas, thresholds: {}, vars: {} };

          const res = await runSqlCheck({
            pool: targetPool,
            template,
            ctx,
            limits,
            mapping,
          });

          // Determine pass/fail from pass_fail_rule (default: pass if rowCount==0)
          const evalRes = evaluateRule(item.pass_fail_rule, res.rows.length);
          const passed = evalRes.passed;

          violationsCount = passed ? 0 : res.rows.length;

          outputSummary = passed
            ? `PASS (${res.rows.length} rows, ${evalRes.reason})`
            : `FAIL (${res.rows.length} rows, ${evalRes.reason})`;

          outputStats = {
            rowCount: res.rows.length,
            reason: evalRes.reason,
          };

          outputRows = res.rows.slice(0, 50);
          targetRefs = res.targetRef.targets ?? [];
        }
      }
```

**Important:** If you want SQL checks to *only* run when `check_ref` is null, wrap it with:

```ts
if (!checkRef && (item.check_kind === 'sql' || item.sql_template)) { ... }
```

…but I recommend letting `check_kind` decide.

---

# 7) Node schema: `result_mapping` examples

### Table-target mapping (typical)

```json
{
  "targetKind": "table",
  "fields": { "schema": "schema", "table": "table" }
}
```

### Relationship-target mapping

```json
{
  "targetKind": "relationship",
  "fields": {
    "childSchema": "child_schema",
    "childTable": "child_table",
    "childCols": "child_cols",
    "parentSchema": "parent_schema",
    "parentTable": "parent_table",
    "parentCols": "parent_cols"
  }
}
```

### Column-target mapping

```json
{
  "targetKind": "column",
  "fields": { "schema": "schema", "table": "table", "column": "column" }
}
```

---

# 8) A built-in SQL check template you can ship immediately

**NO_PK via SQL** (targets tables)

```sql
SELECT
  n.nspname AS schema,
  c.relname AS table
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_constraint con
  ON con.conrelid = c.oid AND con.contype='p'
WHERE c.relkind='r'
  AND n.nspname IN {{schemas}}
  AND con.oid IS NULL
ORDER BY 1,2
```

With mapping:

```json
{ "targetKind": "table", "fields": { "schema": "schema", "table": "table" } }
```

Pass/fail:

```json
{ "type": "rowCount", "max": 0 }
```

---

## Next piece (since you’re shipping a SQL builder)

Say **“2.3 SQL test endpoint code”** and I’ll add:

* `POST /api/v1/sql/test`
* inferred `mappingSuggestions`
* optional “dry-run explain” mode for optimizer/explainer later

Below is **2.2 issues filters code** for a real shipping-quality **Issues Queue** endpoint:

✅ filters: `severity`, `status`, `sectionId`, `schema`, `table`
✅ sorting: **blocking first**, then error, then warning (and within that: blocked → fail → warning → unchecked/pass)
✅ uses `target_ref.targets[]` (table/relationship/column) to filter schema/table
✅ supports pagination (`limit`, `offset`)
✅ returns `focus` object that your ERD can jump to

---

# 1) Route: `GET /api/v1/checklist-instances/:instanceId/issues`

### `apps/api/src/routes/issues.ts`

```ts
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { query } from '../sql';

const UUID = z.string().uuid();

function parseCsv(v?: string | string[]) {
  if (!v) return [];
  const s = Array.isArray(v) ? v.join(',') : v;
  return s
    .split(',')
    .map((x) => x.trim())
    .filter(Boolean);
}

function focusFromTargetRef(targetRef: any) {
  const t = targetRef?.targets?.[0];
  if (!t) return null;

  if (t.kind === 'table') {
    return { type: 'table', key: `${t.schema}.${t.table}` };
  }

  if (t.kind === 'column') {
    return { type: 'table', key: `${t.schema}.${t.table}` }; // focus table for column issues
  }

  if (t.kind === 'relationship') {
    const childCols = (t.childCols ?? []).join(',');
    const parentCols = (t.parentCols ?? []).join(',');
    return {
      type: 'relationship',
      key: `${t.childSchema}.${t.childTable}(${childCols})->${t.parentSchema ?? ''}.${t.parentTable ?? ''}(${parentCols})`,
    };
  }

  return null;
}

export async function issuesRoutes(app: FastifyInstance) {
  app.get('/api/v1/checklist-instances/:instanceId/issues', async (req) => {
    const instanceId = UUID.parse((req.params as any).instanceId);

    const Q = z.object({
      severity: z.string().optional(), // csv blocking,error,warning
      status: z.string().optional(),   // csv blocked,fail,warning,unchecked,pass
      sectionId: z.string().uuid().optional(),
      schema: z.string().optional(),
      table: z.string().optional(),
      limit: z.coerce.number().int().min(1).max(500).default(200),
      offset: z.coerce.number().int().min(0).default(0),
    });

    const q = Q.parse(req.query ?? {});
    const severities = parseCsv(q.severity);
    const statuses = parseCsv(q.status);

    // Build WHERE dynamically (parameterized)
    const where: string[] = [`r.instance_id = $1`];
    const params: any[] = [instanceId];
    let p = 1;

    // severity filter
    if (severities.length) {
      params.push(severities);
      p += 1;
      where.push(`r.severity = ANY($${p}::text[])`);
    }

    // status filter
    if (statuses.length) {
      params.push(statuses);
      p += 1;
      where.push(`r.status = ANY($${p}::text[])`);
    }

    // schema/table filter using target_ref.targets
    // Supports issues where targets include:
    // - table {schema, table}
    // - column {schema, table, column}
    // - relationship {childSchema, childTable, parentSchema, parentTable}
    if (q.schema) {
      params.push(q.schema);
      p += 1;
      where.push(`
        EXISTS (
          SELECT 1
          FROM jsonb_array_elements(COALESCE(r.target_ref->'targets','[]'::jsonb)) t
          WHERE
            (t->>'schema' = $${p})
            OR (t->>'childSchema' = $${p})
            OR (t->>'parentSchema' = $${p})
        )
      `);
    }

    if (q.table) {
      params.push(q.table);
      p += 1;
      where.push(`
        EXISTS (
          SELECT 1
          FROM jsonb_array_elements(COALESCE(r.target_ref->'targets','[]'::jsonb)) t
          WHERE
            (t->>'table' = $${p})
            OR (t->>'childTable' = $${p})
            OR (t->>'parentTable' = $${p})
        )
      `);
    }

    // sectionId filter: include all descendant nodes of that section/group
    // We scope descendants to the SAME template_version_id as the instance.
    if (q.sectionId) {
      params.push(q.sectionId);
      p += 1;

      where.push(`
        r.node_id IN (
          WITH RECURSIVE inst AS (
            SELECT template_version_id
            FROM checklist_instances
            WHERE id = $1
          ),
          subtree AS (
            SELECT n.id
            FROM checklist_nodes n
            JOIN inst i ON i.template_version_id = n.template_version_id
            WHERE n.id = $${p}
            UNION ALL
            SELECT c.id
            FROM checklist_nodes c
            JOIN subtree s ON s.id = c.parent_id
          )
          SELECT id FROM subtree
        )
      `);
    }

    // Sort rules:
    // 1) severity: blocking -> error -> warning
    // 2) status: blocked -> fail -> warning -> unchecked -> pass
    // 3) most recent first
    const sql = `
      SELECT
        r.id AS result_id,
        r.node_id,
        r.status AS result_status,
        r.severity AS result_severity,
        r.output_summary,
        r.output_stats,
        r.target_ref,
        r.updated_at,

        n.title AS node_title,
        n.check_ref,
        n.node_type,
        n.parent_id,

        -- helpful for UI grouping
        i.template_version_id

      FROM checklist_instance_results r
      JOIN checklist_nodes n ON n.id = r.node_id
      JOIN checklist_instances i ON i.id = r.instance_id

      WHERE ${where.join('\n AND ')}

      ORDER BY
        CASE r.severity
          WHEN 'blocking' THEN 0
          WHEN 'error' THEN 1
          WHEN 'warning' THEN 2
          ELSE 9
        END ASC,
        CASE r.status
          WHEN 'blocked' THEN 0
          WHEN 'fail' THEN 1
          WHEN 'warning' THEN 2
          WHEN 'unchecked' THEN 3
          WHEN 'pass' THEN 4
          ELSE 9
        END ASC,
        r.updated_at DESC

      LIMIT ${q.limit} OFFSET ${q.offset}
    `;

    const rows = await query<any>(sql, params);

    const issues = rows.map((r: any) => ({
      resultId: r.result_id,
      nodeId: r.node_id,
      code: r.check_ref ?? 'SQL',
      title: r.node_title,
      severity: r.result_severity,
      status: r.result_status,
      updatedAt: r.updated_at,
      outputSummary: r.output_summary ?? null,
      outputStats: r.output_stats ?? null,
      targetRef: r.target_ref ?? null,
      focus: focusFromTargetRef(r.target_ref),
    }));

    return {
      instanceId,
      filters: {
        severity: severities,
        status: statuses,
        sectionId: q.sectionId ?? null,
        schema: q.schema ?? null,
        table: q.table ?? null,
        limit: q.limit,
        offset: q.offset,
      },
      issues,
    };
  });
}
```

---

# 2) Wire it up

### `apps/api/src/index.ts`

```ts
import { issuesRoutes } from './routes/issues';
// ...
await app.register(issuesRoutes);
```

---

# 3) Example calls

### Blocking + error, only in `public` schema

`GET /api/v1/checklist-instances/:id/issues?severity=blocking,error&schema=public`

### Only issues for a given section subtree

`GET /api/v1/checklist-instances/:id/issues?sectionId=<uuid>`

### Only table-specific issues

`GET /api/v1/checklist-instances/:id/issues?table=users`

---

# 4) Small but important note (UI expectation)

This endpoint returns **all results** by default (including pass/unchecked).
If you want “issues only” behavior, add a default `status IN ('blocked','fail','warning')` when no status filter is provided.

Here’s that tweak (drop into code after `statuses` parse):

```ts
const statuses = parseCsv(q.status);
if (!statuses.length) statuses.push('blocked', 'fail', 'warning');
```

---

If you want the next upgrade after this: **2.2 section labels** (return parent section path for each issue so UI can show `Schema → Keys → FK Not Indexed`).

