3.4 Change Tracking + Audit Trail (writes log, history UI, optional undo)

3.4 is where your SQL GUI becomes “team-safe” and enterprise-ready:

every insert/update/delete is recorded

you can answer “who changed what and when?”

you can roll back simple mistakes


We’ll do 3.4.1 schema, 3.4.2 middleware/hook, 3.4.3 API, 3.4.4 UI, 3.4.5 optional undo.


---

3.4.1 App DB tables (audit log)

db/migrations/020_audit_log.sql

CREATE TABLE IF NOT EXISTS audit_log (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NULL,
  actor_id uuid NULL,
  actor_label text NULL,              -- "nick@..." or "local-dev"
  connection_key text NOT NULL,       -- conn:... or url:[masked]
  schema_name text NOT NULL,
  table_name text NOT NULL,
  action text NOT NULL CHECK (action IN ('INSERT','UPDATE','DELETE')),
  pk jsonb NULL,                      -- {"id": "..."} or composite
  before jsonb NULL,                  -- previous row (for UPDATE/DELETE)
  after jsonb NULL,                   -- new row (for INSERT/UPDATE)
  diff jsonb NULL,                    -- {"col": {"from":x,"to":y}, ...} optional
  statement jsonb NULL,               -- {type:"row/update", payload:{...}} optional
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS audit_log_conn_time
  ON audit_log(connection_key, created_at DESC);

CREATE INDEX IF NOT EXISTS audit_log_table_time
  ON audit_log(schema_name, table_name, created_at DESC);

CREATE INDEX IF NOT EXISTS audit_log_pk
  ON audit_log USING gin (pk);

CREATE INDEX IF NOT EXISTS audit_log_diff
  ON audit_log USING gin (diff);

Why JSONB? Flexible, supports composite PKs, searchable with GIN.


---

3.4.2 Audit writer (used by update/insert/delete routes)

apps/api/src/audit/writeAudit.ts

import { appDb } from '../services/appDb';

function computeDiff(before: any, after: any) {
  if (!before || !after) return null;
  const diff: any = {};
  const keys = new Set([...Object.keys(before), ...Object.keys(after)]);
  for (const k of keys) {
    const a = before[k];
    const b = after[k];
    // simple deep compare for primitives; v1 is fine
    const same = JSON.stringify(a) === JSON.stringify(b);
    if (!same) diff[k] = { from: a ?? null, to: b ?? null };
  }
  return Object.keys(diff).length ? diff : null;
}

export async function writeAudit(args: {
  workspaceId?: string | null;
  actorId?: string | null;
  actorLabel?: string | null;

  connectionKey: string;
  schema: string;
  table: string;

  action: 'INSERT' | 'UPDATE' | 'DELETE';
  pk?: any | null;

  before?: any | null;
  after?: any | null;

  statement?: any | null;
}) {
  const diff = computeDiff(args.before ?? null, args.after ?? null);

  await appDb.query(
    `
    INSERT INTO audit_log (
      workspace_id, actor_id, actor_label,
      connection_key, schema_name, table_name,
      action, pk, before, after, diff, statement
    )
    VALUES ($1,$2,$3,$4,$5,$6,$7,$8::jsonb,$9::jsonb,$10::jsonb,$11::jsonb,$12::jsonb)
    `,
    [
      args.workspaceId ?? null,
      args.actorId ?? null,
      args.actorLabel ?? null,
      args.connectionKey,
      args.schema,
      args.table,
      args.action,
      args.pk ?? null,
      args.before ?? null,
      args.after ?? null,
      diff,
      args.statement ?? null,
    ],
  );

  return { ok: true };
}


---

3.4.3 Wire audit into write endpoints (UPDATE/INSERT/DELETE)

A) UPDATE route patch (capture before, log after)

In /data/row/update:

1. SELECT * WHERE pk... → before


2. run UPDATE RETURNING * → after


3. writeAudit({ action:'UPDATE', pk, before, after })



Patch snippet

const connectionKey = body.connectionId ? `conn:${body.connectionId}` : 'url:[masked]';

// 1) before
const beforeRes = await pool.query(
  `SELECT * FROM ${qident(body.schema)}.${qident(body.table)} WHERE ${whereParts.join(' AND ')} LIMIT 1`,
  whereParams,
);
const before = beforeRes.rows?.[0] ?? null;

// 2) update -> after
const res = await pool.query(updateSql, updateParams);
const after = res.rows?.[0] ?? null;

// 3) audit
await writeAudit({
  connectionKey,
  schema: body.schema,
  table: body.table,
  action: 'UPDATE',
  pk: body.pk,
  before,
  after,
  statement: { type: 'row/update', payload: { set: body.set } },
});

B) INSERT route patch

after is the returned row

pk can be extracted if you know PK cols (optional v1: store null pk)


C) DELETE route patch

before is the returned row from DELETE … RETURNING *

after null



---

3.4.4 Audit API (read history)

GET /api/v1/audit

Query params:

connectionKey

schema

table

action

since / until

pk (JSON string) optional


Response:

list of audit rows (paged)


apps/api/src/routes/audit.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { appDb } from '../services/appDb';

export async function auditRoutes(app: FastifyInstance) {
  app.get('/api/v1/audit', async (req) => {
    const Q = z.object({
      connectionKey: z.string().min(3).optional(),
      schema: z.string().optional(),
      table: z.string().optional(),
      action: z.enum(['INSERT','UPDATE','DELETE']).optional(),
      limit: z.coerce.number().int().min(1).max(200).default(50),
      offset: z.coerce.number().int().min(0).default(0),
    });

    const q = Q.parse(req.query ?? {});
    const params: any[] = [];
    const where: string[] = [];

    const add = (cond: string, val: any) => {
      params.push(val);
      where.push(cond.replace('?', `$${params.length}`));
    };

    if (q.connectionKey) add(`connection_key = ?`, q.connectionKey);
    if (q.schema) add(`schema_name = ?`, q.schema);
    if (q.table) add(`table_name = ?`, q.table);
    if (q.action) add(`action = ?`, q.action);

    const sql = `
      SELECT id, actor_label, connection_key, schema_name, table_name, action,
             pk, diff, before, after, created_at
      FROM audit_log
      ${where.length ? `WHERE ${where.join(' AND ')}` : ''}
      ORDER BY created_at DESC
      LIMIT ${q.limit} OFFSET ${q.offset}
    `;

    const res = await appDb.query(sql, params);
    return { rows: res.rows };
  });
}

Wire:

await app.register(auditRoutes);


---

3.4.5 UI: “Recent Changes” panel

Add a tab in the right drawer (or a top-level page):

filters: connection, schema/table, action

list rows:

timestamp

actor label

action

table

“changed fields” chips from diff


click item → opens:

JSON before/after diff viewer

buttons:

“Jump to table”

“Open row” (if pk present)





---

3.4.6 Optional Undo (safe v1)

Undo is safe for UPDATE where:

pk present

before present

table still has that row


Undo endpoint: POST /api/v1/audit/:id/undo

re-apply before values (only columns in diff)

write a new audit row action = UPDATE with actor_label “undo”


I can provide the full undo implementation next if you want.


---

If you say “continue”, I’ll do 3.4.6 Undo endpoint code + UI button wiring.
