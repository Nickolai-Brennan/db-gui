3.3 ERD Graph Builder + Layout Persistence (Minimum to Ship)

Section 3.3 is where the introspection snapshot becomes an interactive ERD with:

✅ nodes (tables/views) + columns

✅ edges (FK relationships)

✅ stable IDs + “relationship-aware anchors”

✅ layout save/load (positions, collapsed state, lane grouping)

✅ incremental merge (for “visible refresh”)


I’m going to define 3.3.1 graph model, 3.3.2 builder, 3.3.3 layout storage, 3.3.4 merge strategy, and the API endpoints.


---

3.3.1 ERD Graph Model (what frontend consumes)

export type ErdGraph = {
  meta: {
    capturedAt: string;
    schemas: string[];
    signature: string;
  };

  nodes: Array<{
    id: string;                // "schema.table"
    key: string;               // same as id
    schema: string;
    name: string;
    kind: 'table' | 'partitioned' | 'view' | 'materialized_view';

    stats?: { rows?: number; bytes?: number };

    columns: Array<{
      id: string;              // "schema.table.column"
      name: string;
      dataType: string;
      isNullable: boolean;
      isPk?: boolean;
      isUnique?: boolean;
      isFk?: boolean;
      default?: string | null;
    }>;
  }>;

  edges: Array<{
    id: string;                // relationship key signature
    key: string;               // same as id
    name?: string;
    from: string;              // child table key: "schema.table"
    to: string;                // parent table key: "schema.table"
    fromCols: string[];
    toCols: string[];
    onUpdate?: string;
    onDelete?: string;
    deferrable?: boolean;
    initiallyDeferred?: boolean;
  }>;
};

Critical: node.id and edge.id must match:

table key: schema.table

relationship key: childKey(cols) -> parentKey(cols)


That’s what your Issues “highlight payload” will target.


---

3.3.2 Graph Builder (snapshot → graph)

apps/api/src/erd/buildGraph.ts

import type { CatalogSnapshot } from '../introspection/types';
import type { ErdGraph } from './types';

export function buildErdGraph(args: {
  snapshot: CatalogSnapshot;
  signature: string;
}): ErdGraph {
  const s = args.snapshot;

  // Precompute PK/unique sets by column
  const pkCols = new Set<string>();
  const uniqueCols = new Set<string>();

  for (const pk of Object.values(s.constraints.pks)) {
    for (const c of pk.columns) pkCols.add(`${pk.tableKey}.${c}`);
  }
  for (const uq of Object.values(s.constraints.uniques)) {
    for (const c of uq.columns) uniqueCols.add(`${uq.tableKey}.${c}`);
  }

  // FK columns
  const fkCols = new Set<string>();
  for (const rel of Object.values(s.relationships)) {
    for (const c of rel.childCols) fkCols.add(`${rel.childKey}.${c}`);
  }

  // Build nodes
  const nodes: ErdGraph['nodes'] = [];
  for (const t of Object.values(s.tables)) {
    const tableKey = t.key;

    // gather columns for table
    const cols = Object.values(s.columns).filter((c) => c.tableKey === tableKey);

    nodes.push({
      id: tableKey,
      key: tableKey,
      schema: t.schema,
      name: t.name,
      kind: t.kind,
      stats: { rows: t.rowEstimate, bytes: t.totalBytes },
      columns: cols.map((c) => {
        const colKey = `${c.tableKey}.${c.name}`;
        return {
          id: `${c.schema}.${c.table}.${c.name}`,
          name: c.name,
          dataType: c.dataType,
          isNullable: c.isNullable,
          default: c.default ?? null,
          isPk: pkCols.has(colKey),
          isUnique: uniqueCols.has(colKey),
          isFk: fkCols.has(colKey),
        };
      }),
    });
  }

  // Build edges
  const edges: ErdGraph['edges'] = Object.values(s.relationships).map((r) => ({
    id: r.key,
    key: r.key,
    name: r.name,
    from: r.childKey,
    to: r.parentKey,
    fromCols: r.childCols,
    toCols: r.parentCols,
    onUpdate: r.onUpdate,
    onDelete: r.onDelete,
    deferrable: r.deferrable,
    initiallyDeferred: r.initiallyDeferred,
  }));

  return {
    meta: {
      capturedAt: s.meta.capturedAt,
      schemas: s.meta.schemas,
      signature: args.signature,
    },
    nodes,
    edges,
  };
}


---

3.3.3 Layout Persistence (positions, collapsed, schema lanes)

You want layout saved per:

workspace

connection

schema scope

and optionally per “diagram id”


App DB table

db/migrations/010_erd_layouts.sql

CREATE TABLE IF NOT EXISTS erd_layouts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NULL,
  connection_key text NOT NULL,
  schemas text[] NOT NULL,
  signature text NULL, -- signature layout was built against
  layout jsonb NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS erd_layouts_unique
  ON erd_layouts(connection_key, schemas);

Layout JSON shape (what frontend stores)

export type ErdLayout = {
  nodes: Record<string, { x: number; y: number; collapsed?: boolean; lane?: string }>;
  viewport?: { x: number; y: number; zoom: number };
  lanes?: Record<string, { x: number; width: number }>; // schema lanes optional
  updatedAt: string;
};


---

3.3.4 Layout endpoints

GET layout

GET /api/v1/erd/layout?connectionKey=...&schemas=public,foo

PUT layout

PUT /api/v1/erd/layout Body:

{
  "workspaceId": null,
  "connectionKey": "conn:uuid-or-url:...",
  "schemas": ["public"],
  "signature": "sha256...",
  "layout": { "nodes": { "public.users": { "x": 120, "y": 80 } } }
}

apps/api/src/routes/erdLayout.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { appDb } from '../services/appDb';

function normalizeSchemas(s: string[]) {
  return s.slice().map(x => x.trim()).filter(Boolean).sort();
}

export async function erdLayoutRoutes(app: FastifyInstance) {
  // GET
  app.get('/api/v1/erd/layout', async (req) => {
    const Q = z.object({
      connectionKey: z.string().min(3),
      schemas: z.string().min(1) // csv
    });
    const q = Q.parse(req.query ?? {});
    const schemas = normalizeSchemas(q.schemas.split(','));

    const res = await appDb.query(
      `
      SELECT layout, signature, updated_at
      FROM erd_layouts
      WHERE connection_key = $1 AND schemas = $2::text[]
      LIMIT 1
      `,
      [q.connectionKey, schemas],
    );

    if (!res.rows?.length) return { layout: null };

    return {
      layout: res.rows[0].layout,
      signature: res.rows[0].signature,
      updatedAt: new Date(res.rows[0].updated_at).toISOString(),
    };
  });

  // PUT
  app.put('/api/v1/erd/layout', async (req) => {
    const Body = z.object({
      workspaceId: z.string().uuid().nullable().optional(),
      connectionKey: z.string().min(3),
      schemas: z.array(z.string().min(1)).min(1),
      signature: z.string().nullable().optional(),
      layout: z.any()
    });
    const body = Body.parse(req.body);
    const schemas = normalizeSchemas(body.schemas);

    await appDb.query(
      `
      INSERT INTO erd_layouts (workspace_id, connection_key, schemas, signature, layout, updated_at)
      VALUES ($1, $2, $3::text[], $4, $5::jsonb, now())
      ON CONFLICT (connection_key, schemas)
      DO UPDATE SET
        workspace_id = EXCLUDED.workspace_id,
        signature = EXCLUDED.signature,
        layout = EXCLUDED.layout,
        updated_at = now()
      `,
      [body.workspaceId ?? null, body.connectionKey, schemas, body.signature ?? null, body.layout],
    );

    return { ok: true };
  });
}

Wire:

import { erdLayoutRoutes } from './routes/erdLayout';
await app.register(erdLayoutRoutes);


---

3.3.5 Graph endpoint (snapshot → graph)

You can either:

build graph on backend (recommended v1) and send to UI

or send snapshot and build graph in frontend


Backend endpoint:

POST /api/v1/erd/graph Body:

{
  "targetDatabaseUrl":"postgresql://...",
  "schemas":["public"],
  "refresh":"cache|force|visible",
  "visibleTables":["public.users"]
}

Response:

graph

layout (if exists)

lastRefreshedAt

drift (optional)


This simply composes your existing /snapshot + buildErdGraph() + layout GET.


---

3.3.6 Incremental merge strategy (for visible refresh)

When refresh=visible:

backend returns partial snapshot/graph

frontend merges:

node exists → replace its column list / stats

edges: replace any edge touching a visible table



Key mechanism:

treat node.id as primary key

treat edge.id (relationship signature) as primary key



---

What I’d do next (if you say “continue”)

3.3.7 ERD Graph endpoint code (full route that returns graph + layout + drift)
and a recommended frontend store shape for fast canvas lookups.

3.3.7 ERD Graph endpoint (graph + layout + drift) — full code

This endpoint is the one call your frontend ERD screen can make to get everything it needs:

✅ snapshot (cached/force/visible)
✅ signature + drift info
✅ graph (nodes + edges)
✅ saved layout (positions/collapsed/viewport)
✅ last refreshed timestamp


---

1) Route: POST /api/v1/erd/graph

Request body

{
  "workspaceId": null,
  "connectionId": null,
  "targetDatabaseUrl": "postgresql://…",
  "schemas": ["public"],
  "refresh": "cache|force|visible",
  "visibleTables": ["public.users","public.orders"]
}

Response body

{
  "graph": { "meta": {}, "nodes": [], "edges": [] },
  "layout": { "nodes": {}, "viewport": {} } | null,
  "signature": "sha256...",
  "drift": { "changedSinceLast": false, "previousSignature": "...", "currentSignature": "..." },
  "lastRefreshedAt": "ISO",
  "cache": { "hit": true, "source": "mem|db|fresh" }
}


---

2) Code: ERD graph route

apps/api/src/routes/erdGraph.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';

import { createTargetPool } from '../targetDb';
import { appDb } from '../services/appDb';

import { fetchCatalogSnapshot } from '../introspection/snapshot';
import { fetchCatalogSnapshotVisible } from '../introspection/snapshotVisible';
import { parseVisibleTables } from '../introspection/visible';

import { computeSnapshotSignature } from '../introspection/signature';
import { loadLatestSnapshot, saveSnapshot } from '../introspection/persist';
import { getMem, setMem } from '../introspection/cache';

import { buildErdGraph } from '../erd/buildGraph';

function normalizeSchemas(schemas: string[]) {
  return schemas.slice().map(s => s.trim()).filter(Boolean).sort();
}

function makeConnectionKey(body: { connectionId?: string; targetDatabaseUrl: string }) {
  return body.connectionId ? `conn:${body.connectionId}` : `url:${body.targetDatabaseUrl}`;
}

function makeCacheKey(connectionKey: string, schemas: string[], mode: 'full'|'partial') {
  return `${connectionKey}::schemas:${schemas.join(',')}::mode:${mode}`;
}

async function loadLayout(connectionKey: string, schemas: string[]) {
  const res = await appDb.query(
    `
    SELECT layout, signature, updated_at
    FROM erd_layouts
    WHERE connection_key = $1 AND schemas = $2::text[]
    LIMIT 1
    `,
    [connectionKey, schemas],
  );
  if (!res.rows?.length) return null;
  return {
    layout: res.rows[0].layout,
    layoutSignature: res.rows[0].signature,
    layoutUpdatedAt: new Date(res.rows[0].updated_at).toISOString(),
  };
}

export async function erdGraphRoutes(app: FastifyInstance) {
  app.post('/api/v1/erd/graph', async (req) => {
    const Body = z.object({
      workspaceId: z.string().uuid().nullable().optional(),
      connectionId: z.string().uuid().optional(),

      // v1 dev
      targetDatabaseUrl: z.string().min(10),

      schemas: z.array(z.string().min(1)).min(1),
      refresh: z.enum(['cache', 'force', 'visible']).default('cache'),
      visibleTables: z.array(z.string().min(3)).optional(),
    });

    const body = Body.parse(req.body);
    const schemas = normalizeSchemas(body.schemas);
    const connectionKey = makeConnectionKey(body);

    const memTtlMs = 60_000;        // memory cache
    const dbMaxAgeMs = 10 * 60_000; // persisted snapshot freshness (v1)

    const mode: 'full'|'partial' = body.refresh === 'visible' ? 'partial' : 'full';
    const cacheKey = makeCacheKey(connectionKey, schemas, mode);

    // 0) Load layout (always; layout is cheap)
    const layout = await loadLayout(connectionKey, schemas);

    // 1) Memory snapshot cache
    if (body.refresh === 'cache') {
      const hit = getMem(cacheKey);
      if (hit) {
        const graph = buildErdGraph({ snapshot: hit.snapshot, signature: hit.signature });
        return {
          graph,
          layout: layout?.layout ?? null,
          signature: hit.signature,
          drift: { changedSinceLast: false, previousSignature: hit.signature, currentSignature: hit.signature },
          lastRefreshedAt: hit.snapshot.meta.capturedAt,
          cache: { hit: true, source: 'mem', key: cacheKey, ttlMs: memTtlMs },
        };
      }
    }

    // 2) Persisted snapshot cache (only for FULL mode)
    // NOTE: we intentionally do NOT persist partial snapshots (visible mode) in v1.
    if (body.refresh === 'cache' && mode === 'full') {
      const latest = await loadLatestSnapshot({ appDb, connectionKey, schemas });
      if (latest) {
        const age = Date.now() - new Date(latest.capturedAt).getTime();
        if (age <= dbMaxAgeMs) {
          setMem(cacheKey, latest.snapshot, latest.signature, memTtlMs);
          const graph = buildErdGraph({ snapshot: latest.snapshot, signature: latest.signature });
          return {
            graph,
            layout: layout?.layout ?? null,
            signature: latest.signature,
            drift: { changedSinceLast: false, previousSignature: latest.signature, currentSignature: latest.signature },
            lastRefreshedAt: latest.capturedAt,
            cache: { hit: true, source: 'db', key: cacheKey, maxAgeMs: dbMaxAgeMs },
          };
        }
      }
    }

    // 3) Fresh introspection (force / visible / expired)
    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      // Compare against latest persisted for drift (full mode only)
      const prev = mode === 'full'
        ? await loadLatestSnapshot({ appDb, connectionKey, schemas })
        : await loadLatestSnapshot({ appDb, connectionKey, schemas }); // still useful for drift messaging

      let snapshot: any;
      let signature: string;

      if (body.refresh === 'visible') {
        const visible = parseVisibleTables(body.visibleTables);
        const res = await fetchCatalogSnapshotVisible(pool, schemas, visible);
        snapshot = res.snapshot;
        signature = res.signature;
      } else {
        snapshot = await fetchCatalogSnapshot(pool, schemas);
        signature = computeSnapshotSignature(snapshot);
      }

      // drift info
      const prevSig = prev?.signature ?? null;
      const changedSinceLast = prevSig ? prevSig !== signature : false;

      // persist only FULL snapshots
      if (mode === 'full') {
        await saveSnapshot({
          appDb,
          workspaceId: body.workspaceId ?? null,
          connectionKey,
          schemas,
          snapshot,
          signature,
        });
      }

      // memory cache
      setMem(cacheKey, snapshot, signature, memTtlMs);

      const graph = buildErdGraph({ snapshot, signature });

      return {
        graph,
        layout: layout?.layout ?? null,
        signature,
        drift: { changedSinceLast, previousSignature: prevSig, currentSignature: signature },
        lastRefreshedAt: snapshot.meta.capturedAt,
        cache: { hit: false, source: 'fresh', key: cacheKey },
      };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}

Wire in apps/api/src/index.ts:

import { erdGraphRoutes } from './routes/erdGraph';
await app.register(erdGraphRoutes);


---

3) Frontend store shape (fast ERD lookups)

Use maps for O(1) canvas operations:

type ErdStore = {
  signature: string | null;
  nodesById: Map<string, ErdGraph['nodes'][number]>;
  edgesById: Map<string, ErdGraph['edges'][number]>;
  layout: ErdLayout | null;
  highlight: ErdHighlightPayload | null;
};

When you receive graph:

nodesById = new Map(graph.nodes.map(n => [n.id, n]))

edgesById = new Map(graph.edges.map(e => [e.id, e]))



---

4) What I recommend next (to begin real UI dev)

3.3.8 “layout merge + auto-place new nodes”
When diff says “tables added”, you:

auto-place new nodes in a “New” lane

keep existing positions unchanged

mark layout dirty so user can save


If you want that, say: “3.3.8 auto-place algorithm”.

3.3.8 Auto-place algorithm + Layout merge (new tables, removed tables, edge changes)

This is the “don’t ruin my diagram” feature.

When schema changes:

✅ keep existing node positions

✅ remove deleted nodes cleanly

✅ auto-place new nodes in a predictable lane

✅ optionally reflow only the new nodes

✅ preserve collapsed state + viewport

✅ keep edges purely derived from graph (no need to store)



---

A) Layout merge rules (authoritative)

Given:

graph.nodes[] (truth)

layout.nodes{} (saved positions)


Merge rules

1. Existing node in layout + still in graph → keep {x,y,collapsed,lane}


2. Node removed from graph → delete from layout


3. Node new in graph → auto-place it:

lane = schema lane (or "__new__")

position = next available slot in that lane grid



4. Viewport:

keep viewport if present

optional: if first-time layout (empty), center on densest schema lane





---

B) Layout model (same as before)

export type ErdLayout = {
  nodes: Record<string, { x: number; y: number; collapsed?: boolean; lane?: string }>;
  viewport?: { x: number; y: number; zoom: number };
  lanes?: Record<string, { x: number; width: number }>;
  updatedAt: string;
};


---

C) Auto-place strategy (simple, consistent grid)

Parameters (v1 sensible defaults)

Node card width: W = 320

Node card height: H = 180 (collapsed) or H = 360 (expanded)

Grid spacing: GX = 60, GY = 60

Per-lane X origin: computed from layout.lanes[schema].x else assign sequential lanes


Placement

For a lane:

place nodes in rows of colsPerRow = 3 (configurable)

next position index = count existing nodes in lane

x = laneX + (index % colsPerRow) * (W + GX)

y = laneTop + floor(index / colsPerRow) * (H + GY)



---

D) Implementation (frontend or backend)

This algorithm is best implemented frontend-side (instant, no API round trip).
But I’ll give you pure TS that works anywhere.

apps/web/src/erd/layoutMerge.ts (or packages/shared)

type LayoutNode = { x: number; y: number; collapsed?: boolean; lane?: string };
type ErdLayout = {
  nodes: Record<string, LayoutNode>;
  viewport?: { x: number; y: number; zoom: number };
  lanes?: Record<string, { x: number; width: number }>;
  updatedAt: string;
};

type ErdNode = { id: string; schema: string; kind: string; columns: any[] };

type MergeOptions = {
  // geometry
  nodeW?: number;
  nodeHCollapsed?: number;
  nodeHExpanded?: number;
  gapX?: number;
  gapY?: number;
  colsPerRow?: number;

  // lane settings
  laneWidth?: number;
  laneGap?: number;
  laneTop?: number;

  // new nodes policy
  newNodesLane?: 'schema' | '__new__';
  placeStartX?: number;
};

function nowIso() {
  return new Date().toISOString();
}

function ensureLanes(layout: ErdLayout, schemas: string[], opts: Required<MergeOptions>) {
  layout.lanes ??= {};

  const laneWidth = opts.laneWidth;
  const laneGap = opts.laneGap;
  const startX = opts.placeStartX;

  // preserve existing lane X positions
  // assign missing lanes in stable order
  const existing = Object.keys(layout.lanes);
  const used = new Set(existing);

  // compute nextX based on rightmost lane
  let nextX = startX;
  for (const l of existing) {
    const lx = layout.lanes[l]?.x ?? nextX;
    nextX = Math.max(nextX, lx + laneWidth + laneGap);
  }

  for (const s of schemas) {
    if (used.has(s)) continue;
    layout.lanes[s] = { x: nextX, width: laneWidth };
    nextX += laneWidth + laneGap;
  }

  // ensure "__new__" lane exists if used
  if (!used.has('__new__')) {
    layout.lanes['__new__'] ??= { x: nextX, width: laneWidth };
  }
}

function countNodesInLane(layout: ErdLayout, lane: string) {
  let n = 0;
  for (const v of Object.values(layout.nodes)) if ((v.lane ?? '') === lane) n++;
  return n;
}

function nextGridPosition(args: {
  laneX: number;
  laneTop: number;
  index: number;
  opts: Required<MergeOptions>;
  collapsed: boolean;
}) {
  const { laneX, laneTop, index, opts, collapsed } = args;

  const W = opts.nodeW;
  const H = collapsed ? opts.nodeHCollapsed : opts.nodeHExpanded;
  const x = laneX + (index % opts.colsPerRow) * (W + opts.gapX);
  const y = laneTop + Math.floor(index / opts.colsPerRow) * (H + opts.gapY);
  return { x, y };
}

export function mergeLayoutWithGraph(args: {
  graphNodes: ErdNode[];
  layout: ErdLayout | null;
  options?: MergeOptions;
}) {
  const opts: Required<MergeOptions> = {
    nodeW: args.options?.nodeW ?? 320,
    nodeHCollapsed: args.options?.nodeHCollapsed ?? 180,
    nodeHExpanded: args.options?.nodeHExpanded ?? 360,
    gapX: args.options?.gapX ?? 60,
    gapY: args.options?.gapY ?? 60,
    colsPerRow: args.options?.colsPerRow ?? 3,

    laneWidth: args.options?.laneWidth ?? 1200,
    laneGap: args.options?.laneGap ?? 200,
    laneTop: args.options?.laneTop ?? 80,
    newNodesLane: args.options?.newNodesLane ?? 'schema',
    placeStartX: args.options?.placeStartX ?? 80,
  };

  const graphById = new Map(args.graphNodes.map(n => [n.id, n]));
  const schemas = Array.from(new Set(args.graphNodes.map(n => n.schema))).sort();

  // Initialize layout if missing
  const layout: ErdLayout = args.layout ?? { nodes: {}, lanes: {}, updatedAt: nowIso() };

  // Ensure lane map exists (schema lanes + __new__)
  ensureLanes(layout, schemas, opts);

  // 1) Remove nodes not in graph
  for (const nodeId of Object.keys(layout.nodes)) {
    if (!graphById.has(nodeId)) delete layout.nodes[nodeId];
  }

  // 2) Add nodes missing from layout
  const added: string[] = [];
  for (const n of args.graphNodes) {
    if (layout.nodes[n.id]) continue;

    const lane =
      opts.newNodesLane === '__new__'
        ? '__new__'
        : (n.schema || '__new__');

    const laneX = layout.lanes?.[lane]?.x ?? opts.placeStartX;
    const index = countNodesInLane(layout, lane);

    // default: expanded tables, collapsed views (or vice versa; you decide)
    const defaultCollapsed = n.kind === 'view' || n.kind === 'materialized_view';

    const pos = nextGridPosition({
      laneX,
      laneTop: opts.laneTop,
      index,
      opts,
      collapsed: defaultCollapsed,
    });

    layout.nodes[n.id] = { ...pos, collapsed: defaultCollapsed, lane };
    added.push(n.id);
  }

  // 3) Optional: repair nodes with missing lanes
  for (const [id, ln] of Object.entries(layout.nodes)) {
    if (!ln.lane) {
      const node = graphById.get(id);
      ln.lane = node?.schema ?? '__new__';
    }
    if (layout.lanes && ln.lane && !layout.lanes[ln.lane]) {
      // fallback lane if unknown
      layout.lanes[ln.lane] = { x: opts.placeStartX, width: opts.laneWidth };
    }
  }

  layout.updatedAt = nowIso();

  return { layout, added };
}


---

E) How to use it in the ERD screen

On ERD load:

1. call POST /api/v1/erd/graph


2. take graph + layout (maybe null)


3. run mergeLayoutWithGraph({ graphNodes: graph.nodes, layout })


4. render using returned merged layout


5. if any added.length > 0, show toast: “New tables placed in diagram”



When user moves nodes:

update local layout state

debounce save via PUT /api/v1/erd/layout



---

F) Bonus: “New lane” vs “Schema lane”

Two good modes:

schema lanes (default): new tables appear in their schema lane

new lane: new tables appear in a dedicated “New tables” lane until user drags them out


Switch via newNodesLane option.


---

3.3.9
3.3.9 Jump-to-focus pan/zoom (table + relationship midpoint) + highlight application

This is the missing glue between:

Issues Drawer → highlight.payload

ERD canvas → “go to that thing and glow”


You’ll get:

✅ getFocusPoint() for table or relationship

✅ applyHighlight() helper (primary/secondary sets)

✅ smooth pan/zoom animation targets (framework-agnostic)


> Assumes your layout stores node positions and your canvas uses a viewport {x,y,zoom}.




---

A) Types (frontend)

type Viewport = { x: number; y: number; zoom: number };
type LayoutNode = { x: number; y: number; collapsed?: boolean; lane?: string };

type ErdLayout = {
  nodes: Record<string, LayoutNode>;
  viewport?: Viewport;
};

type ErdNode = { id: string; kind: string; columns: any[] };
type ErdEdge = { id: string; from: string; to: string };

type ErdHighlightPayload = {
  focus: { type: 'table' | 'relationship' | 'none'; key: string | null };
  tables: Array<{ key: string; emphasis: 'primary' | 'secondary' }>;
  columns: Array<{ key: string; emphasis: 'primary' | 'secondary' }>;
  relationships: Array<{ key: string; emphasis: 'primary' | 'secondary' }>;
  message?: string;
};


---

B) Geometry helpers

We need an approximate node box size. In v1 you can treat all nodes as same width and height; collapsed nodes shorter.

apps/web/src/erd/focus.ts

export function nodeDims(args: { collapsed?: boolean }) {
  const W = 320;
  const H = args.collapsed ? 180 : 360;
  return { W, H };
}

export function nodeCenter(layoutNode: { x: number; y: number; collapsed?: boolean }) {
  const { W, H } = nodeDims({ collapsed: layoutNode.collapsed });
  return { cx: layoutNode.x + W / 2, cy: layoutNode.y + H / 2 };
}

export function edgeMidpoint(args: {
  fromNode: { x: number; y: number; collapsed?: boolean };
  toNode: { x: number; y: number; collapsed?: boolean };
}) {
  const a = nodeCenter(args.fromNode);
  const b = nodeCenter(args.toNode);
  return { cx: (a.cx + b.cx) / 2, cy: (a.cy + b.cy) / 2 };
}


---

C) Focus resolution (table or relationship)

apps/web/src/erd/getFocusPoint.ts

import { nodeCenter, edgeMidpoint } from './focus';

export function getFocusPoint(args: {
  highlight: { focus: { type: 'table'|'relationship'|'none'; key: string|null } };
  layout: { nodes: Record<string, { x: number; y: number; collapsed?: boolean }> };
  edgesById: Map<string, { id: string; from: string; to: string }>;
}) {
  const { type, key } = args.highlight.focus;
  if (!key || type === 'none') return null;

  if (type === 'table') {
    const ln = args.layout.nodes[key];
    if (!ln) return null;
    const { cx, cy } = nodeCenter(ln);
    return { x: cx, y: cy };
  }

  if (type === 'relationship') {
    const e = args.edgesById.get(key);
    if (!e) return null;
    const from = args.layout.nodes[e.from];
    const to = args.layout.nodes[e.to];
    if (!from || !to) return null;

    const { cx, cy } = edgeMidpoint({ fromNode: from, toNode: to });
    return { x: cx, y: cy };
  }

  return null;
}


---

D) Convert focus point → target viewport (pan/zoom)

This is canvas-implementation dependent, but here’s the standard math if your viewport is “world → screen”:

Screen coord = (worldX * zoom + x, worldY * zoom + y)

To center on world point (px,py):

set x = screenCenterX - px*zoom

set y = screenCenterY - py*zoom



apps/web/src/erd/viewport.ts

type Viewport = { x: number; y: number; zoom: number };

export function viewportToCenterOn(args: {
  point: { x: number; y: number };
  current: Viewport;
  screen: { w: number; h: number };
  zoom?: number; // optional override
}) {
  const zoom = args.zoom ?? args.current.zoom;
  const x = args.screen.w / 2 - args.point.x * zoom;
  const y = args.screen.h / 2 - args.point.y * zoom;
  return { x, y, zoom };
}


---

E) Smooth animation (simple easing)

apps/web/src/erd/animateViewport.ts

type Viewport = { x: number; y: number; zoom: number };

export function animateViewport(args: {
  from: Viewport;
  to: Viewport;
  durationMs?: number;
  onUpdate: (v: Viewport) => void;
  onDone?: () => void;
}) {
  const duration = args.durationMs ?? 350;
  const start = performance.now();

  const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3);

  function tick(now: number) {
    const t = Math.min(1, (now - start) / duration);
    const e = easeOutCubic(t);

    const v = {
      x: args.from.x + (args.to.x - args.from.x) * e,
      y: args.from.y + (args.to.y - args.from.y) * e,
      zoom: args.from.zoom + (args.to.zoom - args.from.zoom) * e,
    };

    args.onUpdate(v);

    if (t < 1) requestAnimationFrame(tick);
    else args.onDone?.();
  }

  requestAnimationFrame(tick);
}


---

F) Highlight sets (primary/secondary lookup)

This makes rendering fast (no array scans each frame).

apps/web/src/erd/highlightSets.ts

export function buildHighlightSets(h: {
  tables: Array<{ key: string; emphasis: 'primary'|'secondary' }>;
  columns: Array<{ key: string; emphasis: 'primary'|'secondary' }>;
  relationships: Array<{ key: string; emphasis: 'primary'|'secondary' }>;
}) {
  const tPrimary = new Set<string>();
  const tSecondary = new Set<string>();
  const cPrimary = new Set<string>();
  const cSecondary = new Set<string>();
  const rPrimary = new Set<string>();
  const rSecondary = new Set<string>();

  for (const x of h.tables) (x.emphasis === 'primary' ? tPrimary : tSecondary).add(x.key);
  for (const x of h.columns) (x.emphasis === 'primary' ? cPrimary : cSecondary).add(x.key);
  for (const x of h.relationships) (x.emphasis === 'primary' ? rPrimary : rSecondary).add(x.key);

  return { tPrimary, tSecondary, cPrimary, cSecondary, rPrimary, rSecondary };
}


---

G) One orchestrator: “jump + glow”

apps/web/src/erd/jumpToHighlight.ts

import { getFocusPoint } from './getFocusPoint';
import { viewportToCenterOn } from './viewport';
import { animateViewport } from './animateViewport';

export function jumpToHighlight(args: {
  highlight: any;
  layout: any;
  edgesById: Map<string, any>;
  viewport: { x: number; y: number; zoom: number };
  screen: { w: number; h: number };

  setViewport: (v: { x: number; y: number; zoom: number }) => void;
  preferredZoom?: number;
}) {
  const pt = getFocusPoint({
    highlight: args.highlight,
    layout: args.layout,
    edgesById: args.edgesById,
  });

  if (!pt) return false;

  const target = viewportToCenterOn({
    point: pt,
    current: args.viewport,
    screen: args.screen,
    zoom: args.preferredZoom ?? Math.max(args.viewport.zoom, 0.9),
  });

  animateViewport({
    from: args.viewport,
    to: target,
    onUpdate: args.setViewport,
  });

  return true;
}


---

How to use (UI flow)

When user clicks an issue row:

1. set erdStore.highlight = issue.highlight


2. call jumpToHighlight(...)


3. your render uses buildHighlightSets() to apply CSS classes:

table card: primary glow / secondary outline

relationship edge: thicker stroke / glow

columns: highlight row in column list





---


3.3.10 Edge routing + anchors (so relationship lines attach to the correct side and don’t look like spaghetti).

3.3.10 Edge routing + anchors (clean ERD lines, less spaghetti)

This is the “it feels like a real ERD tool” upgrade.

You’ll implement:

✅ side anchors (left/right/top/bottom) based on relative node positions

✅ orthogonal routing (Manhattan paths) with 1–2 bends

✅ edge dedup offsets (parallel edges don’t overlap)

✅ relationship-aware anchors (when highlighted, edge pulses)


This is framework-agnostic; you can use it with Canvas, SVG, React Flow, or your own renderer.


---

A) Anchor selection (which side to attach)

Given two node rectangles A and B:

compute vector from A center → B center

if |dx| > |dy|: use left/right anchors

else: use top/bottom anchors


apps/web/src/erd/edgeAnchors.ts

type Rect = { x: number; y: number; w: number; h: number };
type Point = { x: number; y: number };

export type AnchorSide = 'left' | 'right' | 'top' | 'bottom';

export function rectCenter(r: Rect) {
  return { x: r.x + r.w / 2, y: r.y + r.h / 2 };
}

export function pickAnchorSides(a: Rect, b: Rect): { from: AnchorSide; to: AnchorSide } {
  const ac = rectCenter(a);
  const bc = rectCenter(b);
  const dx = bc.x - ac.x;
  const dy = bc.y - ac.y;

  if (Math.abs(dx) >= Math.abs(dy)) {
    // horizontal dominance
    return dx >= 0 ? { from: 'right', to: 'left' } : { from: 'left', to: 'right' };
  }

  // vertical dominance
  return dy >= 0 ? { from: 'bottom', to: 'top' } : { from: 'top', to: 'bottom' };
}

export function anchorPoint(r: Rect, side: AnchorSide, pad = 8): Point {
  switch (side) {
    case 'left': return { x: r.x - pad, y: r.y + r.h / 2 };
    case 'right': return { x: r.x + r.w + pad, y: r.y + r.h / 2 };
    case 'top': return { x: r.x + r.w / 2, y: r.y - pad };
    case 'bottom': return { x: r.x + r.w / 2, y: r.y + r.h + pad };
  }
}


---

B) Orthogonal routing (simple Manhattan path)

We’ll output a polyline: [p0, p1, p2, p3] with at most 2 bends.

Routing rules:

If from is left/right: go horizontal out, then vertical, then horizontal into target

If from is top/bottom: go vertical out, then horizontal, then vertical in


apps/web/src/erd/edgeRoute.ts

import { anchorPoint, pickAnchorSides, type AnchorSide } from './edgeAnchors';

type Rect = { x: number; y: number; w: number; h: number };
type Point = { x: number; y: number };

function offsetPoint(p: Point, side: AnchorSide, dist: number): Point {
  if (side === 'left') return { x: p.x - dist, y: p.y };
  if (side === 'right') return { x: p.x + dist, y: p.y };
  if (side === 'top') return { x: p.x, y: p.y - dist };
  return { x: p.x, y: p.y + dist }; // bottom
}

export function routeOrthogonal(args: {
  fromRect: Rect;
  toRect: Rect;
  pad?: number;        // anchor pad
  stub?: number;       // out-of-node stub length
  parallelOffset?: number; // for multi-edges
}): Point[] {
  const pad = args.pad ?? 8;
  const stub = args.stub ?? 28;
  const po = args.parallelOffset ?? 0;

  const sides = pickAnchorSides(args.fromRect, args.toRect);
  const p0 = anchorPoint(args.fromRect, sides.from, pad);
  const p3 = anchorPoint(args.toRect, sides.to, pad);

  // apply parallel offset as a small perpendicular nudge
  const nudge = (p: Point, side: AnchorSide, amt: number) => {
    if (amt === 0) return p;
    // perpendicular direction
    if (side === 'left' || side === 'right') return { x: p.x, y: p.y + amt };
    return { x: p.x + amt, y: p.y };
  };

  const a0 = nudge(p0, sides.from, po);
  const a3 = nudge(p3, sides.to, po);

  const s0 = offsetPoint(a0, sides.from, stub);
  const s3 = offsetPoint(a3, sides.to, stub);

  // 2-bend path
  // Choose a mid point that aligns with s0 and s3
  let p1: Point;
  let p2: Point;

  if (sides.from === 'left' || sides.from === 'right') {
    // horizontal first, then vertical, then horizontal
    const midX = (s0.x + s3.x) / 2;
    p1 = { x: midX, y: s0.y };
    p2 = { x: midX, y: s3.y };
  } else {
    // vertical first, then horizontal, then vertical
    const midY = (s0.y + s3.y) / 2;
    p1 = { x: s0.x, y: midY };
    p2 = { x: s3.x, y: midY };
  }

  return [a0, s0, p1, p2, s3, a3];
}


---

C) Multi-edge “parallel offsets” (avoid overlap)

If multiple relationships connect the same two tables, give them offsets:

-18, 0, +18, +36, ...


apps/web/src/erd/edgeOffsets.ts

export function computeParallelOffset(index: number) {
  if (index === 0) return 0;
  const step = 18;
  // order: -1, +1, -2, +2...
  const k = Math.ceil(index / 2);
  return (index % 2 === 1 ? -k : k) * step;
}

export function groupEdgesByPair(edges: Array<{ id: string; from: string; to: string }>) {
  const map = new Map<string, Array<{ id: string; from: string; to: string }>>();
  for (const e of edges) {
    const a = e.from < e.to ? e.from : e.to;
    const b = e.from < e.to ? e.to : e.from;
    const key = `${a}__${b}`;
    if (!map.has(key)) map.set(key, []);
    map.get(key)!.push(e);
  }
  return map;
}

Usage in render:

group edges by pair

for each edge in group, compute offset using its index



---

D) Convert route points to SVG path (quick helper)

apps/web/src/erd/svgPath.ts

type Point = { x: number; y: number };

export function polylineToPath(points: Point[]) {
  if (!points.length) return '';
  const [p0, ...rest] = points;
  return `M ${p0.x} ${p0.y} ` + rest.map(p => `L ${p.x} ${p.y}`).join(' ');
}


---

E) Putting it together (pseudo-render loop)

You’ll need:

node rects derived from layout positions + dims

edges list from graph.edges


Pseudo:

const pairGroups = groupEdgesByPair(graph.edges);

for (const [pairKey, group] of pairGroups) {
  group.forEach((e, idx) => {
    const fromRect = rectForNode(e.from);
    const toRect = rectForNode(e.to);

    const offset = computeParallelOffset(idx);
    const pts = routeOrthogonal({ fromRect, toRect, parallelOffset: offset });
    const d = polylineToPath(pts);

    // if highlighted: thicker stroke/glow
    drawPath(d, isPrimaryEdge(e.id), isSecondaryEdge(e.id));
  });
}


---

F) Relationship-aware anchors (ties to your highlight payload)

Because edge.id === relationship.key, your highlight sets can do:

rPrimary.has(edge.id) → glow/pulse


No extra mapping needed.


---
3.3.11

3.3.11 Collision avoidance (light) for auto-place + drag “snap” (optional)

This keeps your auto-placed nodes from landing on top of existing nodes, without doing heavy graph layout math.

You’ll implement:

✅ grid occupancy (fast)

✅ find next free slot in a lane (spiral/row scan)

✅ optional snap-to-grid on drag end



---

A) Concept

Treat the canvas as a grid of “cells” sized to your node footprint + gaps:

cell width  = nodeW + gapX

cell height = nodeH + gapY


Each node occupies 1 cell (good enough for v1).
When placing a new node, find the first unoccupied cell in its lane.


---

B) Code: occupancy + next free slot

apps/web/src/erd/collision.ts

type LayoutNode = { x: number; y: number; collapsed?: boolean; lane?: string };
type ErdLayout = { nodes: Record<string, LayoutNode>; lanes?: Record<string, { x: number; width: number }> };

type GridCfg = {
  nodeW: number;
  nodeHCollapsed: number;
  nodeHExpanded: number;
  gapX: number;
  gapY: number;
  laneTop: number;
  colsPerRow: number; // lane local grid (recommended 3)
};

function nodeH(n: LayoutNode, cfg: GridCfg) {
  return n.collapsed ? cfg.nodeHCollapsed : cfg.nodeHExpanded;
}

// Convert world x/y -> lane-local grid cell (col,row)
function toCell(args: {
  x: number; y: number;
  laneX: number;
  cfg: GridCfg;
  collapsed: boolean;
}) {
  const cellW = args.cfg.nodeW + args.cfg.gapX;
  const cellH = (args.collapsed ? args.cfg.nodeHCollapsed : args.cfg.nodeHExpanded) + args.cfg.gapY;

  const col = Math.max(0, Math.floor((args.x - args.laneX) / cellW));
  const row = Math.max(0, Math.floor((args.y - args.cfg.laneTop) / cellH));
  return { col, row };
}

// Convert (col,row) -> world x/y for top-left of node
function fromCell(args: {
  col: number; row: number;
  laneX: number;
  cfg: GridCfg;
  collapsed: boolean;
}) {
  const cellW = args.cfg.nodeW + args.cfg.gapX;
  const cellH = (args.collapsed ? args.cfg.nodeHCollapsed : args.cfg.nodeHExpanded) + args.cfg.gapY;

  const x = args.laneX + args.col * cellW;
  const y = args.cfg.laneTop + args.row * cellH;
  return { x, y };
}

// Build occupancy set per lane: "col,row"
export function buildLaneOccupancy(args: {
  layout: ErdLayout;
  lane: string;
  laneX: number;
  cfg: GridCfg;
}) {
  const occ = new Set<string>();

  for (const n of Object.values(args.layout.nodes)) {
    if ((n.lane ?? '') !== args.lane) continue;
    const { col, row } = toCell({ x: n.x, y: n.y, laneX: args.laneX, cfg: args.cfg, collapsed: !!n.collapsed });
    occ.add(`${col},${row}`);
  }
  return occ;
}

// Find first free slot scanning row-major within colsPerRow
export function findNextFreeSlot(args: {
  occupancy: Set<string>;
  cfg: GridCfg;
  startIndex?: number;     // optional start cell index
  maxSearch?: number;      // safety cap
}) {
  const cols = args.cfg.colsPerRow;
  const start = Math.max(0, args.startIndex ?? 0);
  const max = args.maxSearch ?? 10_000;

  for (let i = start; i < start + max; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const k = `${col},${row}`;
    if (!args.occupancy.has(k)) return { col, row, index: i };
  }
  // fallback: just append a new row
  const i = start + max;
  return { col: i % cols, row: Math.floor(i / cols), index: i };
}


---

C) Use it in your auto-place merge

Patch your mergeLayoutWithGraph() where you place a new node:

Replace “countNodesInLane + nextGridPosition” with occupancy-based placement

import { buildLaneOccupancy, findNextFreeSlot } from './collision';

...

const lane = opts.newNodesLane === '__new__' ? '__new__' : (n.schema || '__new__');
const laneX = layout.lanes?.[lane]?.x ?? opts.placeStartX;

const defaultCollapsed = n.kind === 'view' || n.kind === 'materialized_view';

const cfg = {
  nodeW: opts.nodeW,
  nodeHCollapsed: opts.nodeHCollapsed,
  nodeHExpanded: opts.nodeHExpanded,
  gapX: opts.gapX,
  gapY: opts.gapY,
  laneTop: opts.laneTop,
  colsPerRow: opts.colsPerRow,
};

const occ = buildLaneOccupancy({ layout, lane, laneX, cfg });
const slot = findNextFreeSlot({ occupancy: occ, cfg });
const pos = fromCell({ col: slot.col, row: slot.row, laneX, cfg, collapsed: defaultCollapsed });

layout.nodes[n.id] = { ...pos, collapsed: defaultCollapsed, lane };

You’ll also need fromCell exported (either export it from collision.ts or copy it next to merge).


---

D) Optional: snap-to-grid on drag end

When user releases a node:

compute nearest cell in its lane

snap x/y to that cell’s origin


apps/web/src/erd/snap.ts

import { toCell } from './collision'; // if you export it
import { fromCell } from './collision';

export function snapNodeToGrid(args: {
  node: { x: number; y: number; collapsed?: boolean; lane?: string };
  laneX: number;
  cfg: any;
}) {
  const collapsed = !!args.node.collapsed;
  const { col, row } = toCell({ x: args.node.x, y: args.node.y, laneX: args.laneX, cfg: args.cfg, collapsed });
  return fromCell({ col, row, laneX: args.laneX, cfg: args.cfg, collapsed });
}


---

E) What this buys you immediately

New tables never overlap existing ones

Layout stays stable even after many schema refreshes

Users can drag nodes freely but still keep things tidy with snap



---

Next (best “make it feel premium”)

3.3.12 Edge label placement + hover cards:

show FK name + “child → parent”

on hover: show FK cols, actions, deferrable, and a “copy relationship key” button (useful for debugging highlights).

3.3.12 Edge labels + hover cards (FK details, copy key, jump actions)

This is the “professional ERD” polish:

✅ edge labels that don’t sit directly on the line

✅ hover card with FK metadata (cols, on delete/update, deferrable)

✅ “Copy relationship key” (debug + anchor reliability)

✅ “Focus tables” quick actions



---

A) Add edge label fields in ErdGraph

Update your backend buildErdGraph() edges to include a short label:

apps/api/src/erd/types.ts (edge additions)

export type ErdEdge = {
  id: string;
  key: string;
  name?: string;

  from: string;
  to: string;
  fromCols: string[];
  toCols: string[];

  onUpdate?: string;
  onDelete?: string;
  deferrable?: boolean;
  initiallyDeferred?: boolean;

  label?: string;        // e.g., "fk_orders_user_id"
  labelShort?: string;   // e.g., "orders.user_id → users.id"
};

Patch buildErdGraph() edges mapper

const edges: ErdGraph['edges'] = Object.values(s.relationships).map((r) => ({
  id: r.key,
  key: r.key,
  name: r.name,
  label: r.name,
  labelShort: `${r.childKey.split('.').pop()}.${(r.childCols[0] ?? '…')} → ${r.parentKey.split('.').pop()}.${(r.parentCols[0] ?? '…')}`,
  from: r.childKey,
  to: r.parentKey,
  fromCols: r.childCols,
  toCols: r.parentCols,
  onUpdate: r.onUpdate,
  onDelete: r.onDelete,
  deferrable: r.deferrable,
  initiallyDeferred: r.initiallyDeferred,
}));


---

B) Compute label position (midpoint + normal offset)

We already compute an orthogonal path as points [p0..pn].
For labels, pick the segment around the midpoint, then offset perpendicular.

apps/web/src/erd/edgeLabel.ts

type Point = { x: number; y: number };

function dist(a: Point, b: Point) {
  const dx = b.x - a.x, dy = b.y - a.y;
  return Math.hypot(dx, dy);
}

function segmentNormal(a: Point, b: Point) {
  const dx = b.x - a.x, dy = b.y - a.y;
  const len = Math.hypot(dx, dy) || 1;
  // rotate (dx,dy) by 90deg to get normal
  return { nx: -dy / len, ny: dx / len };
}

export function labelPointForPolyline(points: Point[], offset = 12) {
  if (points.length < 2) return null;

  // total length
  let total = 0;
  for (let i = 0; i < points.length - 1; i++) total += dist(points[i], points[i + 1]);
  const half = total / 2;

  // walk to midpoint
  let acc = 0;
  for (let i = 0; i < points.length - 1; i++) {
    const a = points[i], b = points[i + 1];
    const d = dist(a, b);
    if (acc + d >= half) {
      const t = (half - acc) / (d || 1);
      const mx = a.x + (b.x - a.x) * t;
      const my = a.y + (b.y - a.y) * t;

      const { nx, ny } = segmentNormal(a, b);
      return { x: mx + nx * offset, y: my + ny * offset, segIndex: i };
    }
    acc += d;
  }

  // fallback end
  const last = points[points.length - 1];
  return { x: last.x, y: last.y, segIndex: points.length - 2 };
}


---

C) Hover detection (edge hit test)

For SVG paths, easiest is:

render an invisible “fat stroke” path on top (strokeWidth=16, opacity=0)

attach onMouseEnter/onMouseLeave/onClick


No geometry math needed.


---

D) Hover card UI data (what to show)

On hover:

FK name

child table + cols

parent table + cols

ON DELETE / ON UPDATE

deferrable + initially deferred

buttons:

Copy relationship key

Focus child

Focus parent



The data is already on edge.


---

E) Copy key helper

apps/web/src/utils/copy.ts

export async function copyText(text: string) {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    return false;
  }
}


---

F) “Focus child/parent” actions

These are just table-focus highlights using your existing jump system.

Create a tiny helper:

apps/web/src/erd/makeTableHighlight.ts

export function makeTableHighlight(tableKey: string, message?: string) {
  return {
    focus: { type: 'table', key: tableKey },
    tables: [{ key: tableKey, emphasis: 'primary' as const }],
    columns: [],
    relationships: [],
    message: message ?? `Focus: ${tableKey}`,
  };
}


---

G) Minimal React-ish render structure (pseudo)

For each edge:

compute route points

compute path d

compute label point

render:

visible path

invisible hit path

label (SVG <text> or HTML overlay)




Pseudo:

<path d={d} strokeWidth={isPrimary ? 4 : 2} />
<path d={d} strokeWidth={16} opacity={0} onMouseEnter={()=>setHover(edge)} />
{lp && <text x={lp.x} y={lp.y}>{edge.label}</text>}

For the hover card:

{hoverEdge && (
  <EdgePopover x={mouseX} y={mouseY} edge={hoverEdge} />
)}


---

Next (highest value)

3.3.13 Column-level anchors & edge endpoints:

When hovering edge, highlight the specific columns on both tables (fromCols / toCols).

When clicking “jump to relationship”, scroll the table card’s column list to the FK column and flash it.


3.3.13 Column-level anchors (edge ↔ columns) + “scroll to FK column” + flash

This makes relationships feel real: when you hover or click an edge, you see exactly which columns participate, and the table card scrolls right to them.

You’ll implement:

✅ map edge.fromCols/toCols → column keys

✅ highlight those rows in the table cards

✅ auto-scroll the column list to the first matched FK column

✅ flash animation (CSS class) for 800ms



---

A) Build column keys from an edge

Remember your column keys are schema.table.column.

apps/web/src/erd/edgeColumns.ts

export function edgeColumnKeys(edge: { from: string; to: string; fromCols: string[]; toCols: string[] }) {
  const fromKeys = (edge.fromCols ?? []).map(c => `${edge.from}.${c}`);
  const toKeys = (edge.toCols ?? []).map(c => `${edge.to}.${c}`);
  return { fromKeys, toKeys };
}


---

B) Merge with highlight payload on edge hover/click

When hovering an edge, you can temporarily set a derived highlight:

primary: relationship edge

secondary: the two tables

primary columns: FK cols on child + referenced cols on parent


apps/web/src/erd/makeEdgeHighlight.ts

import { edgeColumnKeys } from './edgeColumns';

export function makeEdgeHighlight(edge: {
  id: string;
  from: string;
  to: string;
  fromCols: string[];
  toCols: string[];
  label?: string;
}) {
  const { fromKeys, toKeys } = edgeColumnKeys(edge);

  return {
    focus: { type: 'relationship' as const, key: edge.id },
    relationships: [{ key: edge.id, emphasis: 'primary' as const }],
    tables: [
      { key: edge.from, emphasis: 'secondary' as const },
      { key: edge.to, emphasis: 'secondary' as const },
    ],
    columns: [
      ...fromKeys.map(k => ({ key: k, emphasis: 'primary' as const })),
      ...toKeys.map(k => ({ key: k, emphasis: 'primary' as const })),
    ],
    message: edge.label ?? 'Relationship',
  };
}

Use this for:

onMouseEnter(edge) (set hover highlight)

onClick(edge) (set persistent highlight + jump)



---

C) Column list scrolling + flashing

Inside each table card, you likely have:

<div className="columns-scroll" ref={listRef}>
  {columns.map(col => <ColumnRow key={col.id} ... />)}
</div>

We need:

1. find the first target column element


2. scroll container so it’s visible


3. add a flash class for 800ms



1) Add data attributes to column rows

<div
  data-col-key={col.id}              // "schema.table.column"
  className={rowClass}
>
  ...
</div>

2) Utility: scroll + flash

apps/web/src/erd/scrollFlash.ts

export function scrollToColumnAndFlash(args: {
  container: HTMLElement;
  columnKey: string;
  flashClass?: string;
  durationMs?: number;
}) {
  const flashClass = args.flashClass ?? 'erd-flash';
  const duration = args.durationMs ?? 800;

  const el = args.container.querySelector(`[data-col-key="${CSS.escape(args.columnKey)}"]`) as HTMLElement | null;
  if (!el) return false;

  // scroll into view inside container
  const cTop = args.container.scrollTop;
  const cHeight = args.container.clientHeight;
  const eTop = el.offsetTop;
  const eHeight = el.offsetHeight;

  const eBottom = eTop + eHeight;
  const cBottom = cTop + cHeight;

  if (eTop < cTop) args.container.scrollTop = Math.max(0, eTop - 12);
  else if (eBottom > cBottom) args.container.scrollTop = eBottom - cHeight + 12;

  // flash
  el.classList.remove(flashClass);
  // force reflow so re-adding triggers animation
  void el.offsetWidth;
  el.classList.add(flashClass);

  window.setTimeout(() => el.classList.remove(flashClass), duration);

  return true;
}


---

D) CSS for flash (Tailwind-friendly)

Add once (e.g., apps/web/src/index.css)

@keyframes erdFlash {
  0%   { transform: scale(1); }
  25%  { transform: scale(1.01); }
  50%  { transform: scale(1); }
  100% { transform: scale(1); }
}

.erd-flash {
  animation: erdFlash 800ms ease-out;
  outline: 2px solid currentColor;
  outline-offset: 2px;
  border-radius: 10px;
}

If you want a glow, you can pair with a subtle box-shadow via Tailwind class toggling too.


---

E) Wiring in a TableCard component

Each table card owns its column scroll container ref:

const listRef = useRef<HTMLDivElement>(null);

useEffect(() => {
  if (!listRef.current) return;

  // if highlight includes primary columns for this table, scroll to first
  const first = highlightedColumnKeysForThisTable[0];
  if (!first) return;

  scrollToColumnAndFlash({
    container: listRef.current,
    columnKey: first,
  });
}, [highlightVersionOrKey]);

Important: Use a stable “version” increment on highlight changes so hover doesn’t spam.


---

F) Relationship click behavior (ideal v1 UX)

On edge click:

1. set persistent highlight = makeEdgeHighlight(edge)


2. jumpToHighlight(...) to relationship midpoint


3. for both involved table cards:

scroll/flash first FK column on child table

scroll/flash first referenced column on parent table





---

Next (best)

3.3.14 “Issue → Column target resolution”:
If an issue targets a relationship but columns are missing (partial snapshot), the UI requests a visible refresh for those two tables automatically, then retries the scroll/flash.

3.3.14 Issue → Column target resolution (auto-fetch missing detail on demand)

Problem: in partial/visible snapshots, you might have the relationship edge and tables, but not the full column lists (or the specific FK cols) loaded yet.

Solution: when the user clicks an Issue (or edge), the UI:

1. tries to scroll/flash FK columns


2. if missing → auto-call visible refresh for the two tables


3. merge returned partial graph


4. retry scroll/flash



This makes the ERD feel smart and avoids “nothing happened”.


---

A) Frontend contract: visible refresh call

Use your existing endpoint:

POST /api/v1/erd/graph with:

refresh: "visible"

visibleTables: [childTableKey, parentTableKey]


Return includes graph (partial) which you merge.


---

B) Detection: “do we have the needed columns?”

apps/web/src/erd/needsColumns.ts

export function tableHasColumns(args: {
  nodesById: Map<string, { id: string; columns: Array<{ id: string }> }>;
  tableKey: string;
  requiredColumnKeys: string[];
}) {
  const node = args.nodesById.get(args.tableKey);
  if (!node) return false;
  const have = new Set(node.columns.map(c => c.id));
  return args.requiredColumnKeys.every(k => have.has(k));
}


---

C) Orchestrator: resolve + refresh + retry

apps/web/src/erd/resolveEdgeColumns.ts

import { edgeColumnKeys } from './edgeColumns';
import { tableHasColumns } from './needsColumns';

export async function resolveEdgeColumnsIfNeeded(args: {
  edge: { id: string; from: string; to: string; fromCols: string[]; toCols: string[] };
  nodesById: Map<string, { id: string; columns: Array<{ id: string }> }>;

  // API
  fetchVisibleGraph: (visibleTables: string[]) => Promise<{ graph: any }>;

  // merge
  mergeGraph: (graph: any) => void;
}) {
  const { fromKeys, toKeys } = edgeColumnKeys(args.edge);

  const childOk = tableHasColumns({
    nodesById: args.nodesById,
    tableKey: args.edge.from,
    requiredColumnKeys: fromKeys,
  });

  const parentOk = tableHasColumns({
    nodesById: args.nodesById,
    tableKey: args.edge.to,
    requiredColumnKeys: toKeys,
  });

  if (childOk && parentOk) return { refreshed: false };

  // fetch visible-only update for the two tables
  const res = await args.fetchVisibleGraph([args.edge.from, args.edge.to]);

  // merge into store
  args.mergeGraph(res.graph);

  return { refreshed: true };
}


---

D) Example: fetchVisibleGraph() implementation

apps/web/src/api/erd.ts

export async function fetchErdGraph(args: {
  targetDatabaseUrl: string;
  schemas: string[];
  refresh: 'cache' | 'force' | 'visible';
  visibleTables?: string[];
}) {
  const res = await fetch('/api/v1/erd/graph', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(args),
  });
  if (!res.ok) throw new Error(`ERD graph failed: ${res.status}`);
  return res.json();
}

Then:

const fetchVisibleGraph = async (visibleTables: string[]) =>
  fetchErdGraph({
    targetDatabaseUrl,
    schemas,
    refresh: 'visible',
    visibleTables,
  });


---

E) Graph merge (partial → store)

You want a “replace-by-id” merge:

apps/web/src/erd/mergeGraph.ts

export function mergeGraphIntoStore(args: {
  incoming: { nodes: any[]; edges: any[] };
  nodesById: Map<string, any>;
  edgesById: Map<string, any>;
}) {
  for (const n of args.incoming.nodes ?? []) {
    args.nodesById.set(n.id, n); // replace whole node (includes columns)
  }
  for (const e of args.incoming.edges ?? []) {
    args.edgesById.set(e.id, e);
  }
}

If you want to be safer for partial nodes:

only overwrite columns if incoming has them

keep local columns otherwise


But your visible refresh returns columns for those tables, so replacing is fine.


---

F) Full “Issue click” flow (ideal)

On issue click:

1. setHighlight(issue.highlight)


2. jumpToHighlight(...)


3. if focus is relationship:

resolveEdgeColumnsIfNeeded(...)

then scrollToColumnAndFlash for the FK columns on both tables




This yields a “click → jump → load missing → flash” experience.


---

Next (best)

3.3.15 “ERD mini-map + search”:

search table/column names (fuzzy)

clicking result sets highlight + jumps

mini-map shows lanes + viewport rectangle for huge diagrams

3.3.15 ERD Search (table/column/relationship) + mini “Jump” UX (minimum to ship)

This is the feature users will use constantly:

type orders → jump to public.orders

type orders.user_id → jump + flash that column

type fk_orders_user → jump to that edge


We’ll ship search first (mini-map can come next as 3.3.16).


---

A) Search index (build once per graph update)

We’ll index:

tables: schema.table, table

columns: schema.table.column, column, table.column

relationships: edge name, and the relationship key signature


apps/web/src/erd/searchIndex.ts

export type SearchItem =
  | { kind: 'table'; key: string; label: string; subtitle?: string }
  | { kind: 'column'; key: string; tableKey: string; label: string; subtitle?: string }
  | { kind: 'relationship'; key: string; label: string; subtitle?: string };

export function buildSearchIndex(args: {
  nodes: Array<{ id: string; schema: string; name: string; columns: Array<{ id: string; name: string }> }>;
  edges: Array<{ id: string; name?: string; from: string; to: string }>;
}) {
  const items: SearchItem[] = [];

  for (const n of args.nodes) {
    items.push({
      kind: 'table',
      key: n.id,
      label: n.name,
      subtitle: n.schema,
    });

    for (const c of n.columns ?? []) {
      items.push({
        kind: 'column',
        key: c.id,               // "schema.table.column"
        tableKey: n.id,           // "schema.table"
        label: `${n.name}.${c.name}`,
        subtitle: n.schema,
      });
    }
  }

  for (const e of args.edges) {
    const label = e.name ? e.name : `${e.from} → ${e.to}`;
    items.push({
      kind: 'relationship',
      key: e.id,                 // relationship signature key
      label,
      subtitle: `${e.from} → ${e.to}`,
    });
  }

  return items;
}


---

B) Lightweight fuzzy matcher (v1 simple scoring)

We’ll do “contains” + token bonuses (good enough).

apps/web/src/erd/searchMatch.ts

import type { SearchItem } from './searchIndex';

function normalize(s: string) {
  return s.toLowerCase().trim();
}

function scoreText(hay: string, q: string) {
  if (!q) return 0;
  const h = normalize(hay);
  const qq = normalize(q);

  if (h === qq) return 100;
  if (h.startsWith(qq)) return 80;
  const idx = h.indexOf(qq);
  if (idx >= 0) return 60 - Math.min(20, idx); // earlier match better

  // token match
  const tokens = qq.split(/[.\s_:-]+/).filter(Boolean);
  let tokenScore = 0;
  for (const t of tokens) if (h.includes(t)) tokenScore += 10;
  return tokenScore;
}

export function search(items: SearchItem[], query: string, limit = 20) {
  const q = query.trim();
  if (!q) return [];

  const scored = items
    .map((it) => {
      const s1 = scoreText(it.label, q);
      const s2 = it.subtitle ? scoreText(it.subtitle, q) : 0;
      const bonus =
        it.kind === 'table' ? 5 :
        it.kind === 'column' ? 3 : 1;

      return { it, score: Math.max(s1, s2) + bonus };
    })
    .filter(x => x.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map(x => x.it);

  return scored;
}


---

C) “Select result” → highlight + jump + flash (column aware)

apps/web/src/erd/selectSearchItem.ts

import type { SearchItem } from './searchIndex';
import { makeTableHighlight } from './makeTableHighlight';

export function highlightForSearchItem(item: SearchItem) {
  if (item.kind === 'table') {
    return makeTableHighlight(item.key, `Table: ${item.label}`);
  }
  if (item.kind === 'column') {
    return {
      focus: { type: 'table' as const, key: item.tableKey },
      tables: [{ key: item.tableKey, emphasis: 'primary' as const }],
      columns: [{ key: item.key, emphasis: 'primary' as const }],
      relationships: [],
      message: `Column: ${item.label}`,
    };
  }
  // relationship
  return {
    focus: { type: 'relationship' as const, key: item.key },
    tables: [],
    columns: [],
    relationships: [{ key: item.key, emphasis: 'primary' as const }],
    message: `Relationship`,
  };
}

On select:

1. set highlight


2. jump to focus


3. if column result: scroll/flash that column row in the table card


4. if relationship result: use 3.3.14 auto-refresh if needed then flash columns if desired




---

D) Minimal UI component behavior (what to implement)

Top bar

Search input with hotkey / or Ctrl+K

Results dropdown

Enter selects first result


Result line

icon: table/column/link

label

subtitle



---

E) Next (3.3.16) — Mini-map (optional but awesome)

If you want the mini-map next, say 3.3.16 and I’ll give:

layout bounds calculation

viewport rectangle

click-to-jump mapping

lightweight rendering strategy (SVG)

3.3.16 ERD Mini-map (bounds + viewport rect + click-to-jump)

A mini-map is just:

a scaled-down view of node rectangles

plus your current viewport rectangle

clicking a point recenters the main canvas there


No heavy rendering — basic SVG works great.


---

A) What the mini-map needs

Inputs:

layout.nodes with {x,y,collapsed}

a fixed node size approximation (same as ERD)

current viewport {x,y,zoom}

screen size of main canvas {w,h}

mini-map size {mw,mh}


Outputs:

overall bounds {minX,minY,maxX,maxY}

scale factor for mini-map

viewport rect in mini-map coords

click handler mapping mini coords → world point → viewport recenter



---

B) Bounds calculation (world space)

apps/web/src/erd/minimapBounds.ts

import { nodeDims } from './focus';

type LayoutNode = { x: number; y: number; collapsed?: boolean };

export function computeWorldBounds(nodes: Record<string, LayoutNode>) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  for (const n of Object.values(nodes)) {
    const { W, H } = nodeDims({ collapsed: n.collapsed });
    minX = Math.min(minX, n.x);
    minY = Math.min(minY, n.y);
    maxX = Math.max(maxX, n.x + W);
    maxY = Math.max(maxY, n.y + H);
  }

  if (!isFinite(minX)) {
    // empty
    return { minX: 0, minY: 0, maxX: 1000, maxY: 800 };
  }
  return { minX, minY, maxX, maxY };
}


---

C) Fit bounds into minimap (scale + padding)

apps/web/src/erd/minimapFit.ts

export function fitToMinimap(args: {
  bounds: { minX: number; minY: number; maxX: number; maxY: number };
  size: { w: number; h: number };
  pad?: number;
}) {
  const pad = args.pad ?? 12;

  const bw = args.bounds.maxX - args.bounds.minX;
  const bh = args.bounds.maxY - args.bounds.minY;

  // avoid div by zero
  const scaleX = (args.size.w - pad * 2) / Math.max(1, bw);
  const scaleY = (args.size.h - pad * 2) / Math.max(1, bh);
  const scale = Math.min(scaleX, scaleY);

  // center within minimap
  const contentW = bw * scale;
  const contentH = bh * scale;
  const ox = (args.size.w - contentW) / 2 - args.bounds.minX * scale;
  const oy = (args.size.h - contentH) / 2 - args.bounds.minY * scale;

  return { scale, ox, oy };
}

World → mini:

mx = worldX * scale + ox

my = worldY * scale + oy


Mini → world:

worldX = (mx - ox) / scale



---

D) Viewport rectangle (mini coords)

Viewport formula (world → screen):

screenX = worldX * zoom + viewport.x

screenY = worldY * zoom + viewport.y


So screen (0,0) corresponds to world:

worldLeft = (-viewport.x) / zoom

worldTop  = (-viewport.y) / zoom


And screen (w,h) corresponds to:

worldRight  = (w - viewport.x) / zoom

worldBottom = (h - viewport.y) / zoom


apps/web/src/erd/minimapViewport.ts

export function worldViewportRect(args: {
  viewport: { x: number; y: number; zoom: number };
  screen: { w: number; h: number };
}) {
  const { x, y, zoom } = args.viewport;

  const left = (-x) / zoom;
  const top = (-y) / zoom;
  const right = (args.screen.w - x) / zoom;
  const bottom = (args.screen.h - y) / zoom;

  return { left, top, right, bottom, w: right - left, h: bottom - top };
}

Convert to mini coords using {scale,ox,oy}.


---

E) Click-to-jump mapping

When user clicks minimap at (mx,my):

1. convert to world point (wx,wy)


2. compute a new viewport that centers on (wx,wy) (same as 3.3.9)



apps/web/src/erd/minimapClick.ts

import { viewportToCenterOn } from './viewport';

export function viewportFromMinimapClick(args: {
  click: { mx: number; my: number };
  fit: { scale: number; ox: number; oy: number };
  current: { x: number; y: number; zoom: number };
  screen: { w: number; h: number };
}) {
  const wx = (args.click.mx - args.fit.ox) / args.fit.scale;
  const wy = (args.click.my - args.fit.oy) / args.fit.scale;

  return viewportToCenterOn({
    point: { x: wx, y: wy },
    current: args.current,
    screen: args.screen,
  });
}


---

F) Rendering (simple SVG)

Render:

small rectangles for nodes

a rectangle for viewport

(optional) highlight rects for selected tables


Pseudo JSX:

<svg width={mw} height={mh} onClick={...}>
  {Object.entries(layout.nodes).map(([id,n]) => {
    const {W,H}=nodeDims({collapsed:n.collapsed});
    const x=n.x*scale+ox, y=n.y*scale+oy;
    return <rect x={x} y={y} width={W*scale} height={H*scale} rx={2} />;
  })}
  <rect x={vpX} y={vpY} width={vpW} height={vpH} fill="none" strokeWidth={2} />
</svg>

Compute viewport rect in mini coords:

const wv = worldViewportRect({viewport, screen});
const vpX = wv.left*scale + ox;
const vpY = wv.top*scale + oy;
const vpW = wv.w*scale;
const vpH = wv.h*scale;


---

G) UX defaults

Mini-map docked bottom-right

toggle button (map icon)

clicking recenters (optional drag-to-pan later)



---

Next (most useful after mini-map)

3.3.17 Column search “within table” + filter toggles

hide non-related columns (show only PK/FK/unique)

collapse all / expand all

show only tables connected to selected table (1-hop neighborhood)

3.3.17 Column filter toggles + “Neighborhood” mode (connected tables only) + in-table search

This is the “I can actually use this ERD on a real database” set of controls.

You’ll implement 3 UI features that leverage your existing keys:

1. Column filters (PK/FK/Unique/Nullable/All)


2. In-table column search (quick filter inside a node card)


3. Neighborhood mode (show only tables within N hops of a selected table)




---

A) Column filter toggles (per table card)

Filter state

type ColumnFilterMode = 'all' | 'keys' | 'pk' | 'fk' | 'unique' | 'not_null';

type TableUiState = {
  filterMode: ColumnFilterMode;
  columnQuery: string;   // in-table search
};

Filter logic

export function filterColumns(args: {
  cols: Array<{ id: string; name: string; isPk?: boolean; isFk?: boolean; isUnique?: boolean; isNullable: boolean }>;
  mode: ColumnFilterMode;
  query: string;
}) {
  const q = args.query.trim().toLowerCase();

  return args.cols.filter(c => {
    // mode filter
    let ok = true;
    if (args.mode === 'keys') ok = !!(c.isPk || c.isFk || c.isUnique);
    if (args.mode === 'pk') ok = !!c.isPk;
    if (args.mode === 'fk') ok = !!c.isFk;
    if (args.mode === 'unique') ok = !!c.isUnique;
    if (args.mode === 'not_null') ok = !c.isNullable;

    if (!ok) return false;

    // query filter
    if (!q) return true;
    return c.name.toLowerCase().includes(q);
  });
}

UX default: keys filter is a great “clean” default for giant tables.


---

B) In-table search UI (minimal)

In the TableCard header:

small search input

filter pills: All / Keys / PK / FK / Unique / Not null

“Clear” button (x)


This is purely frontend; no API calls.


---

C) Neighborhood mode (connected tables only)

When user selects a “focus table”:

filter graph to show tables within N hops (1 or 2)

keep edges only among visible nodes

preserve layout positions (don’t re-layout)

minimap + search still work, but on filtered set


Compute adjacency from edges

export function buildAdjacency(edges: Array<{ from: string; to: string }>) {
  const adj = new Map<string, Set<string>>();
  const add = (a: string, b: string) => {
    if (!adj.has(a)) adj.set(a, new Set());
    adj.get(a)!.add(b);
  };
  for (const e of edges) {
    add(e.from, e.to);
    add(e.to, e.from);
  }
  return adj;
}

BFS to get N-hop neighborhood

export function neighborhoodNodes(args: {
  start: string; // table key
  hops: number;
  adj: Map<string, Set<string>>;
}) {
  const seen = new Set<string>([args.start]);
  let frontier = new Set<string>([args.start]);

  for (let h = 0; h < args.hops; h++) {
    const next = new Set<string>();
    for (const n of frontier) {
      for (const m of args.adj.get(n) ?? []) {
        if (!seen.has(m)) {
          seen.add(m);
          next.add(m);
        }
      }
    }
    frontier = next;
    if (frontier.size === 0) break;
  }

  return seen;
}

Filter graph

export function filterGraphToNodes(args: {
  nodes: Array<{ id: string }>;
  edges: Array<{ id: string; from: string; to: string }>;
  keep: Set<string>;
}) {
  const nodes = args.nodes.filter(n => args.keep.has(n.id));
  const edges = args.edges.filter(e => args.keep.has(e.from) && args.keep.has(e.to));
  return { nodes, edges };
}


---

D) UX: Neighborhood controls

Top bar controls:

Toggle: “Neighborhood”

Slider / dropdown: 1 hop / 2 hops

Button: “Reset (Show all)”

When user clicks a table: set it as neighborhood center


Pro behavior: If an Issue highlight focuses a table, auto-enable neighborhood 1-hop around it (optional).


---

E) Tie-in with your existing highlight payload

When you set highlight to a table:

set selected table = highlight.focus.key

optionally compute neighborhood set and filter graph


This makes “Issue → ERD” much cleaner.


---

Next (best)

3.3.18 Export/Share

export ERD as PNG/SVG

export snapshot JSON (for bug reports)

export “DDL bundle” (tables + views definitions) optionally

3.3.18 Export/Share (PNG/SVG + Snapshot JSON + “Support bundle”)

This is what turns your ERD into a product people can use and share.

We’ll ship 3 exports (v1-friendly):

1. Export ERD as SVG (best quality)


2. Export ERD as PNG (for docs/slides)


3. Export “Support bundle” JSON (snapshot + layout + signature + app version)



(DDL bundle can be 3.3.19.)


---

A) Export SVG (recommended baseline)

If you render edges/nodes as SVG already, export is easy:

wrap your ERD SVG in a single <svg> root

serialize to string

download as .svg


apps/web/src/erd/exportSvg.ts

export function exportSvg(svgEl: SVGSVGElement, filename = 'erd.svg') {
  const clone = svgEl.cloneNode(true) as SVGSVGElement;

  // Ensure xmlns for standalone file
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  const serializer = new XMLSerializer();
  const svgText = serializer.serializeToString(clone);

  const blob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();

  URL.revokeObjectURL(url);
}

Tip: include a white background rect for readability:

<rect x="0" y="0" width="100%" height="100%" fill="white" />


---

B) Export PNG (SVG → Canvas render)

Convert SVG text into an <img>, paint to <canvas>, then download PNG.

apps/web/src/erd/exportPng.ts

function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

export async function exportSvgAsPng(args: {
  svgEl: SVGSVGElement;
  filename?: string;
  scale?: number; // 2 for retina
  background?: string; // "white"
}) {
  const filename = args.filename ?? 'erd.png';
  const scale = args.scale ?? 2;

  const clone = args.svgEl.cloneNode(true) as SVGSVGElement;
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  // Optional background
  if (args.background) {
    const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bg.setAttribute('x', '0');
    bg.setAttribute('y', '0');
    bg.setAttribute('width', '100%');
    bg.setAttribute('height', '100%');
    bg.setAttribute('fill', args.background);
    clone.insertBefore(bg, clone.firstChild);
  }

  const svgText = new XMLSerializer().serializeToString(clone);
  const svgBlob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(svgBlob);

  const img = new Image();
  // Important for some browsers
  img.decoding = 'async';

  await new Promise<void>((resolve, reject) => {
    img.onload = () => resolve();
    img.onerror = () => reject(new Error('Failed to load SVG image'));
    img.src = url;
  });

  // Determine intrinsic size
  const bbox = args.svgEl.getBoundingClientRect();
  const w = Math.max(1, Math.floor(bbox.width));
  const h = Math.max(1, Math.floor(bbox.height));

  const canvas = document.createElement('canvas');
  canvas.width = w * scale;
  canvas.height = h * scale;

  const ctx = canvas.getContext('2d');
  if (!ctx) throw new Error('No 2D canvas context');

  ctx.setTransform(scale, 0, 0, scale, 0, 0);
  ctx.drawImage(img, 0, 0);

  URL.revokeObjectURL(url);

  const pngBlob = await new Promise<Blob>((resolve) =>
    canvas.toBlob((b) => resolve(b!), 'image/png')
  );

  downloadBlob(pngBlob, filename);
}


---

C) Export “Support bundle” JSON (snapshot+layout+graph meta)

This is huge for debugging user reports:

“why is my edge missing?” → you can reproduce with snapshot JSON.


Bundle includes:

app version (commit hash)

connectionKey (optionally masked)

schemas

snapshot meta + signature

graph nodes/edges (optional)

layout

active filters/neighborhood state (optional)


apps/web/src/erd/exportBundle.ts

function downloadJson(obj: any, filename: string) {
  const text = JSON.stringify(obj, null, 2);
  const blob = new Blob([text], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

export function exportSupportBundle(args: {
  appVersion: string;
  connectionKey: string;
  schemas: string[];
  signature: string;
  graph: any;
  layout: any;
  snapshotMeta?: any; // if you keep it
  uiState?: any;
}) {
  // optional: mask connectionKey if it contains url
  const safeKey = args.connectionKey.startsWith('url:')
    ? 'url:[masked]'
    : args.connectionKey;

  downloadJson(
    {
      exportedAt: new Date().toISOString(),
      appVersion: args.appVersion,
      connectionKey: safeKey,
      schemas: args.schemas,
      signature: args.signature,
      snapshotMeta: args.snapshotMeta ?? null,
      graph: args.graph,
      layout: args.layout,
      uiState: args.uiState ?? null,
    },
    `erd_bundle_${args.schemas.join('_')}.json`,
  );
}


---

D) UI placement (what to add now)

Top-right “Share / Export” menu with:

Export SVG

Export PNG

Export Support Bundle (JSON)


These do not require backend.


---

E) Next (3.3.19) — DDL Bundle (tables + views)

If you want the next step:

backend endpoint that returns DDL for selected tables/views

zip download (or JSON array)

integrates with search + neighborhood selection


Say 3.3.19 if you want it.

3.3.19 DDL Bundle Export (tables + views) + “selected / neighborhood” scopes

We’ll add a backend endpoint that returns a DDL package for:

selected tables

selected views/materialized views

or “current neighborhood” (N-hop set)


Supports Postgres first (fits your 3.x introspection layer).


---

A) Endpoint spec

POST /api/v1/introspect/postgres/ddl-bundle

Body:

{
  "targetDatabaseUrl": "postgresql://...",
  "schemas": ["public"],
  "scope": {
    "mode": "selected|neighborhood|schemas",
    "tables": ["public.users","public.orders"],
    "views": ["public.user_rollup"],
    "centerTable": "public.users",
    "hops": 1
  },
  "options": {
    "includeIndexes": true,
    "includeConstraints": true,
    "includeFkConstraints": true,
    "includeComments": false,
    "includeOwnerGrants": false,
    "statementTimeoutMs": 8000
  }
}

Response:

{
  "meta": { "db": "mydb", "capturedAt": "ISO" },
  "items": [
    { "kind": "table", "key": "public.users", "ddl": "CREATE TABLE ..." },
    { "kind": "view", "key": "public.user_rollup", "ddl": "CREATE VIEW ..." }
  ]
}


---

B) What Postgres can/can’t do easily

Postgres doesn’t have a single perfect “SHOW CREATE TABLE”, but we can get good DDL by combining:

columns + types + defaults + nullability (from catalog)

primary/unique/fk constraints (pg_constraint)

indexes (pg_indexes / pg_get_indexdef)

view definitions (pg_get_viewdef)

optional comments (pg_description)


For v1: produce clean, deterministic DDL good for export and diffs.


---

C) DDL Builder (tables)

apps/api/src/introspection/ddl/tableDdl.ts

import type { Pool } from 'pg';

type DdlOptions = {
  includeIndexes: boolean;
  includeConstraints: boolean;
  includeFkConstraints: boolean;
};

function qident(id: string) {
  // simple quote (safe-ish); for full correctness you can use pg-format later
  return `"${id.replace(/"/g, '""')}"`;
}

export async function buildTableDdl(args: {
  pool: Pool;
  schema: string;
  table: string;
  options: DdlOptions;
}) {
  const { schema, table, pool, options } = args;

  // columns
  const colsRes = await pool.query(
    `
    SELECT
      a.attname AS name,
      format_type(a.atttypid, a.atttypmod) AS data_type,
      a.attnotnull AS not_null,
      pg_get_expr(ad.adbin, ad.adrelid) AS default_expr
    FROM pg_attribute a
    JOIN pg_class c ON c.oid = a.attrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
    WHERE n.nspname = $1
      AND c.relname = $2
      AND a.attnum > 0
      AND NOT a.attisdropped
    ORDER BY a.attnum
    `,
    [schema, table],
  );

  // constraints (pk/unique/fk) using pg_get_constraintdef
  const consRes = options.includeConstraints
    ? await pool.query(
        `
        SELECT con.conname AS name, con.contype AS type, pg_get_constraintdef(con.oid, true) AS def
        FROM pg_constraint con
        JOIN pg_class c ON c.oid = con.conrelid
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = $1 AND c.relname = $2
          AND con.contype IN ('p','u','f','c')
        ORDER BY con.contype, con.conname
        `,
        [schema, table],
      )
    : { rows: [] as any[] };

  // indexes (exclude primary key indexes if you want; v1 include all non-constraint indexes)
  const idxRes = options.includeIndexes
    ? await pool.query(
        `
        SELECT indexname AS name, indexdef AS def
        FROM pg_indexes
        WHERE schemaname = $1 AND tablename = $2
        ORDER BY indexname
        `,
        [schema, table],
      )
    : { rows: [] as any[] };

  const lines: string[] = [];

  // CREATE TABLE header
  lines.push(`CREATE TABLE ${qident(schema)}.${qident(table)} (`);

  // column lines
  const colLines = colsRes.rows.map((r: any) => {
    const parts: string[] = [];
    parts.push(`${qident(r.name)} ${r.data_type}`);
    if (r.default_expr) parts.push(`DEFAULT ${r.default_expr}`);
    if (r.not_null) parts.push(`NOT NULL`);
    return `  ${parts.join(' ')}`;
  });

  // constraint lines (inline after columns)
  const constraintLines: string[] = [];
  if (options.includeConstraints) {
    for (const r of consRes.rows ?? []) {
      const type = String(r.type);
      if (type === 'f' && !options.includeFkConstraints) continue;
      constraintLines.push(`  CONSTRAINT ${qident(r.name)} ${r.def}`);
    }
  }

  const bodyLines = [...colLines, ...constraintLines];
  lines.push(bodyLines.join(',\n'));
  lines.push(`);`);

  // indexes as separate statements
  if (options.includeIndexes) {
    for (const r of idxRes.rows ?? []) {
      // indexdef already contains CREATE INDEX ...; keep it
      lines.push(String(r.def).endsWith(';') ? String(r.def) : `${r.def};`);
    }
  }

  return lines.join('\n');
}

Notes:

Uses pg_get_constraintdef for readable FK/PK/Unique.

Uses pg_indexes.indexdef for index statements.



---

D) DDL Builder (views + matviews)

apps/api/src/introspection/ddl/viewDdl.ts

import type { Pool } from 'pg';

function qident(id: string) {
  return `"${id.replace(/"/g, '""')}"`;
}

export async function buildViewDdl(args: {
  pool: Pool;
  schema: string;
  name: string;
  kind: 'view' | 'materialized_view';
}) {
  const { pool, schema, name, kind } = args;

  const res = await pool.query(
    `
    SELECT c.relkind AS relkind, pg_get_viewdef(c.oid, true) AS def
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = $1 AND c.relname = $2
      AND c.relkind IN ('v','m')
    `,
    [schema, name],
  );

  const row = res.rows?.[0];
  if (!row) throw new Error(`View not found: ${schema}.${name}`);

  const isMat = String(row.relkind) === 'm' || kind === 'materialized_view';
  const head = isMat ? 'CREATE MATERIALIZED VIEW' : 'CREATE VIEW';
  const ddl = `${head} ${qident(schema)}.${qident(name)} AS\n${String(row.def).trim()}\n;`;
  return ddl;
}


---

E) Scope resolution (selected / neighborhood / schemas)

For selected: just use tables[] and views[].

For schemas: export everything in those schemas (dangerous for huge DBs, but useful).

For neighborhood: compute N-hop from a center table using the snapshot relationships (fastest path):

load latest snapshot from persistent cache

BFS edges to collect tables

then build DDL for that set


Minimal neighborhood resolver (backend)

apps/api/src/introspection/ddl/scope.ts

import type { CatalogSnapshot } from '../types';

export function neighborhoodFromSnapshot(args: {
  snapshot: CatalogSnapshot;
  center: string;
  hops: number;
}) {
  const adj = new Map<string, Set<string>>();
  const add = (a: string, b: string) => {
    if (!adj.has(a)) adj.set(a, new Set());
    adj.get(a)!.add(b);
  };

  for (const r of Object.values(args.snapshot.relationships)) {
    add(r.childKey, r.parentKey);
    add(r.parentKey, r.childKey);
  }

  const seen = new Set<string>([args.center]);
  let frontier = new Set<string>([args.center]);

  for (let h = 0; h < args.hops; h++) {
    const next = new Set<string>();
    for (const n of frontier) {
      for (const m of adj.get(n) ?? []) {
        if (!seen.has(m)) {
          seen.add(m);
          next.add(m);
        }
      }
    }
    frontier = next;
    if (!frontier.size) break;
  }

  return Array.from(seen);
}


---

F) Route implementation

apps/api/src/routes/ddlBundle.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';
import { appDb } from '../services/appDb';
import { loadLatestSnapshot } from '../introspection/persist';
import { neighborhoodFromSnapshot } from '../introspection/ddl/scope';
import { buildTableDdl } from '../introspection/ddl/tableDdl';
import { buildViewDdl } from '../introspection/ddl/viewDdl';

function normalizeSchemas(s: string[]) {
  return s.slice().map(x => x.trim()).filter(Boolean).sort();
}

function makeConnectionKey(body: { connectionId?: string; targetDatabaseUrl: string }) {
  return body.connectionId ? `conn:${body.connectionId}` : `url:${body.targetDatabaseUrl}`;
}

export async function ddlBundleRoutes(app: FastifyInstance) {
  app.post('/api/v1/introspect/postgres/ddl-bundle', async (req) => {
    const Body = z.object({
      connectionId: z.string().uuid().optional(),
      targetDatabaseUrl: z.string().min(10),
      schemas: z.array(z.string().min(1)).min(1),
      scope: z.object({
        mode: z.enum(['selected','neighborhood','schemas']),
        tables: z.array(z.string().min(3)).optional(),
        views: z.array(z.string().min(3)).optional(),
        centerTable: z.string().min(3).optional(),
        hops: z.number().int().min(1).max(3).optional(),
      }),
      options: z.object({
        includeIndexes: z.boolean().default(true),
        includeConstraints: z.boolean().default(true),
        includeFkConstraints: z.boolean().default(true),
        includeComments: z.boolean().default(false),
        includeOwnerGrants: z.boolean().default(false),
        statementTimeoutMs: z.number().int().min(1000).max(30000).default(8000),
      }).default({
        includeIndexes: true,
        includeConstraints: true,
        includeFkConstraints: true,
        includeComments: false,
        includeOwnerGrants: false,
        statementTimeoutMs: 8000,
      }),
    });

    const body = Body.parse(req.body);
    const schemas = normalizeSchemas(body.schemas);
    const connectionKey = makeConnectionKey(body);

    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      // safety timeout
      await pool.query(`SET statement_timeout = $1`, [body.options.statementTimeoutMs]);

      let tables: string[] = [];
      let views: string[] = body.scope.views ?? [];

      if (body.scope.mode === 'selected') {
        tables = body.scope.tables ?? [];
      }

      if (body.scope.mode === 'schemas') {
        // all tables/views in schemas
        const tRes = await pool.query(
          `
          SELECT n.nspname AS schema, c.relname AS name, c.relkind AS relkind
          FROM pg_class c
          JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE n.nspname = ANY($1::text[])
            AND c.relkind IN ('r','p','v','m')
          ORDER BY 1,2
          `,
          [schemas],
        );

        for (const r of tRes.rows ?? []) {
          const key = `${r.schema}.${r.name}`;
          if (r.relkind === 'v' || r.relkind === 'm') views.push(key);
          else tables.push(key);
        }
      }

      if (body.scope.mode === 'neighborhood') {
        const center = body.scope.centerTable!;
        const hops = body.scope.hops ?? 1;

        const prev = await loadLatestSnapshot({ appDb, connectionKey, schemas });
        if (!prev) throw new Error('No cached snapshot available for neighborhood mode. Run snapshot first.');

        tables = neighborhoodFromSnapshot({ snapshot: prev.snapshot, center, hops });
      }

      // dedupe & sort
      tables = Array.from(new Set(tables)).sort();
      views = Array.from(new Set(views)).sort();

      const items: Array<{ kind: string; key: string; ddl: string }> = [];

      for (const key of tables) {
        const [schema, name] = key.split('.');
        if (!schema || !name) continue;
        const ddl = await buildTableDdl({
          pool,
          schema,
          table: name,
          options: {
            includeIndexes: body.options.includeIndexes,
            includeConstraints: body.options.includeConstraints,
            includeFkConstraints: body.options.includeFkConstraints,
          },
        });
        items.push({ kind: 'table', key, ddl });
      }

      for (const key of views) {
        const [schema, name] = key.split('.');
        if (!schema || !name) continue;
        const ddl = await buildViewDdl({ pool, schema, name, kind: 'view' });
        items.push({ kind: 'view', key, ddl });
      }

      const dbRes = await pool.query(`SELECT current_database() AS db`);
      return {
        meta: { db: dbRes.rows?.[0]?.db ?? 'db', capturedAt: new Date().toISOString() },
        items,
      };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}

Wire it:

import { ddlBundleRoutes } from './routes/ddlBundle';
await app.register(ddlBundleRoutes);


---

G) Frontend: Export “DDL Bundle”

From your Export menu:

choose scope:

Selected tables (current selection set)

Neighborhood of focused table (hops 1/2)

All schemas (danger confirm)


call endpoint

download as .sql file (concatenate items with separators)


Download helper

export function downloadText(filename: string, text: string) {
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

Concatenate:

const sql = items.map(i => `-- ===== ${i.kind.toUpperCase()} ${i.key} =====\n${i.ddl}\n`).join('\n');
downloadText('erd_bundle.sql', sql);


---

Next (if you want the final ERD “tool completeness” piece)

3.3.20 Data entry / table editor v1

3.3.20 Data Entry / Table Editor v1 (grid viewer + edit + insert + delete)

This is the “database GUI” core beyond ERD: a clean table browser/editor that feels modern.

We’ll ship v1 as:

✅ table picker (from introspection snapshot)

✅ grid view with paging + sorting

✅ row detail drawer (edit fields)

✅ insert row modal

✅ delete row (safe confirm)

✅ “read-only mode” toggle per connection (safety)


No fancy FK dropdowns yet (that’s 3.3.21).


---

A) API endpoints (minimum)

All table editor requests should go through your backend so you can:

enforce RBAC later

apply timeouts/limits

log changes

prevent dangerous queries


Endpoints

1. POST /api/v1/data/query (read)


2. POST /api/v1/data/row/update (edit)


3. POST /api/v1/data/row/insert (insert)


4. POST /api/v1/data/row/delete (delete)



Each request includes:

targetDatabaseUrl

schema, table

primaryKey info (or a row locator strategy)



---

B) Row identity (critical decision)

To safely update/delete, you need a stable row locator:

v1 rule (simple, safe):

Require table has a primary key (single or composite)

Use PK columns to locate row:

WHERE pk1 = $1 AND pk2 = $2



If no PK:

read-only grid only (show warning)


Your introspection snapshot already knows PKs.


---

C) Read endpoint (paging + sorting)

Request

{
  "targetDatabaseUrl":"postgresql://…",
  "schema":"public",
  "table":"users",
  "select":["id","email","created_at"],
  "where": { "q": "nick", "columns": ["email","name"] },
  "orderBy": [{ "column":"created_at", "dir":"desc" }],
  "limit": 50,
  "offset": 0
}

Response

{
  "columns":[{"name":"id","type":"uuid"}, ...],
  "rows":[{"id":"...","email":"..."}, ...],
  "page":{ "limit":50,"offset":0,"rowCountEstimate":12345 }
}


---

Backend code (Fastify + pg)

apps/api/src/routes/dataQuery.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';

function qident(id: string) { return `"${id.replace(/"/g,'""')}"`; }

export async function dataQueryRoutes(app: FastifyInstance) {
  app.post('/api/v1/data/query', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      schema: z.string().min(1),
      table: z.string().min(1),
      select: z.array(z.string().min(1)).optional(),
      where: z.object({
        q: z.string().min(1).optional(),
        columns: z.array(z.string().min(1)).optional(),
      }).optional(),
      orderBy: z.array(z.object({
        column: z.string().min(1),
        dir: z.enum(['asc','desc']).default('asc'),
      })).optional(),
      limit: z.number().int().min(1).max(200).default(50),
      offset: z.number().int().min(0).default(0),
    });

    const body = Body.parse(req.body);
    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      await pool.query(`SET statement_timeout = 8000`);

      // Columns (types) from information_schema (cheap)
      const colsRes = await pool.query(
        `
        SELECT column_name, data_type
        FROM information_schema.columns
        WHERE table_schema = $1 AND table_name = $2
        ORDER BY ordinal_position
        `,
        [body.schema, body.table],
      );

      const allCols = colsRes.rows.map((r: any) => String(r.column_name));
      const selectCols = (body.select?.length ? body.select : allCols).filter(c => allCols.includes(c));

      // Build SQL
      const params: any[] = [];
      let sql = `SELECT ${selectCols.map(c => qident(c)).join(', ')}
                 FROM ${qident(body.schema)}.${qident(body.table)}`;

      // Simple search filter (ILIKE)
      if (body.where?.q && body.where.columns?.length) {
        const q = body.where.q;
        const cols = body.where.columns.filter(c => allCols.includes(c));
        if (cols.length) {
          params.push(`%${q}%`);
          const p = `$${params.length}`;
          const ors = cols.map(c => `${qident(c)}::text ILIKE ${p}`).join(' OR ');
          sql += ` WHERE (${ors})`;
        }
      }

      // ORDER BY
      if (body.orderBy?.length) {
        const parts = body.orderBy
          .filter(o => allCols.includes(o.column))
          .map(o => `${qident(o.column)} ${o.dir.toUpperCase()}`);
        if (parts.length) sql += ` ORDER BY ${parts.join(', ')}`;
      }

      // paging
      params.push(body.limit);
      sql += ` LIMIT $${params.length}`;
      params.push(body.offset);
      sql += ` OFFSET $${params.length}`;

      const rowsRes = await pool.query(sql, params);

      return {
        columns: colsRes.rows.map((r: any) => ({ name: r.column_name, type: r.data_type })),
        rows: rowsRes.rows,
        page: { limit: body.limit, offset: body.offset, rowCountEstimate: null },
      };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}

Wire:

import { dataQueryRoutes } from './routes/dataQuery';
await app.register(dataQueryRoutes);


---

D) Update endpoint (PK required)

Request

{
  "targetDatabaseUrl":"postgresql://…",
  "schema":"public",
  "table":"users",
  "pk": { "id":"0c8..." },
  "set": { "email":"new@x.com", "name":"Nick" }
}

apps/api/src/routes/dataUpdate.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';

function qident(id: string) { return `"${id.replace(/"/g,'""')}"`; }

export async function dataUpdateRoutes(app: FastifyInstance) {
  app.post('/api/v1/data/row/update', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      schema: z.string().min(1),
      table: z.string().min(1),
      pk: z.record(z.any()).min(1),
      set: z.record(z.any()).min(1),
    });

    const body = Body.parse(req.body);
    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      await pool.query(`SET statement_timeout = 8000`);

      const setKeys = Object.keys(body.set);
      const pkKeys = Object.keys(body.pk);

      const params: any[] = [];
      const setParts = setKeys.map((k) => {
        params.push(body.set[k]);
        return `${qident(k)} = $${params.length}`;
      });

      const whereParts = pkKeys.map((k) => {
        params.push(body.pk[k]);
        return `${qident(k)} = $${params.length}`;
      });

      const sql = `
        UPDATE ${qident(body.schema)}.${qident(body.table)}
        SET ${setParts.join(', ')}
        WHERE ${whereParts.join(' AND ')}
        RETURNING *
      `;

      const res = await pool.query(sql, params);
      return { ok: true, row: res.rows?.[0] ?? null };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}


---

E) Insert endpoint

apps/api/src/routes/dataInsert.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';

function qident(id: string) { return `"${id.replace(/"/g,'""')}"`; }

export async function dataInsertRoutes(app: FastifyInstance) {
  app.post('/api/v1/data/row/insert', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      schema: z.string().min(1),
      table: z.string().min(1),
      values: z.record(z.any()).min(1),
    });

    const body = Body.parse(req.body);
    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      await pool.query(`SET statement_timeout = 8000`);

      const keys = Object.keys(body.values);
      const params: any[] = [];
      const cols = keys.map(qident).join(', ');
      const vals = keys.map((k) => {
        params.push(body.values[k]);
        return `$${params.length}`;
      }).join(', ');

      const sql = `
        INSERT INTO ${qident(body.schema)}.${qident(body.table)} (${cols})
        VALUES (${vals})
        RETURNING *
      `;

      const res = await pool.query(sql, params);
      return { ok: true, row: res.rows?.[0] ?? null };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}


---

F) Delete endpoint (PK required)

apps/api/src/routes/dataDelete.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';

function qident(id: string) { return `"${id.replace(/"/g,'""')}"`; }

export async function dataDeleteRoutes(app: FastifyInstance) {
  app.post('/api/v1/data/row/delete', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      schema: z.string().min(1),
      table: z.string().min(1),
      pk: z.record(z.any()).min(1),
    });

    const body = Body.parse(req.body);
    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      await pool.query(`SET statement_timeout = 8000`);

      const pkKeys = Object.keys(body.pk);
      const params: any[] = [];
      const whereParts = pkKeys.map((k) => {
        params.push(body.pk[k]);
        return `${qident(k)} = $${params.length}`;
      });

      const sql = `
        DELETE FROM ${qident(body.schema)}.${qident(body.table)}
        WHERE ${whereParts.join(' AND ')}
        RETURNING *
      `;

      const res = await pool.query(sql, params);
      return { ok: true, deleted: res.rows?.[0] ?? null };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}

Wire all:

await app.register(dataQueryRoutes);
await app.register(dataUpdateRoutes);
await app.register(dataInsertRoutes);
await app.register(dataDeleteRoutes);


---

G) Frontend Table Editor blueprint (minimal)

Left sidebar

connection → schema → table tree (from snapshot)

click table opens editor tab


Main

top bar: search, filters, “Insert row”, “Refresh”, “Read-only toggle”

grid: virtualized table (TanStack Table + TanStack Virtual)

row click: opens right drawer with editable form

save triggers /row/update

delete triggers confirm + /row/delete


Read-only mode

disables update/insert/delete buttons

can be default true for safety



---

Next (3.3.21)

FK-aware data entry:

dropdowns for FK columns (autocomplete)

“create referenced row” shortcut

default value helpers + type-specific inputs

3.3.21 FK-aware data entry (dropdowns + autocomplete + “create referenced row”)

This turns your table editor from “generic grid” into “database GUI”.

We’ll ship v1 FK awareness as:

✅ FK columns render as lookup inputs (typeahead)

✅ resolves display labels (choose a “display column”)

✅ supports composite FKs (basic)

✅ “Open referenced row” and “Create referenced row” shortcuts



---

A) What the editor needs from introspection

From your CatalogSnapshot.relationships you already have:

childKey = schema.table

childCols[]

parentKey

parentCols[]


We build a per-table FK map:

type FkMap = Record<
  string, // childTableKey
  Array<{
    relKey: string;
    childCols: string[];
    parentTable: string; // schema.table
    parentCols: string[];
  }>
>;

apps/web/src/erd/fkMap.ts

export function buildFkMap(relationships: Record<string, any>) {
  const m: Record<string, any[]> = {};
  for (const r of Object.values(relationships)) {
    const child = r.childKey;
    (m[child] ??= []).push({
      relKey: r.key,
      childCols: r.childCols,
      parentTable: r.parentKey,
      parentCols: r.parentCols,
    });
  }
  return m;
}


---

B) Two endpoints to power lookup inputs

1) Lookup candidates (typeahead)

POST /api/v1/data/lookup

Body:

{
  "targetDatabaseUrl":"postgresql://…",
  "table":"public.users",
  "pkCols":["id"],
  "labelCols":["email","name"],
  "q":"nick",
  "limit": 20
}

Response:

{
  "items":[
    { "pk": { "id":"..." }, "label":"nick@x.com — Nick Brennan", "row": { ...optional } }
  ]
}

2) Fetch display label by PK (for existing FK values)

POST /api/v1/data/lookup/by-pk Body:

{
  "targetDatabaseUrl":"postgresql://…",
  "table":"public.users",
  "pk": {"id":"..."},
  "labelCols":["email","name"]
}


---

C) Backend: lookup endpoint (safe + indexed friendly)

apps/api/src/routes/dataLookup.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';

function qident(id: string) { return `"${id.replace(/"/g,'""')}"`; }

export async function dataLookupRoutes(app: FastifyInstance) {
  app.post('/api/v1/data/lookup', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      table: z.string().min(3),     // "schema.table"
      pkCols: z.array(z.string().min(1)).min(1),
      labelCols: z.array(z.string().min(1)).min(1),
      q: z.string().optional(),
      limit: z.number().int().min(1).max(50).default(20),
    });

    const body = Body.parse(req.body);
    const [schema, table] = body.table.split('.');
    if (!schema || !table) throw new Error('Invalid table key');

    const pool = createTargetPool(body.targetDatabaseUrl);
    try {
      await pool.query(`SET statement_timeout = 8000`);

      const cols = Array.from(new Set([...body.pkCols, ...body.labelCols]));
      const selectList = cols.map(c => qident(c)).join(', ');

      const params: any[] = [];
      let sql = `SELECT ${selectList} FROM ${qident(schema)}.${qident(table)}`;

      if (body.q && body.q.trim().length) {
        params.push(`%${body.q.trim()}%`);
        const p = `$${params.length}`;
        const ors = body.labelCols.map(c => `${qident(c)}::text ILIKE ${p}`).join(' OR ');
        sql += ` WHERE (${ors})`;
      }

      params.push(body.limit);
      sql += ` ORDER BY 1 LIMIT $${params.length}`;

      const res = await pool.query(sql, params);

      const items = (res.rows ?? []).map((row: any) => {
        const pk: any = {};
        for (const c of body.pkCols) pk[c] = row[c];

        const label = body.labelCols
          .map(c => row[c])
          .filter(v => v !== null && v !== undefined && String(v).length)
          .join(' — ');

        return { pk, label, row };
      });

      return { items };
    } finally {
      await pool.end().catch(() => {});
    }
  });

  app.post('/api/v1/data/lookup/by-pk', async (req) => {
    const Body = z.object({
      targetDatabaseUrl: z.string().min(10),
      table: z.string().min(3),
      pk: z.record(z.any()).min(1),
      labelCols: z.array(z.string().min(1)).min(1),
    });

    const body = Body.parse(req.body);
    const [schema, table] = body.table.split('.');
    if (!schema || !table) throw new Error('Invalid table key');

    const pool = createTargetPool(body.targetDatabaseUrl);
    try {
      await pool.query(`SET statement_timeout = 8000`);

      const pkKeys = Object.keys(body.pk);
      const params: any[] = [];
      const where = pkKeys.map((k) => {
        params.push(body.pk[k]);
        return `${qident(k)} = $${params.length}`;
      });

      const selectList = Array.from(new Set([...pkKeys, ...body.labelCols])).map(qident).join(', ');
      const sql = `
        SELECT ${selectList}
        FROM ${qident(schema)}.${qident(table)}
        WHERE ${where.join(' AND ')}
        LIMIT 1
      `;

      const res = await pool.query(sql, params);
      const row = res.rows?.[0] ?? null;

      if (!row) return { item: null };

      const label = body.labelCols
        .map(c => row[c])
        .filter(v => v !== null && v !== undefined && String(v).length)
        .join(' — ');

      const pkOut: any = {};
      for (const k of pkKeys) pkOut[k] = row[k];

      return { item: { pk: pkOut, label, row } };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}

Wire:

await app.register(dataLookupRoutes);


---

D) Frontend: render FK fields as “LookupInput”

Determine if a column is FK

When editing a table row:

for each column c.name

find FK relationship where childCols contains c.name

if yes → use lookup


For composite FK:

treat the first column as the “driver” input

selecting a row fills all involved childCols


apps/web/src/tableEditor/isFkColumn.ts

export function findFkForColumn(args: {
  fkList: Array<{ childCols: string[]; parentTable: string; parentCols: string[]; relKey: string }>;
  colName: string;
}) {
  return args.fkList.find(fk => fk.childCols.includes(args.colName)) ?? null;
}


---

E) Choosing label columns (the “display column” heuristic)

We need a default label column(s) for lookup tables.

Heuristic (v1):

1. if has name → use name


2. else if has title → use title


3. else if has email → use email


4. else first non-PK text/varchar column


5. fallback to PK



You can compute this from snapshot columns for that parent table.


---

F) “Create referenced row” flow

In the FK dropdown:

button: “+ Create”

opens Insert modal for the parent table

on insert success, auto-select it (fills FK childCols)


This is just reuse of /row/insert.


---

G) Safety / performance knobs

lookup limit max 50

statement timeout 8s

optional: require at least 2–3 chars before querying

debounce 250–400ms



---

Next (3.3.22)

Change tracking / audit trail hooks:

log writes (update/insert/delete) in app DB

show “recent edits” panel

enable undo for simple updates
