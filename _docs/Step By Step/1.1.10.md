## Step 1.1.10 — Issues Queue + Dashboard Binding (exact)

Goal: surface **actionable problems first** and make the dashboard
a true operational control panel.

This step binds checklist runtime → dashboard UI.

---

# 1.1.10a) Issues queue contract

Flatten results into an ordered list:

```ts
type Issue = {
  resultId: string;
  severity: "blocking" | "error" | "warning" | "info";
  section: string;
  title: string;
  detail?: string;
  targetRef: TargetRef;
  fixAction?: any;
  deepLink: any;
};
```

---

# 1.1.10b) Ordering rules

Default order:
1) Blocking
2) Errors
3) Warnings
4) Info

Secondary sort:
- relationship issues before table issues
- large-table impact first (if stats exist)

---

# 1.1.10c) Dashboard binding

Dashboard reads:
- checklist_instance.status
- checklist_instance.counts
- issues queue

Dashboard components:
- Readiness hero card
- Section scorecards
- Issues work queue
- Quick actions panel

No dashboard state is computed in frontend.

---

# 1.1.10d) Gating rules

Apply button:
- disabled if any BLOCKED issues exist
- optionally disabled on FAIL in prod

Quick actions visibility:
- Fix actions shown only when available
- Run checks always available

---

# Done criteria for 1.1.10

✅ Issues queue ordered and filterable  
✅ Dashboard derives state from instance only  
✅ Apply gating enforced consistently  
✅ Clicking issue deep-links to ERD spotlight  

---
