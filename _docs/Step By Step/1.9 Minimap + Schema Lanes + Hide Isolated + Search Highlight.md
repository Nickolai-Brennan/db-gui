## 1.9 Minimap + Schema Lanes + Hide Isolated + Search Highlight

This upgrade makes large ERDs manageable:
✅ minimap (pan/zoom overview)
✅ schema lanes (group by schema, optional swimlanes)
✅ hide isolated tables (no FKs)
✅ search highlight + dim non-matches

---

# A) Store updates (filters + minimap state)

### Patch `apps/web/src/stores/erdStore.ts`

Add to types:

```ts
filters: {
  schemas: string[];      // active schemas (empty = all)
  search: string;         // query
  hideIsolated: boolean;  // toggle
  showSchemaLanes: boolean;
  showMinimap: boolean;
};
setFilters: (patch: Partial<ErdStore['filters']>) => void;
```

Add implementation:

```ts
filters: {
  schemas: [],
  search: '',
  hideIsolated: false,
  showSchemaLanes: true,
  showMinimap: true,
},
setFilters: (patch) => set((s) => ({ filters: { ...s.filters, ...patch } })),
```

---

# B) Graph helpers (isolated detection + filtering)

Create `apps/web/src/erd/filtering.ts`

```ts
import type { Edge, TableNode } from './graph';

export function buildDegreeMap(nodes: TableNode[], edges: Edge[]) {
  const deg = new Map<string, number>();
  for (const n of nodes) deg.set(n.key, 0);
  for (const e of edges) {
    deg.set(e.childKey, (deg.get(e.childKey) ?? 0) + 1);
    deg.set(e.parentKey, (deg.get(e.parentKey) ?? 0) + 1);
  }
  return deg;
}

export function matchesSearch(node: TableNode, q: string) {
  const s = q.trim().toLowerCase();
  if (!s) return true;
  if (node.key.toLowerCase().includes(s)) return true;
  if (node.table.toLowerCase().includes(s)) return true;
  // columns (cheap)
  return node.columns.some((c) => c.name.toLowerCase().includes(s));
}

export function filterGraph(
  nodes: TableNode[],
  edges: Edge[],
  opts: { activeSchemas: string[]; hideIsolated: boolean; search: string },
) {
  const deg = buildDegreeMap(nodes, edges);

  const schemaSet = new Set(opts.activeSchemas ?? []);
  const useSchemaFilter = schemaSet.size > 0;

  const keptNodes = nodes.filter((n) => {
    if (useSchemaFilter && !schemaSet.has(n.schema)) return false;
    if (opts.hideIsolated && (deg.get(n.key) ?? 0) === 0) return false;
    return true;
  });

  const keptKeys = new Set(keptNodes.map((n) => n.key));

  const keptEdges = edges.filter((e) => keptKeys.has(e.childKey) && keptKeys.has(e.parentKey));

  // search doesn't remove nodes by default; it highlights.
  // But we return matchMap to dim non-matches.
  const matchMap = new Map<string, boolean>();
  const q = opts.search ?? '';
  for (const n of keptNodes) matchMap.set(n.key, matchesSearch(n, q));

  return { nodes: keptNodes, edges: keptEdges, matchMap };
}
```

---

# C) Schema lanes (visual swimlanes)

Create `apps/web/src/erd/SchemaLanes.tsx`

```tsx
import type { Rect } from '../stores/erdStore';

export function SchemaLanes({
  schemas,
  laneRects,
}: {
  schemas: string[];
  laneRects: Record<string, { x: number; w: number }>;
}) {
  return (
    <div className="absolute inset-0 pointer-events-none">
      {schemas.map((s) => {
        const r = laneRects[s];
        if (!r) return null;
        return (
          <div
            key={s}
            style={{ position: 'absolute', left: r.x, top: 0, width: r.w, height: 6000 }}
            className="border-r border-zinc-200/70"
          >
            <div className="sticky top-0">
              <div className="inline-block mt-3 ml-3 px-2 py-1 rounded-lg border border-zinc-200 bg-white text-xs text-zinc-600">
                {s}
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
}
```

Lane rectangles are derived from your layout (x positions).

Create helper `apps/web/src/erd/lanes.ts`

```ts
import type { Rect } from '../stores/erdStore';

export function computeSchemaLanes(
  tableKeys: string[],
  schemaByKey: Record<string, string>,
  layout: Record<string, Rect>,
) {
  const lane = new Map<string, { minX: number; maxX: number }>();

  for (const k of tableKeys) {
    const s = schemaByKey[k] ?? 'public';
    const r = layout[k];
    if (!r) continue;

    const cur = lane.get(s);
    const minX = r.x;
    const maxX = r.x + r.w;

    if (!cur) lane.set(s, { minX, maxX });
    else lane.set(s, { minX: Math.min(cur.minX, minX), maxX: Math.max(cur.maxX, maxX) });
  }

  const schemas = Array.from(lane.keys()).sort();
  const laneRects: Record<string, { x: number; w: number }> = {};
  for (const s of schemas) {
    const r = lane.get(s)!;
    laneRects[s] = { x: r.minX - 60, w: (r.maxX - r.minX) + 120 };
  }

  return { schemas, laneRects };
}
```

---

# D) Minimap (overview + click-to-pan)

Create `apps/web/src/erd/Minimap.tsx`

```tsx
import { useMemo } from 'react';
import { useErdStore } from '../stores/erdStore';
import type { Rect } from '../stores/erdStore';

function boundsOf(layout: Record<string, Rect>, keys: string[]) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const k of keys) {
    const r = layout[k];
    if (!r) continue;
    minX = Math.min(minX, r.x);
    minY = Math.min(minY, r.y);
    maxX = Math.max(maxX, r.x + r.w);
    maxY = Math.max(maxY, r.y + r.h);
  }
  if (!isFinite(minX)) return { minX: 0, minY: 0, maxX: 1, maxY: 1 };
  return { minX, minY, maxX, maxY };
}

export function Minimap({ tableKeys }: { tableKeys: string[] }) {
  const layout = useErdStore((s) => s.layout);
  const viewport = useErdStore((s) => s.viewport);
  const setViewport = useErdStore((s) => s.setViewport);

  const W = 220;
  const H = 160;

  const b = useMemo(() => boundsOf(layout, tableKeys), [layout, tableKeys]);
  const worldW = Math.max(1, b.maxX - b.minX);
  const worldH = Math.max(1, b.maxY - b.minY);

  const scale = Math.min(W / worldW, H / worldH);

  const viewRect = useMemo(() => {
    // viewport is screen -> world transform: world = (screen - vp.xy) / vp.zoom
    // We approximate viewport window as 1000x700 in screen space (good enough v1)
    const screenW = 1000;
    const screenH = 700;

    const wx = (0 - viewport.x) / viewport.zoom;
    const wy = (0 - viewport.y) / viewport.zoom;
    const ww = screenW / viewport.zoom;
    const wh = screenH / viewport.zoom;

    return { wx, wy, ww, wh };
  }, [viewport]);

  return (
    <div className="absolute bottom-3 right-3 z-30 rounded-2xl border border-zinc-200 bg-white shadow-sm p-2">
      <div className="text-[11px] font-semibold text-zinc-700 px-1 pb-1">Minimap</div>
      <svg
        width={W}
        height={H}
        style={{ display: 'block' }}
        onClick={(e) => {
          const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const wx = b.minX + x / scale;
          const wy = b.minY + y / scale;

          // center minimap click into viewport
          const screenW = 1000;
          const screenH = 700;
          setViewport({
            x: screenW / 2 - wx * viewport.zoom,
            y: screenH / 2 - wy * viewport.zoom,
          });
        }}
      >
        {/* nodes */}
        {tableKeys.map((k) => {
          const r = layout[k];
          if (!r) return null;
          return (
            <rect
              key={k}
              x={(r.x - b.minX) * scale}
              y={(r.y - b.minY) * scale}
              width={Math.max(2, r.w * scale)}
              height={Math.max(2, r.h * scale)}
              fill="rgba(0,0,0,0.10)"
              stroke="rgba(0,0,0,0.20)"
            />
          );
        })}

        {/* viewport window */}
        <rect
          x={(viewRect.wx - b.minX) * scale}
          y={(viewRect.wy - b.minY) * scale}
          width={viewRect.ww * scale}
          height={viewRect.wh * scale}
          fill="rgba(0,0,0,0.06)"
          stroke="rgba(0,0,0,0.45)"
        />
      </svg>
    </div>
  );
}
```

---

# E) TopBar controls (schema filter + toggles + search)

Create `apps/web/src/erd/TopControls.tsx`

```tsx
import { useMemo } from 'react';
import { useErdStore } from '../stores/erdStore';

export function TopControls({ schemasAll }: { schemasAll: string[] }) {
  const filters = useErdStore((s) => s.filters);
  const setFilters = useErdStore((s) => s.setFilters);

  const active = new Set(filters.schemas);

  return (
    <div className="flex items-center gap-2">
      <input
        className="w-[260px] px-3 py-1.5 rounded-xl border border-zinc-200 text-sm"
        placeholder="Search tables / columns…"
        value={filters.search}
        onChange={(e) => setFilters({ search: e.target.value })}
      />

      <button
        className="px-3 py-1.5 rounded-xl border border-zinc-200 text-sm"
        onClick={() => setFilters({ hideIsolated: !filters.hideIsolated })}
      >
        {filters.hideIsolated ? 'Show isolated' : 'Hide isolated'}
      </button>

      <button
        className="px-3 py-1.5 rounded-xl border border-zinc-200 text-sm"
        onClick={() => setFilters({ showSchemaLanes: !filters.showSchemaLanes })}
      >
        {filters.showSchemaLanes ? 'Lanes on' : 'Lanes off'}
      </button>

      <button
        className="px-3 py-1.5 rounded-xl border border-zinc-200 text-sm"
        onClick={() => setFilters({ showMinimap: !filters.showMinimap })}
      >
        {filters.showMinimap ? 'Minimap on' : 'Minimap off'}
      </button>

      {/* Schema chips (simple) */}
      <div className="flex items-center gap-1 ml-2">
        {schemasAll.slice(0, 8).map((s) => {
          const on = active.has(s);
          return (
            <button
              key={s}
              className={[
                'px-2 py-1 rounded-xl text-xs border',
                on ? 'bg-black text-white border-black' : 'bg-white border-zinc-200 text-zinc-700',
              ].join(' ')}
              onClick={() => {
                const next = new Set(filters.schemas);
                if (next.has(s)) next.delete(s);
                else next.add(s);
                setFilters({ schemas: Array.from(next) });
              }}
            >
              {s}
            </button>
          );
        })}
      </div>
    </div>
  );
}
```

---

# F) Patch `ErdCanvas` to apply filtering + dim non-matches + render lanes + minimap

## 1.9.01 Update nodes layer props to support “dim”

Patch `TableNodeCard` to accept `dim?: boolean` and apply opacity.

In `apps/web/src/erd/TableNode.tsx` signature:

```tsx
export function TableNodeCard({ node, highlightCols, dim }: { node: TableNode; highlightCols?: string[]; dim?: boolean }) {
```

Apply to wrapper class:

```tsx
className={[
  'rounded-2xl bg-white shadow-sm border overflow-hidden select-none',
  isSelected ? 'border-black' : 'border-zinc-200',
  dim ? 'opacity-30' : '',
].join(' ')}
```

## 1.9.02 Patch `ErdCanvas.tsx` (key parts)

Add imports:

```tsx
import { filterGraph } from './filtering';
import { useErdStore } from '../stores/erdStore';
import { computeSchemaLanes } from './lanes';
import { SchemaLanes } from './SchemaLanes';
import { Minimap } from './Minimap';
```

Inside component:

```tsx
const filters = useErdStore((s) => s.filters);
```

Build filtered view:

```tsx
const filtered = useMemo(() => {
  return filterGraph(nodes, edges, {
    activeSchemas: filters.schemas,
    hideIsolated: filters.hideIsolated,
    search: filters.search,
  });
}, [nodes, edges, filters.schemas, filters.hideIsolated, filters.search]);

const { nodes: visNodes, edges: visEdges, matchMap } = filtered;
```

Use `visNodes/visEdges` everywhere instead of `nodes/edges`:

* edgePaths memo should loop over `visEdges`
* nodes layer should render `visNodes`

Compute lanes:

```tsx
const laneInfo = useMemo(() => {
  if (!filters.showSchemaLanes) return null;
  return computeSchemaLanes(visNodes.map((n) => n.key), Object.fromEntries(visNodes.map((n) => [n.key, n.schema])), layout);
}, [filters.showSchemaLanes, visNodes, layout]);
```

Render lanes inside stage (before edges):

```tsx
{laneInfo ? <SchemaLanes schemas={laneInfo.schemas} laneRects={laneInfo.laneRects} /> : null}
```

Render minimap outside stage:

```tsx
{filters.showMinimap ? <Minimap tableKeys={visNodes.map((n) => n.key)} /> : null}
```

When rendering nodes:

```tsx
{visNodes.map((n) => {
  const hl =
    hoverEdge && (hoverEdge.childKey === n.key || hoverEdge.parentKey === n.key)
      ? (hoverEdge.childKey === n.key ? hoverEdge.childCols : hoverEdge.parentCols)
      : undefined;

  const isMatch = matchMap.get(n.key) ?? true;
  const dim = filters.search.trim() ? !isMatch : false;

  return <TableNodeCard key={n.key} node={n} highlightCols={hl} dim={dim} />;
})}
```

---

# G) Patch `ErdPage` to use TopControls

In `apps/web/src/pages/ErdPage.tsx`, import:

```tsx
import { TopControls } from '../erd/TopControls';
```

When graph loaded, compute schema list:

```tsx
const schemasAll = useMemo(() => {
  if (!graph) return [];
  return Array.from(new Set(graph.nodes.map((n) => n.schema))).sort();
}, [graph]);
```

Replace your top bar right-side buttons area with:

```tsx
{graph ? <TopControls schemasAll={schemasAll} /> : null}
```

Keep your Connection + Auto layout buttons if you want; just place them next to controls or keep them on the far right.

---

# ✅ 1.9 Definition of Done

* Minimap shows nodes + viewport window; click pans
* Schema lanes can be toggled
* Hide isolated tables works
* Search highlights matches and dims non-matches
* Filtering affects edges (only show edges between visible nodes)

---

## Next upgrade after 1.9 (best options)

* **2.0 ELK/dagre auto-layout** for very large schemas
* **2.1 Persist filters per workspace**
* **2.2 “Column-level edge anchors” + edge bundling** (even cleaner on dense graphs)
