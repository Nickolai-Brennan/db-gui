## Step 1.1.04 — Migration Preflight Orchestrator (Apply Gate) (exact)

Goal: the “Apply changes” flow must be **trustworthy**.

This step builds the coordinator that:
- runs preflight checks in the correct order
- blocks apply when checks fail
- stores a preflight report on the migration run
- feeds Dashboard gating

Reference: ERD Spec v1 Part 4 (Safety & Apply). fileciteturn0file7

---

# 1.1.04a) Define preflight result contract

Use a stable contract:

```ts
export type PreflightStatus = "clear" | "blocked";

export type PreflightCheckResult = {
  checkId: string;              // NOT_NULL_PRECHECK, UNIQUE_PRECHECK, FK_VIOLATIONS_PRECHECK, etc.
  severity: "warning" | "blocking";
  targetRef?: any;              // TargetRef (table/column/relationship) if applicable
  message: string;
  sampleRows?: any[];           // cap to e.g. 50
  stats?: Record<string, number>;
};

export type PreflightReport = {
  status: PreflightStatus;
  results: PreflightCheckResult[];
  createdAt: string;
};
```

---

# 1.1.04b) Determine checks from migration steps

Given a `MigrationPlan.steps[]`, compute checks:

- `ALTER COLUMN SET NOT NULL` → NOT NULL precheck
- `ADD UNIQUE` → duplicates precheck
- `ADD FK` → FK violations precheck
- Large-table operations → warning / scheduling hint

This mapping must be deterministic (same plan → same preflight set).

---

# 1.1.04c) Orchestrator behavior (exact)

Rules:
- run checks in step order (mirrors apply)
- stop early on first blocking failure (fast feedback)
- record all warnings (optional) but don’t block unless severity=blocking
- cap runtime per check and cap sample row output

Pseudo-code:

```ts
async function runPreflight(plan): Promise<PreflightReport> {
  const results = [];

  for (const step of plan.steps) {
    for (const check of checksFor(step)) {
      const res = await check.run();
      results.push(res);

      if (res.severity === "blocking") {
        return { status: "blocked", results, createdAt: new Date().toISOString() };
      }
    }
  }

  return { status: "clear", results, createdAt: new Date().toISOString() };
}
```

---

# 1.1.04d) Apply gating

Apply flow:
1) User clicks Apply
2) System runs preflight
3) If blocked:
   - Apply disabled
   - show remediation actions (open violations, backfill, etc.)
4) If clear:
   - Apply enabled

Persist:
- `migration_run.preflight_report`
- `migration_run.status`
- applied SQL (if executed)

---

# 1.1.04e) Index concurrently rule (Postgres gotcha)

`CREATE INDEX CONCURRENTLY` cannot run in a transaction.

Implementation:
- Phase A: transactional DDL
- Phase B: concurrent indexes outside transaction
- Phase C: constraints after indexes

If you don’t support concurrently in v1, you must:
- warn on large tables
- require explicit confirm for non-concurrent index on large tables

---

# Done criteria for 1.1.04

✅ Preflight report blocks apply on real violations  
✅ Preflight report stored in `migration_run`  
✅ Dashboard/Checklist can gate “Apply” using preflight outcomes  
✅ Apply flow respects Postgres CONCURRENTLY rule (or warns clearly)

---
