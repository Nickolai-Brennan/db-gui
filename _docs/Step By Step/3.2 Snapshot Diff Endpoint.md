Next — 3.2 Snapshot Diff Endpoint (added/removed/changed)

This gives you a UI-ready drift report so the ERD page can show:

“+2 tables, -1 relationship, 5 columns changed”

highlight affected tables

optionally prompt user to refresh layout


We’ll implement:

✅ POST /api/v1/introspect/postgres/diff
✅ compares latest persisted snapshot vs fresh snapshot (or vs a provided signature)
✅ returns added/removed keys + changed tables (columns/indexes/fks differences)
✅ uses stable keys you already standardized (schema.table, schema.table.column, relationship signature)


---

1) Diff model

apps/api/src/introspection/diffTypes.ts

export type SnapshotDiff = {
  meta: {
    connectionKey: string;
    schemas: string[];
    previousCapturedAt: string | null;
    currentCapturedAt: string;
    previousSignature: string | null;
    currentSignature: string;
    changed: boolean;
  };

  tables: { added: string[]; removed: string[]; changed: string[] };
  columns: { added: string[]; removed: string[] };
  relationships: { added: string[]; removed: string[] };
  indexes: { added: string[]; removed: string[] };

  // Table-level details (only for changed tables)
  tableDetails: Record<string, {
    columnsAdded: string[];
    columnsRemoved: string[];
    relationshipsAdded: string[];
    relationshipsRemoved: string[];
    indexesAdded: string[];
    indexesRemoved: string[];
  }>;
};


---

2) Diff utility

apps/api/src/introspection/diff.ts

import type { CatalogSnapshot } from './types';
import type { SnapshotDiff } from './diffTypes';

function toSet(keys: string[]) {
  return new Set(keys);
}

function setDiff(a: Set<string>, b: Set<string>) {
  // a - b
  const out: string[] = [];
  for (const k of a) if (!b.has(k)) out.push(k);
  return out.sort();
}

function setIntersect(a: Set<string>, b: Set<string>) {
  const out: string[] = [];
  for (const k of a) if (b.has(k)) out.push(k);
  return out;
}

function tableKeyOfColumn(colKey: string) {
  // "schema.table.column" -> "schema.table"
  const parts = colKey.split('.');
  return parts.length >= 2 ? `${parts[0]}.${parts[1]}` : colKey;
}

function tablesTouchedByRelationship(relKey: string) {
  // "s.t(a)->p.q(b)" but our relKey is "childKey(cols) -> parentKey(cols)"
  // safest: parse by ' -> '
  const [left, right] = relKey.split(' -> ').map(s => s.trim());
  const child = left?.split('(')[0]?.trim();
  const parent = right?.split('(')[0]?.trim();
  return [child, parent].filter(Boolean) as string[];
}

export function diffSnapshots(args: {
  connectionKey: string;
  schemas: string[];
  previous: CatalogSnapshot | null;
  previousSignature: string | null;
  previousCapturedAt: string | null;

  current: CatalogSnapshot;
  currentSignature: string;
  currentCapturedAt: string;
}): SnapshotDiff {
  const prev = args.previous;
  const cur = args.current;

  const prevTables = toSet(prev ? Object.keys(prev.tables) : []);
  const curTables = toSet(Object.keys(cur.tables));

  const prevCols = toSet(prev ? Object.keys(prev.columns) : []);
  const curCols = toSet(Object.keys(cur.columns));

  const prevRels = toSet(prev ? Object.keys(prev.relationships) : []);
  const curRels = toSet(Object.keys(cur.relationships));

  const prevIdx = toSet(prev ? Object.keys(prev.indexes) : []);
  const curIdx = toSet(Object.keys(cur.indexes));

  const tablesAdded = setDiff(curTables, prevTables);
  const tablesRemoved = setDiff(prevTables, curTables);

  const colsAdded = setDiff(curCols, prevCols);
  const colsRemoved = setDiff(prevCols, curCols);

  const relsAdded = setDiff(curRels, prevRels);
  const relsRemoved = setDiff(prevRels, curRels);

  const idxAdded = setDiff(curIdx, prevIdx);
  const idxRemoved = setDiff(prevIdx, curIdx);

  // Table details: map changes back to table keys
  const tableDetails: SnapshotDiff['tableDetails'] = {};
  const touchedTables = new Set<string>();

  for (const c of colsAdded) touchedTables.add(tableKeyOfColumn(c));
  for (const c of colsRemoved) touchedTables.add(tableKeyOfColumn(c));

  for (const r of relsAdded) for (const t of tablesTouchedByRelationship(r)) touchedTables.add(t);
  for (const r of relsRemoved) for (const t of tablesTouchedByRelationship(r)) touchedTables.add(t);

  for (const i of idxAdded) touchedTables.add(i.split('.').slice(0, 2).join('.'));
  for (const i of idxRemoved) touchedTables.add(i.split('.').slice(0, 2).join('.'));

  for (const t of touchedTables) {
    tableDetails[t] = {
      columnsAdded: colsAdded.filter((k) => tableKeyOfColumn(k) === t),
      columnsRemoved: colsRemoved.filter((k) => tableKeyOfColumn(k) === t),
      relationshipsAdded: relsAdded.filter((k) => tablesTouchedByRelationship(k).includes(t)),
      relationshipsRemoved: relsRemoved.filter((k) => tablesTouchedByRelationship(k).includes(t)),
      indexesAdded: idxAdded.filter((k) => k.startsWith(`${t}.`)),
      indexesRemoved: idxRemoved.filter((k) => k.startsWith(`${t}.`)),
    };
  }

  // Changed tables = existing tables that have any detail changes
  const existing = setIntersect(curTables, prevTables);
  const changedTables = existing
    .filter((t) => {
      const d = tableDetails[t];
      return d && (
        d.columnsAdded.length || d.columnsRemoved.length ||
        d.relationshipsAdded.length || d.relationshipsRemoved.length ||
        d.indexesAdded.length || d.indexesRemoved.length
      );
    })
    .sort();

  const changed = args.previousSignature ? args.previousSignature !== args.currentSignature : (tablesAdded.length + tablesRemoved.length + colsAdded.length + colsRemoved.length + relsAdded.length + relsRemoved.length + idxAdded.length + idxRemoved.length) > 0;

  return {
    meta: {
      connectionKey: args.connectionKey,
      schemas: args.schemas,
      previousCapturedAt: args.previousCapturedAt,
      currentCapturedAt: args.currentCapturedAt,
      previousSignature: args.previousSignature,
      currentSignature: args.currentSignature,
      changed,
    },
    tables: { added: tablesAdded, removed: tablesRemoved, changed: changedTables },
    columns: { added: colsAdded, removed: colsRemoved },
    relationships: { added: relsAdded, removed: relsRemoved },
    indexes: { added: idxAdded, removed: idxRemoved },
    tableDetails,
  };
}


---

3) Diff endpoint route

apps/api/src/routes/introspectDiff.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';
import { fetchCatalogSnapshot } from '../introspection/snapshot';
import { computeSnapshotSignature } from '../introspection/signature';
import { loadLatestSnapshot } from '../introspection/persist';
import { diffSnapshots } from '../introspection/diff';
import { appDb } from '../services/appDb';

function normalizeSchemas(schemas: string[]) {
  return schemas.slice().map(s => s.trim()).filter(Boolean).sort();
}

function makeConnectionKey(body: { connectionId?: string; targetDatabaseUrl: string }) {
  return body.connectionId ? `conn:${body.connectionId}` : `url:${body.targetDatabaseUrl}`;
}

export async function introspectDiffRoutes(app: FastifyInstance) {
  app.post('/api/v1/introspect/postgres/diff', async (req) => {
    const Body = z.object({
      workspaceId: z.string().uuid().optional(),
      connectionId: z.string().uuid().optional(),
      targetDatabaseUrl: z.string().min(10),
      schemas: z.array(z.string().min(1)).min(1),

      // optional: compare against specific stored snapshot signature later
      // previousSignature: z.string().optional()
      refreshCurrent: z.enum(['fresh', 'cache']).default('fresh')
    });

    const body = Body.parse(req.body);
    const schemas = normalizeSchemas(body.schemas);
    const connectionKey = makeConnectionKey(body);

    // Previous = latest persisted snapshot
    const prev = await loadLatestSnapshot({ appDb, connectionKey, schemas });

    // Current = fresh introspection (v1)
    const pool = createTargetPool(body.targetDatabaseUrl);
    try {
      const current = await fetchCatalogSnapshot(pool, schemas);
      const currentSig = computeSnapshotSignature(current);

      const diff = diffSnapshots({
        connectionKey,
        schemas,
        previous: prev?.snapshot ?? null,
        previousSignature: prev?.signature ?? null,
        previousCapturedAt: prev?.capturedAt ?? null,
        current,
        currentSignature: currentSig,
        currentCapturedAt: current.meta.capturedAt,
      });

      return { diff };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}

Wire it in apps/api/src/index.ts:

import { introspectDiffRoutes } from './routes/introspectDiff';
await app.register(introspectDiffRoutes);


---

4) Frontend usage pattern

On ERD load:

1. call /snapshot with refresh:"cache"


2. optionally call /diff in background



If diff.meta.changed === true:

show banner: “Schema changed since last refresh”

show quick counts:

tables.added.length, tables.removed.length, tables.changed.length


“Refresh now” button calls /snapshot with refresh:"force"




---

Next after this

If you say Next again, best move is “visible-only refresh v1.5”:

accept visibleTables[]

fetch metadata only for those tables (columns/constraints/indexes) to speed up ERD while panning/zooming.
