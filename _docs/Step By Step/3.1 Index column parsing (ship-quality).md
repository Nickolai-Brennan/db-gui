## 3.1 Index column parsing (ship-quality)

Right now we’re storing indexes with columns: []. This “next” makes index metadata actually usable for checks like:

FK columns missing index

Composite index coverage ((a,b) vs just a)

Partial index awareness (predicate)

Expression indexes (store expression text)


We’ll implement it the right way using pg_index.indkey + pg_attribute + pg_get_indexdef(), not fragile regex.


---

3.1.XX Index parsing upgrade

A) Update the indexes query (returns column names + expressions)

Replace the index query in fetchCatalogSnapshot() with this:

const idxRes = await pool.query(
  `
  SELECT
    n.nspname AS schema,
    t.relname AS table,
    i.relname AS name,
    am.amname AS method,
    ix.indisunique AS is_unique,
    ix.indisprimary AS is_primary,
    ix.indkey AS indkey,
    ix.indnkeyatts AS indnkeyatts,
    pg_get_indexdef(i.oid) AS indexdef,
    pg_get_expr(ix.indpred, ix.indrelid) AS predicate,

    -- index columns (for simple column indexes)
    array_remove(array_agg(a.attname ORDER BY x.ord), NULL) AS attnames,

    -- index expressions (for expression indexes)
    array_remove(array_agg(pg_get_indexdef(i.oid, x.ord, true) ORDER BY x.ord), NULL) AS exprs

  FROM pg_index ix
  JOIN pg_class t ON t.oid = ix.indrelid
  JOIN pg_class i ON i.oid = ix.indexrelid
  JOIN pg_namespace n ON n.oid = t.relnamespace
  JOIN pg_am am ON am.oid = i.relam

  -- ordinals for index keys (1..indnatts)
  JOIN LATERAL generate_subscripts(ix.indkey, 1) AS x(ord) ON true

  -- map indkey attnums to attnames (0 = expression)
  LEFT JOIN pg_attribute a
    ON a.attrelid = t.oid
   AND a.attnum = ix.indkey[x.ord]
   AND ix.indkey[x.ord] <> 0

  WHERE n.nspname = ANY($1::text[])
  GROUP BY
    n.nspname, t.relname, i.relname, am.amname,
    ix.indisunique, ix.indisprimary, ix.indkey, ix.indnkeyatts,
    i.oid, ix.indpred, ix.indrelid
  ORDER BY 1,2,3
  `,
  [schemas],
);

What this gives you

attnames[]: actual column names for non-expression index keys

exprs[]: expression text for expression keys (lower(email), etc.)

indnkeyatts: number of “key attributes” (excludes INCLUDE columns)



---

B) Extend the snapshot index model

Update your index type to keep both column and expression keys:

indexes: Record<string, {
  key: string;                 // "schema.table.index"
  tableKey: string;
  schema: string;
  table: string;
  name: string;
  method: string;
  keyColumns: string[];        // key attrs only
  includeColumns: string[];    // INCLUDE cols (Postgres)
  expressions: string[];       // expression keys in order
  predicate?: string | null;
  isUnique: boolean;
  isPrimary: boolean;
  indexDef?: string;           // store full definition for UI
}>;


---

C) Normalize index keys into key vs include columns

pg_index.indnkeyatts tells us where key columns stop and INCLUDE begins.

Patch the normalization block in fetchCatalogSnapshot():

for (const r of idxRes.rows ?? []) {
  const tableKey = `${r.schema}.${r.table}`;
  const key = `${r.schema}.${r.table}.${r.name}`;

  const attnames: string[] = (r.attnames ?? []).map(String);
  const exprs: string[] = (r.exprs ?? []).map(String);

  // We need key-only order. attnames/exprs are aligned to ordinals.
  // But attnames has NULLs for expression positions; exprs has values for expression positions.
  // So we rebuild a single ordered list of "parts".
  const parts: Array<{ kind: 'col'|'expr'; value: string }> = [];

  // exprs includes column keys too if pg_get_indexdef(..., ord, true) returns plain column name;
  // BUT attnames is more reliable for columns. We’ll prefer attnames when present.
  // We rebuild by splitting indexdef parts using ord positions:
  // - for each ordinal:
  //   - if attname exists => column
  //   - else => expression from pg_get_indexdef(index, ord, true)
  const indnkeyatts = Number(r.indnkeyatts ?? attnames.length);

  // Create an ordinal loop from 0..(maxLen-1) based on exprs length
  const maxOrd = Math.max(attnames.length, exprs.length);
  for (let i = 0; i < maxOrd; i++) {
    const col = attnames[i];
    if (col) parts.push({ kind: 'col', value: col });
    else if (exprs[i]) parts.push({ kind: 'expr', value: exprs[i] });
  }

  // Split into key vs include portions
  const keyParts = parts.slice(0, indnkeyatts);
  const includeParts = parts.slice(indnkeyatts);

  const keyColumns = keyParts.filter(p => p.kind === 'col').map(p => p.value);
  const expressions = keyParts.filter(p => p.kind === 'expr').map(p => p.value);
  const includeColumns = includeParts.filter(p => p.kind === 'col').map(p => p.value);

  snap.indexes[key] = {
    key,
    tableKey,
    schema: r.schema,
    table: r.table,
    name: r.name,
    method: r.method,
    keyColumns,
    includeColumns,
    expressions,
    predicate: r.predicate ?? null,
    isUnique: !!r.is_unique,
    isPrimary: !!r.is_primary,
    indexDef: r.indexdef ?? null
  };
}


---

D) What this unlocks immediately (checks)

1) FK not indexed (simple + correct)

For each relationship childCols[], check if any index on child table has keyColumns that starts with childCols in order.

Ignore partial indexes unless predicate is null (v1 simplest).

Later you can treat partial indexes as “maybe” warnings.


2) “Index includes FK but not leading” detection

If index columns are ['created_at','user_id'], it doesn’t help the FK for typical joins. You can warn.


---

E) Small helper: “covers prefix”

Drop this in apps/api/src/checks/utils/indexCoverage.ts

export function coversPrefix(indexCols: string[], needed: string[]) {
  if (needed.length === 0) return true;
  if (indexCols.length < needed.length) return false;
  for (let i = 0; i < needed.length; i++) {
    if (indexCols[i] !== needed[i]) return false;
  }
  return true;
}


---

F) Next after this (best “next next”)

3.1 Views definitions (optional v1) or 3.2 persistent snapshot storage (so ERD loads instantly without re-introspecting).

If you just say Next again, I’ll do 3.2 persistent snapshot storage + drift signature (cache + DB + “last refreshed” + “schema changed” indicator).

3.1 Views definitions (optional v1)

We’ll add views + materialized views to the snapshot with:

stable keys (schema.view)

definition text (pg_get_viewdef)

(optional) dependency hints later


This supports:

ERD display of views (different node styling)

“View health” checks (ownership, security definer, etc. later)

quick “open definition” in UI



---

A) Extend CatalogSnapshot type

apps/api/src/introspection/types.ts (add / extend)

export type CatalogSnapshot = {
  // ...existing...
  views?: Record<string, {
    key: string;               // "schema.view"
    schema: string;
    name: string;
    kind: 'view' | 'materialized_view';
    definition: string;        // SQL text
  }>;
};


---

B) Add a views query (pg_class + pg_get_viewdef)

Patch apps/api/src/introspection/snapshot.ts

Add this query after tables/columns (uses the same schemas[] filter):

const viewsRes = await pool.query(
  `
  SELECT
    n.nspname AS schema,
    c.relname AS name,
    c.relkind AS relkind,
    pg_get_viewdef(c.oid, true) AS definition
  FROM pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE n.nspname = ANY($1::text[])
    AND c.relkind IN ('v','m')
  ORDER BY 1,2
  `,
  [schemas],
);


---

C) Normalize into snapshot

Initialize views on the snapshot:

snap.views = {};

Then add normalization:

for (const r of viewsRes.rows ?? []) {
  const key = `${r.schema}.${r.name}`;
  const kind = r.relkind === 'v' ? 'view' : 'materialized_view';

  snap.views![key] = {
    key,
    schema: r.schema,
    name: r.name,
    kind,
    definition: String(r.definition ?? ''),
  };
}


---

D) ERD integration (frontend note)

You already store tables.kind as view|materialized_view.
Two approaches:

Option 1 (simplest)

Keep views in tables (they already appear) and use snap.views[key]?.definition when user opens inspector.

Option 2 (clean separation)

Render “Views” section in left sidebar from snapshot.views.

I recommend Option 1 for v1: less UI work.


---

E) Optional: views in checks runtime

Add a scope selector later:

scopeType: "view"

targetSelector: { kind: "allViews" }


Not needed for v1 shipping.


---

Next best “3.1” upgrade

If you say Next, I’d do 3.1 stable object identity + hashing:

meta.signature hash for drift detection

meta.objectCounts for UI summary
(and then wire it into 3.2 refresh UI: “schema changed since last refresh”).
