3.2 Caching + Refresh (memory + persistent) + drift detection + “last refreshed”

We’ll implement:

✅ Memory cache (fast)

✅ Persistent cache in App DB (catalog_snapshots)

✅ Refresh modes: cache | force | visible

✅ Drift detection (light v1) via snapshot signature hash

✅ Last refreshed timestamp returned to UI

✅ Optional: “refresh visible tables only” (v1.5 ok) — we’ll stub the shape now



---

3.2.01 DB schema (persistent cache)

db/migrations/009_catalog_snapshots.sql

-- requires pgcrypto for gen_random_uuid (or use uuid-ossp)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE IF NOT EXISTS catalog_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NULL,
  connection_key text NOT NULL,
  schemas text[] NOT NULL,
  captured_at timestamptz NOT NULL,
  signature text NOT NULL,
  snapshot jsonb NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS catalog_snapshots_key_idx
  ON catalog_snapshots(connection_key);

CREATE INDEX IF NOT EXISTS catalog_snapshots_key_schemas_idx
  ON catalog_snapshots(connection_key, schemas);

CREATE INDEX IF NOT EXISTS catalog_snapshots_created_idx
  ON catalog_snapshots(created_at DESC);

> workspace_id is optional in v1. Keep it if you want multi-tenant correctness later.




---

3.2.02 Signature (drift detection light v1)

We compute a stable hash from:

sorted table keys

sorted column keys

sorted relationship keys


apps/api/src/introspection/signature.ts

import crypto from 'crypto';
import type { CatalogSnapshot } from './types';

export function computeSnapshotSignature(s: CatalogSnapshot) {
  const tables = Object.keys(s.tables).sort();
  const columns = Object.keys(s.columns).sort();
  const rels = Object.keys(s.relationships).sort();

  // keep it light; don’t hash full definitions
  const payload = JSON.stringify({
    t: tables,
    c: columns,
    r: rels,
  });

  return crypto.createHash('sha256').update(payload).digest('hex');
}


---

3.2.03 Persistent cache access layer

apps/api/src/introspection/persist.ts

import type { Pool } from 'pg';
import type { CatalogSnapshot } from './types';

export async function loadLatestSnapshot(args: {
  appDb: Pool;
  connectionKey: string;
  schemas: string[];
}): Promise<null | { snapshot: CatalogSnapshot; capturedAt: string; signature: string }> {
  const res = await args.appDb.query(
    `
    SELECT snapshot, captured_at, signature
    FROM catalog_snapshots
    WHERE connection_key = $1
      AND schemas = $2::text[]
    ORDER BY captured_at DESC
    LIMIT 1
    `,
    [args.connectionKey, args.schemas],
  );

  if (!res.rows?.length) return null;

  return {
    snapshot: res.rows[0].snapshot as CatalogSnapshot,
    capturedAt: new Date(res.rows[0].captured_at).toISOString(),
    signature: String(res.rows[0].signature),
  };
}

export async function saveSnapshot(args: {
  appDb: Pool;
  workspaceId?: string | null;
  connectionKey: string;
  schemas: string[];
  snapshot: CatalogSnapshot;
  signature: string;
}) {
  await args.appDb.query(
    `
    INSERT INTO catalog_snapshots (workspace_id, connection_key, schemas, captured_at, signature, snapshot)
    VALUES ($1, $2, $3::text[], $4::timestamptz, $5, $6::jsonb)
    `,
    [
      args.workspaceId ?? null,
      args.connectionKey,
      args.schemas,
      args.snapshot.meta.capturedAt,
      args.signature,
      args.snapshot,
    ],
  );
}


---

3.2.04 Cache key + memory cache (already started) — refine it

apps/api/src/introspection/cache.ts

import type { CatalogSnapshot } from './types';

type CacheEntry = {
  snapshot: CatalogSnapshot;
  signature: string;
  capturedAt: number;
  expiresAt: number;
};

const mem = new Map<string, CacheEntry>();

export function getMem(key: string) {
  const e = mem.get(key);
  if (!e) return null;
  if (Date.now() > e.expiresAt) {
    mem.delete(key);
    return null;
  }
  return e;
}

export function setMem(key: string, snapshot: CatalogSnapshot, signature: string, ttlMs: number) {
  mem.set(key, { snapshot, signature, capturedAt: Date.now(), expiresAt: Date.now() + ttlMs });
}


---

3.2.05 Route: snapshot with refresh modes + drift detection

We’ll return:

snapshot

cache: hit, source (mem|db|fresh)

lastRefreshedAt

drift: { changedSinceLast: boolean, previousSignature, currentSignature }


apps/api/src/routes/introspectSnapshot.ts

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { createTargetPool } from '../targetDb';
import { fetchCatalogSnapshot } from '../introspection/snapshot';
import { computeSnapshotSignature } from '../introspection/signature';
import { getMem, setMem } from '../introspection/cache';
import { loadLatestSnapshot, saveSnapshot } from '../introspection/persist';
import { appDb } from '../services/appDb';

function normalizeSchemas(schemas: string[]) {
  return schemas.slice().map(s => s.trim()).filter(Boolean).sort();
}

function makeConnectionKey(body: { connectionId?: string; targetDatabaseUrl: string }) {
  // v1: simplest
  return body.connectionId ? `conn:${body.connectionId}` : `url:${body.targetDatabaseUrl}`;
}

function makeCacheKey(connectionKey: string, schemas: string[]) {
  return `${connectionKey}::schemas:${schemas.join(',')}`;
}

export async function introspectSnapshotRoutes(app: FastifyInstance) {
  app.post('/api/v1/introspect/postgres/snapshot', async (req) => {
    const Body = z.object({
      workspaceId: z.string().uuid().optional(),
      connectionId: z.string().uuid().optional(),

      // v1 dev
      targetDatabaseUrl: z.string().min(10),

      schemas: z.array(z.string().min(1)).min(1),

      refresh: z.enum(['cache', 'force', 'visible']).default('cache'),
      visibleTables: z.array(z.string().min(3)).optional()
    });

    const body = Body.parse(req.body);
    const schemas = normalizeSchemas(body.schemas);
    const connectionKey = makeConnectionKey(body);
    const cacheKey = makeCacheKey(connectionKey, schemas);

    const memTtlMs = 60_000;      // memory cache (fast)
    const dbMaxAgeMs = 10 * 60_000; // db cache (10 min) v1

    // 1) Memory cache
    if (body.refresh === 'cache') {
      const hit = getMem(cacheKey);
      if (hit) {
        return {
          snapshot: hit.snapshot,
          cache: { hit: true, source: 'mem', key: cacheKey, ttlMs: memTtlMs },
          lastRefreshedAt: hit.snapshot.meta.capturedAt,
          drift: { changedSinceLast: false, previousSignature: hit.signature, currentSignature: hit.signature }
        };
      }
    }

    // 2) Persistent cache (App DB)
    if (body.refresh === 'cache') {
      const latest = await loadLatestSnapshot({ appDb, connectionKey, schemas });
      if (latest) {
        const age = Date.now() - new Date(latest.capturedAt).getTime();
        if (age <= dbMaxAgeMs) {
          setMem(cacheKey, latest.snapshot, latest.signature, memTtlMs);
          return {
            snapshot: latest.snapshot,
            cache: { hit: true, source: 'db', key: cacheKey, maxAgeMs: dbMaxAgeMs },
            lastRefreshedAt: latest.capturedAt,
            drift: { changedSinceLast: false, previousSignature: latest.signature, currentSignature: latest.signature }
          };
        }
      }
    }

    // 3) Fresh introspection (force or expired)
    const pool = createTargetPool(body.targetDatabaseUrl);

    try {
      // v1: visible mode still runs full snapshot; later optimize using visibleTables
      const snapshot = await fetchCatalogSnapshot(pool, schemas);
      const signature = computeSnapshotSignature(snapshot);

      // Compare to latest persisted for drift info
      const prev = await loadLatestSnapshot({ appDb, connectionKey, schemas });
      const prevSig = prev?.signature ?? null;
      const changedSinceLast = prevSig ? prevSig !== signature : false;

      // Persist + memory
      await saveSnapshot({
        appDb,
        workspaceId: body.workspaceId ?? null,
        connectionKey,
        schemas,
        snapshot,
        signature
      });
      setMem(cacheKey, snapshot, signature, memTtlMs);

      return {
        snapshot,
        cache: { hit: false, source: 'fresh', key: cacheKey },
        lastRefreshedAt: snapshot.meta.capturedAt,
        drift: { changedSinceLast, previousSignature: prevSig, currentSignature: signature }
      };
    } finally {
      await pool.end().catch(() => {});
    }
  });
}


---

3.2.06 App DB connection (appDb)

If you don’t already have one:

apps/api/src/services/appDb.ts

import { Pool } from 'pg';

export const appDb = new Pool({
  connectionString: process.env.APP_DATABASE_URL,
  max: 10
});


---

3.2.07 Frontend UX contract (“Last refreshed” + refresh button)

UI uses:

lastRefreshedAt for display

refresh button calls snapshot endpoint with:

refresh:"force"



If drift is detected:

show pill: “Schema changed since last refresh”

optionally auto-refresh layout edges if keys missing



---

3.2.08 “Refresh visible tables only” (v1.5 note)

We already accept:

refresh:"visible"

visibleTables:["public.users", ...]


In v1 you can ignore visibleTables.
In v1.5 you optimize by:

fetching columns/constraints/indexes only for visible table OIDs.



---

Next (if you say Next again)

I’d implement 3.2 visible-only optimization or 3.2 snapshot diff endpoint:

POST /introspect/postgres/diff returns added/removed tables/columns/relationships using signatures + key lists.
