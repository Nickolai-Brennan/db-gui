3.5 Checks & Validation Layer (ERD-aware “Checks Runtime” + Issues Engine)

3.5 is where your GUI stops being “a pretty ERD” and becomes a database diagnostics/workbench:

run automated checks against the catalog + live DB

generate Issues that deep-link into ERD (table/column/relationship focus)

store results per run, compare over time, export bundles


I’m going to define 3.5.1–3.5.9 with minimum-to-ship code skeletons.


---

3.5.1 Core concepts

Entities

CheckDefinition: metadata + parameters + how to run

CheckRun: one execution instance (time, scope, status)

CheckResult: output rows/summary + mappings to targets

Issue: flattened “actionable problem” with highlight payload (your ERD jump system)


Target refs (same keys as ERD)

table: schema.table

column: schema.table.column

relationship: child(col)->parent(col) signature



---

3.5.2 App DB schema for runs + results + issues

db/migrations/030_checks.sql

CREATE TABLE IF NOT EXISTS check_runs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NULL,
  actor_id uuid NULL,
  actor_label text NULL,

  connection_key text NOT NULL,
  schemas text[] NOT NULL,

  status text NOT NULL CHECK (status IN ('queued','running','success','failed','canceled')),
  started_at timestamptz NULL,
  finished_at timestamptz NULL,

  snapshot_signature text NULL,
  error text NULL,

  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS check_results (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  run_id uuid NOT NULL REFERENCES check_runs(id) ON DELETE CASCADE,

  check_id text NOT NULL,
  check_version text NOT NULL DEFAULT '1',

  severity text NOT NULL CHECK (severity IN ('info','warning','blocking')),
  title text NOT NULL,

  target_type text NOT NULL CHECK (target_type IN ('db','schema','table','column','relationship')),
  target_key text NULL,                    -- e.g. "public.users" or relationship signature

  summary jsonb NULL,                      -- stats, counts, etc.
  sample_rows jsonb NULL,                  -- limited rows sample
  evidence jsonb NULL,                     -- optional payload

  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS issues (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  run_id uuid NOT NULL REFERENCES check_runs(id) ON DELETE CASCADE,

  severity text NOT NULL CHECK (severity IN ('info','warning','blocking')),
  status text NOT NULL DEFAULT 'open' CHECK (status IN ('open','acknowledged','resolved','ignored')),

  title text NOT NULL,
  message text NULL,

  target_type text NOT NULL CHECK (target_type IN ('db','schema','table','column','relationship')),
  target_key text NULL,

  highlight jsonb NULL,                    -- your ERD Highlight Payload
  tags text[] NULL,

  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS issues_run_sev ON issues(run_id, severity);
CREATE INDEX IF NOT EXISTS issues_target ON issues(target_type, target_key);


---

3.5.3 Check interface + registry

apps/api/src/checks/types.ts

import type { Pool } from 'pg';
import type { CatalogSnapshot } from '../introspection/types';

export type CheckSeverity = 'info' | 'warning' | 'blocking';
export type TargetType = 'db' | 'schema' | 'table' | 'column' | 'relationship';

export type CheckContext = {
  targetPool: Pool;                // connection under test
  connectionKey: string;
  schemas: string[];
  snapshot: CatalogSnapshot;
  statementTimeoutMs: number;
};

export type CheckResult = {
  checkId: string;
  checkVersion: string;

  severity: CheckSeverity;
  title: string;

  targetType: TargetType;
  targetKey?: string | null;       // e.g. "public.users" or "public.a(x)->public.b(y)"

  message?: string;
  summary?: any;
  sampleRows?: any[];
  evidence?: any;

  // optional: recommended highlight payload
  highlight?: any;
};

export type CheckDefinition = {
  id: string;
  version: string;
  title: string;
  defaultSeverity: CheckSeverity;
  description: string;

  // optional: UI params schema for low-code
  paramsSchema?: any;

  run: (ctx: CheckContext, params?: any) => Promise<CheckResult[]>;
};

apps/api/src/checks/registry.ts

import type { CheckDefinition } from './types';

const registry = new Map<string, CheckDefinition>();

export function registerCheck(def: CheckDefinition) {
  if (registry.has(def.id)) throw new Error(`Check already registered: ${def.id}`);
  registry.set(def.id, def);
}

export function getCheck(id: string) {
  const c = registry.get(id);
  if (!c) throw new Error(`Unknown check: ${id}`);
  return c;
}

export function listChecks() {
  return Array.from(registry.values()).sort((a, b) => a.id.localeCompare(b.id));
}


---

3.5.4 Built-in checks (v1 set)

Minimum set that’s immediately valuable + ERD-aware:

A) Missing primary keys (table-level)

severity: warning

target: table


B) Orphaned foreign keys (relationship-level)

severity: blocking

target: relationship

runs SQL to count orphaned rows (cap sample)


C) Nullable FK columns (column-level)

severity: warning

target: column


D) Wide tables (too many columns) / big tables (size)

severity: info/warning


I’ll drop two fully-implemented checks below (PK + Orphans). Others can be added the same way.


---

3.5.4.1 Check: missing primary keys

apps/api/src/checks/builtins/missingPrimaryKeys.ts

import type { CheckDefinition } from '../types';

export const missingPrimaryKeys: CheckDefinition = {
  id: 'schema.missing_primary_keys',
  version: '1',
  title: 'Tables without Primary Keys',
  defaultSeverity: 'warning',
  description: 'Finds tables that do not have a primary key constraint.',

  run: async (ctx) => {
    const hasPk = new Set<string>();
    for (const pk of Object.values(ctx.snapshot.constraints.pks)) {
      hasPk.add(pk.tableKey);
    }

    const results = [];
    for (const t of Object.values(ctx.snapshot.tables)) {
      if (t.kind !== 'table' && t.kind !== 'partitioned') continue;
      if (!ctx.schemas.includes(t.schema)) continue;

      if (!hasPk.has(t.key)) {
        results.push({
          checkId: 'schema.missing_primary_keys',
          checkVersion: '1',
          severity: 'warning',
          title: 'Missing Primary Key',
          targetType: 'table',
          targetKey: t.key,
          message: `Table ${t.key} has no primary key.`,
          summary: { table: t.key },
          highlight: {
            focus: { type: 'table', key: t.key },
            tables: [{ key: t.key, emphasis: 'primary' }],
            columns: [],
            relationships: [],
          },
        });
      }
    }

    return results;
  },
};


---

3.5.4.2 Check: orphaned FK rows (relationship-aware)

This uses your relationship signatures and FK metadata.

apps/api/src/checks/builtins/orphanedForeignKeys.ts

import type { CheckDefinition } from '../types';

// Helper: quote schema/table/col safely (minimal)
function qident(x: string) { return `"${x.replace(/"/g, '""')}"`; }

export const orphanedForeignKeys: CheckDefinition = {
  id: 'rel.orphaned_foreign_keys',
  version: '1',
  title: 'Orphaned Foreign Keys',
  defaultSeverity: 'blocking',
  description: 'Detects child rows where the FK does not match a parent row (excluding NULL FKs).',

  run: async (ctx, params) => {
    const limit = Math.min(50, Number(params?.sampleLimit ?? 20));
    const results = [];

    await ctx.targetPool.query(`SET statement_timeout = $1`, [ctx.statementTimeoutMs]);

    for (const rel of Object.values(ctx.snapshot.relationships)) {
      // only run relationships where child schema is in selected schemas
      const childSchema = rel.childKey.split('.')[0];
      if (!ctx.schemas.includes(childSchema)) continue;

      const [cs, ct] = rel.childKey.split('.');
      const [ps, pt] = rel.parentKey.split('.');
      if (!cs || !ct || !ps || !pt) continue;

      // Build join predicate: child.childCol[i] = parent.parentCol[i]
      const join = rel.childCols.map((cc, i) =>
        `c.${qident(cc)} = p.${qident(rel.parentCols[i])}`
      ).join(' AND ');

      // Exclude NULL FKs (any fk col null -> consider “not applicable”)
      const nonNull = rel.childCols.map(cc => `c.${qident(cc)} IS NOT NULL`).join(' AND ');

      const sqlCount = `
        SELECT COUNT(*)::bigint AS orphan_count
        FROM ${qident(cs)}.${qident(ct)} c
        LEFT JOIN ${qident(ps)}.${qident(pt)} p
          ON ${join}
        WHERE (${nonNull})
          AND p.${qident(rel.parentCols[0])} IS NULL
      `;

      const countRes = await ctx.targetPool.query(sqlCount);
      const orphanCount = Number(countRes.rows?.[0]?.orphan_count ?? 0);

      if (orphanCount > 0) {
        const sqlSample = `
          SELECT ${rel.childCols.map(cc => `c.${qident(cc)} AS ${qident(cc)}`).join(', ')}
          FROM ${qident(cs)}.${qident(ct)} c
          LEFT JOIN ${qident(ps)}.${qident(pt)} p
            ON ${join}
          WHERE (${nonNull})
            AND p.${qident(rel.parentCols[0])} IS NULL
          LIMIT ${limit}
        `;

        const sampleRes = await ctx.targetPool.query(sqlSample);

        results.push({
          checkId: 'rel.orphaned_foreign_keys',
          checkVersion: '1',
          severity: 'blocking',
          title: 'Orphaned FK rows',
          targetType: 'relationship',
          targetKey: rel.key,
          message: `${rel.childKey} has ${orphanCount} row(s) violating FK to ${rel.parentKey}.`,
          summary: {
            orphanCount,
            child: rel.childKey,
            parent: rel.parentKey,
            childCols: rel.childCols,
            parentCols: rel.parentCols,
          },
          sampleRows: sampleRes.rows ?? [],
          highlight: {
            focus: { type: 'relationship', key: rel.key },
            relationships: [{ key: rel.key, emphasis: 'primary' }],
            tables: [
              { key: rel.childKey, emphasis: 'secondary' },
              { key: rel.parentKey, emphasis: 'secondary' },
            ],
            columns: [
              ...rel.childCols.map(c => ({ key: `${rel.childKey}.${c}`, emphasis: 'primary' })),
              ...rel.parentCols.map(c => ({ key: `${rel.parentKey}.${c}`, emphasis: 'primary' })),
            ],
          },
        });
      }
    }

    return results;
  },
};


---

3.5.5 Register builtins at startup

apps/api/src/checks/builtins/index.ts

import { registerCheck } from '../registry';
import { missingPrimaryKeys } from './missingPrimaryKeys';
import { orphanedForeignKeys } from './orphanedForeignKeys';

export function registerBuiltins() {
  registerCheck(missingPrimaryKeys);
  registerCheck(orphanedForeignKeys);
}

In server bootstrap:

import { registerBuiltins } from './checks/builtins';
registerBuiltins();


---

3.5.6 Runner service (execute checks, persist results + issues)

apps/api/src/checks/runner.ts

import { appDb } from '../services/appDb';
import { getCheck, listChecks } from './registry';
import type { CheckContext, CheckResult } from './types';

export async function createRun(args: {
  connectionKey: string;
  schemas: string[];
  actorLabel?: string | null;
  snapshotSignature?: string | null;
}) {
  const res = await appDb.query(
    `INSERT INTO check_runs(connection_key, schemas, status, started_at, actor_label, snapshot_signature)
     VALUES ($1,$2,'running', now(), $3, $4)
     RETURNING id`,
    [args.connectionKey, args.schemas, args.actorLabel ?? null, args.snapshotSignature ?? null]
  );
  return String(res.rows[0].id);
}

export async function saveResults(runId: string, results: CheckResult[]) {
  for (const r of results) {
    await appDb.query(
      `INSERT INTO check_results(
         run_id, check_id, check_version, severity, title,
         target_type, target_key, summary, sample_rows, evidence
       )
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8::jsonb,$9::jsonb,$10::jsonb)`,
      [
        runId,
        r.checkId, r.checkVersion,
        r.severity, r.title,
        r.targetType, r.targetKey ?? null,
        r.summary ?? null,
        r.sampleRows ?? null,
        r.evidence ?? null,
      ]
    );

    // Create “issues” only for warnings/blocking (v1 rule)
    if (r.severity === 'warning' || r.severity === 'blocking') {
      await appDb.query(
        `INSERT INTO issues(
           run_id, severity, status, title, message,
           target_type, target_key, highlight, tags
         )
         VALUES ($1,$2,'open',$3,$4,$5,$6,$7::jsonb,$8::text[])`,
        [
          runId,
          r.severity,
          r.title,
          r.message ?? null,
          r.targetType,
          r.targetKey ?? null,
          r.highlight ?? null,
          null,
        ]
      );
    }
  }
}

export async function finalizeRun(runId: string, status: 'success'|'failed', error?: string | null) {
  await appDb.query(
    `UPDATE check_runs
     SET status=$2, finished_at=now(), error=$3
     WHERE id=$1`,
    [runId, status, error ?? null]
  );
}

export async function runChecks(args: {
  ctx: CheckContext;
  checkIds?: string[];     // if omitted => all
  paramsById?: Record<string, any>;
  actorLabel?: string | null;
  snapshotSignature?: string | null;
}) {
  const runId = await createRun({
    connectionKey: args.ctx.connectionKey,
    schemas: args.ctx.schemas,
    actorLabel: args.actorLabel ?? null,
    snapshotSignature: args.snapshotSignature ?? null,
  });

  try {
    const defs = args.checkIds?.length
      ? args.checkIds.map(getCheck)
      : listChecks();

    const allResults: CheckResult[] = [];
    for (const def of defs) {
      const p = args.paramsById?.[def.id];
      const res = await def.run(args.ctx, p);
      allResults.push(...res);
    }

    await saveResults(runId, allResults);
    await finalizeRun(runId, 'success', null);
    return { runId, resultsCount: allResults.length };
  } catch (e: any) {
    await finalizeRun(runId, 'failed', e?.message ?? String(e));
    throw e;
  }
}


---

3.5.7 API endpoints (minimum to ship)

Endpoints

GET /api/v1/checks list registry

POST /api/v1/checks/run run checks (all or selected)

GET /api/v1/runs/:id run summary

GET /api/v1/runs/:id/issues issues list with filters


If you want, I’ll paste the exact Fastify route files next.


---

3.5.8 Frontend UX (ties to your ERD)

Minimum UI:

Checks page

list checks (toggle enable)

Run button


Run results

summary counters (blocking/warning/info)

Issues drawer

filters: severity, schema, table, relationship

click issue → uses highlight payload → ERD jump + flash (already built)





---

3.5.9 Minimum built-in checks list (v1 roadmap)

Start with 8–12 checks max:

Schema integrity

1. Tables without PK (warning)


2. Orphaned FKs (blocking)


3. Nullable FK columns (warning)


4. Unindexed FK columns (warning)



Performance hints 5. Missing indexes on large tables (info/warning) 6. Duplicate indexes (info) 7. Very wide tables (info)

Data hygiene (optional) 8. Columns with unexpected NULL ratio (warning) — needs sampling 9. Text columns with high cardinality (info) — needs sampling


---

If you say “continue”, I’ll deliver the exact Fastify routes for 3.5.7 (list checks, run checks, get runs, issues filters) + the request/response payloads matching your existing “Issues filters code” style.
