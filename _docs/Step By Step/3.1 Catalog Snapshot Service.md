Got it — 3.1 is the heart of your ERD + checks system. Below is a clean, ship-ready spec for the Postgres Catalog Snapshot Service including the exact query set, a normalized CatalogSnapshot model, and the stable relationship signature rules.


---

3.1 Catalog Snapshot Service

Goal

Produce a single normalized object:

tables (+ row estimate, size)

columns (+ types, nullability, defaults)

constraints (PK + unique)

relationships (FKs + rules + deferrable)

indexes (+ method + predicate)

views (optional v1)

stable identifiers + stable relationship keys


This snapshot is the source of truth for:

ERD graph building

checks runtime targeting (target_ref)

drift detection

caching



---

3.1.1 Normalized Model (Authoritative)

CatalogSnapshot (TypeScript)

export type CatalogSnapshot = {
  meta: {
    capturedAt: string;      // ISO
    db: string;              // current_database()
    schemas: string[];
    serverVersion?: string;
  };

  tables: Record<string, CatalogTable>;          // key = "schema.table"
  columns: Record<string, CatalogColumn>;        // key = "schema.table.column"

  constraints: {
    pks: Record<string, CatalogPk>;              // key = "schema.table|pk_name"
    uniques: Record<string, CatalogUnique>;      // key = "schema.table|uq_name"
  };

  relationships: Record<string, CatalogFk>;      // key = stable relationship signature (below)

  indexes: Record<string, CatalogIndex>;         // key = "schema.table|index_name"

  views?: Record<string, CatalogView>;           // key = "schema.view"
};

Table / Column

export type CatalogTable = {
  key: string;          // "schema.table"
  schema: string;
  name: string;
  kind: 'table' | 'partitioned' | 'view' | 'materialized_view';

  rowEstimate?: number; // from pg_class.reltuples
  totalBytes?: number;  // pg_total_relation_size
  tableBytes?: number;  // pg_relation_size
  indexBytes?: number;  // total - table

  oid?: number;         // internal aid
};

export type CatalogColumn = {
  key: string;          // "schema.table.column"
  schema: string;
  table: string;
  tableKey: string;     // "schema.table"
  name: string;

  dataType: string;     // format_type(atttypid, atttypmod)
  isNullable: boolean;
  default?: string | null; // pg_get_expr(adbin,...)
  ordinal: number;
};

Constraints

export type CatalogPk = {
  tableKey: string;
  name: string;
  columns: string[]; // ordered
};

export type CatalogUnique = {
  tableKey: string;
  name: string;
  columns: string[]; // ordered
};

FK Relationship

export type CatalogFk = {
  key: string;           // stable signature
  name: string;

  childKey: string;      // "schema.table"
  parentKey: string;     // "schema.table"

  childCols: string[];   // ordered
  parentCols: string[];  // ordered

  onUpdate: string;      // CASCADE | RESTRICT | NO ACTION | SET NULL | SET DEFAULT
  onDelete: string;

  deferrable: boolean;
  initiallyDeferred: boolean;
};

Index

export type CatalogIndex = {
  key: string;           // "schema.table|index_name"
  schema: string;
  tableKey: string;
  name: string;

  method: string;        // btree/hash/gin/gist/brin...
  columnsExpr: string;   // pg_get_indexdef(indexrelid)
  predicate?: string | null; // partial index predicate
  isUnique: boolean;
  isPrimary: boolean;
};

View (optional v1)

export type CatalogView = {
  key: string;           // "schema.view"
  schema: string;
  name: string;
  kind: 'view' | 'materialized_view';
  definition: string;    // pg_get_viewdef(oid,true)
};


---

3.1.2 Stable Identifiers

Canonical keys

tableKey: ${schema}.${table}

columnKey: ${schema}.${table}.${column}

indexKey: ${schema}.${table}|${indexName}

constraint key: ${tableKey}|${constraintName}



---

3.1.3 Stable Relationship Signatures (CRITICAL)

Do not use FK constraint name as primary identity (names change).
Use a signature based on the relationship itself:

Relationship key format (authoritative)

childSchema.childTable(col1,col2)->parentSchema.parentTable(colA,colB)

Example:

public.orders(user_id)->public.users(id)

If composite:

public.order_items(order_id,line_no)->public.orders(id,line_no)

This must match what your ERD highlight payload targets.


---

3.1.4 Query Set (Postgres Catalog Fetch Pipeline)

All queries should be scoped to schemas[].

Q0: DB meta

SELECT current_database() AS db, version() AS server_version;

Q1: Tables + estimates + size

SELECT
  n.nspname AS schema,
  c.relname AS name,
  c.relkind,
  c.oid,
  c.reltuples::bigint AS row_estimate,
  pg_total_relation_size(c.oid) AS total_bytes,
  pg_relation_size(c.oid) AS table_bytes,
  (pg_total_relation_size(c.oid) - pg_relation_size(c.oid)) AS index_bytes
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = ANY($1::text[])
  AND c.relkind IN ('r','p','v','m') -- table, partitioned, view, matview
ORDER BY 1,2;

Map relkind:

r → table

p → partitioned

v → view

m → materialized_view


Q2: Columns + types + nullability + defaults

SELECT
  n.nspname AS schema,
  c.relname AS table,
  a.attname AS column,
  a.attnum AS ordinal,
  format_type(a.atttypid, a.atttypmod) AS data_type,
  NOT a.attnotnull AS is_nullable,
  pg_get_expr(ad.adbin, ad.adrelid) AS default_expr
FROM pg_attribute a
JOIN pg_class c ON c.oid = a.attrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
WHERE n.nspname = ANY($1::text[])
  AND c.relkind IN ('r','p','v','m')
  AND a.attnum > 0
  AND NOT a.attisdropped
ORDER BY 1,2,a.attnum;

Q3: PK + unique constraints (ordered columns)

SELECT
  n.nspname AS schema,
  c.relname AS table,
  con.conname AS constraint_name,
  con.contype AS constraint_type, -- p or u
  ARRAY(
    SELECT a.attname
    FROM unnest(con.conkey) WITH ORDINALITY AS k(attnum, ord)
    JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = k.attnum
    ORDER BY k.ord
  ) AS columns
FROM pg_constraint con
JOIN pg_class c ON c.oid = con.conrelid
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = ANY($1::text[])
  AND con.contype IN ('p','u')
ORDER BY 1,2,3;

Q4: Foreign keys + rules + deferrable + ordered col mapping

SELECT
  n1.nspname AS child_schema,
  c1.relname AS child_table,
  con.conname AS fk_name,
  n2.nspname AS parent_schema,
  c2.relname AS parent_table,
  ARRAY(
    SELECT a1.attname
    FROM unnest(con.conkey) WITH ORDINALITY AS k(attnum, ord)
    JOIN pg_attribute a1 ON a1.attrelid = c1.oid AND a1.attnum = k.attnum
    ORDER BY k.ord
  ) AS child_cols,
  ARRAY(
    SELECT a2.attname
    FROM unnest(con.confkey) WITH ORDINALITY AS k(attnum, ord)
    JOIN pg_attribute a2 ON a2.attrelid = c2.oid AND a2.attnum = k.attnum
    ORDER BY k.ord
  ) AS parent_cols,
  con.confupdtype AS on_update_code,
  con.confdeltype AS on_delete_code,
  con.condeferrable AS deferrable,
  con.condeferred AS initially_deferred
FROM pg_constraint con
JOIN pg_class c1 ON c1.oid = con.conrelid
JOIN pg_namespace n1 ON n1.oid = c1.relnamespace
JOIN pg_class c2 ON c2.oid = con.confrelid
JOIN pg_namespace n2 ON n2.oid = c2.relnamespace
WHERE n1.nspname = ANY($1::text[])
  AND con.contype = 'f'
ORDER BY 1,2,fk_name;

Translate action code:

a NO ACTION

r RESTRICT

c CASCADE

n SET NULL

d SET DEFAULT


Q5: Indexes + method + predicate

SELECT
  n.nspname AS schema,
  t.relname AS table,
  i.relname AS index_name,
  am.amname AS method,
  ix.indisunique AS is_unique,
  ix.indisprimary AS is_primary,
  pg_get_indexdef(i.oid) AS indexdef,
  pg_get_expr(ix.indpred, ix.indrelid) AS predicate
FROM pg_index ix
JOIN pg_class i ON i.oid = ix.indexrelid
JOIN pg_class t ON t.oid = ix.indrelid
JOIN pg_namespace n ON n.oid = t.relnamespace
JOIN pg_am am ON am.oid = i.relam
WHERE n.nspname = ANY($1::text[])
ORDER BY 1,2,3;

Q6: View definitions (optional v1)

SELECT
  n.nspname AS schema,
  c.relname AS name,
  c.relkind,
  pg_get_viewdef(c.oid, true) AS definition
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = ANY($1::text[])
  AND c.relkind IN ('v','m')
ORDER BY 1,2;


---

3.1.5 Pipeline Implementation Structure

Recommended file layout

apps/api/src/introspection/
  snapshot.ts
  queries.ts
  normalize.ts
  signature.ts
  types.ts

fetchCatalogSnapshot(pool, schemas[]) flow

1. run Q0–Q5 (and Q6 if enabled)


2. normalize rows into maps


3. compute stable relationship keys


4. return CatalogSnapshot




---

3.1.6 Relationship Key Builder

export function fkSignature(args: {
  childKey: string;
  childCols: string[];
  parentKey: string;
  parentCols: string[];
}) {
  const c = `${args.childKey}(${args.childCols.join(',')})`;
  const p = `${args.parentKey}(${args.parentCols.join(',')})`;
  return `${c}->${p}`;
}


---

3.1.7 “Normalize into CatalogSnapshot” rules

Only include objects where schema in schemas[]

Use canonical keys for map storage

Ensure ordered column arrays for PK/Unique/FK

Keep relationship map keyed by signature, not constraint name

Index map keyed by schema.table|index_name



---

If you want, I can now drop the actual snapshot.ts implementation (TypeScript, using pg Pool) that runs these queries and produces the normalized CatalogSnapshot object in one go (clean, production style).
