## Step 1.1.01 — App DB Schema v1 (Persistence for ERD + Checklists + Apply Logs) (exact)

Goal: create the **application database** that persists:

- Workspaces, Connections
- Catalog Snapshots (introspection cache)
- Diagrams (layout + notes + groups)
- Checklist Templates + Versions + Nodes
- Checklist Instances + Results + Evidence/Overrides (optional v1)
- Migrations Plans + Runs (apply logs)

This is the “spine” that everything else hangs on.

---

# 1.1.01a) Create Postgres DB + enable extensions

### Create DB (example)
```sql
CREATE DATABASE dbstudio_app;
```

### Enable UUID helpers (recommended)
```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
```

---

# 1.1.01b) Create core tables (SQL)

Create a new migration file:

- `apps/api/migrations/001_app_db.sql` (or your chosen migrations system)

Paste the following.

> v1 note: this schema is **Postgres-first** and assumes one diagram per connection (v1 rule).

```sql
-- =========
-- Workspaces
-- =========
CREATE TABLE IF NOT EXISTS app_workspace (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  slug text NOT NULL UNIQUE,
  name text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- =========
-- Connections (to user DBs)
-- =========
CREATE TABLE IF NOT EXISTS app_connection (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NOT NULL REFERENCES app_workspace(id) ON DELETE CASCADE,
  name text NOT NULL,

  dialect text NOT NULL CHECK (dialect IN ('postgres','mysql','sqlserver','sqlite')),
  host text,
  port int,
  database_name text,
  username text,
  secret_ref text, -- points to your secret manager key (never store raw passwords)

  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_connection_workspace ON app_connection(workspace_id);

-- =========
-- Catalog Snapshots (introspection cache)
-- =========
CREATE TABLE IF NOT EXISTS app_catalog_snapshot (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  connection_id uuid NOT NULL REFERENCES app_connection(id) ON DELETE CASCADE,

  schema_scope text[] NOT NULL DEFAULT '{}',   -- e.g. {public,stats}
  fingerprint text NOT NULL,                   -- hash of snapshot for drift compare
  captured_at timestamptz NOT NULL DEFAULT now(),

  payload jsonb NOT NULL                       -- CatalogSnapshot object (see ERD Spec)
);

CREATE INDEX IF NOT EXISTS idx_catalog_snapshot_conn_time
  ON app_catalog_snapshot(connection_id, captured_at DESC);

-- =========
-- Diagrams (layout + design-first state)
-- =========
CREATE TABLE IF NOT EXISTS app_diagram (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NOT NULL REFERENCES app_workspace(id) ON DELETE CASCADE,
  connection_id uuid NOT NULL REFERENCES app_connection(id) ON DELETE CASCADE,

  name text NOT NULL,
  schema_scope text[] NOT NULL DEFAULT '{}',
  base_snapshot_id uuid REFERENCES app_catalog_snapshot(id),

  model jsonb NOT NULL DEFAULT '{}'::jsonb, -- DiagramModel (nodes/edges/groups/notes/view)
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_diagram_workspace ON app_diagram(workspace_id);
CREATE INDEX IF NOT EXISTS idx_diagram_connection ON app_diagram(connection_id);

-- =========
-- Checklist Templates + Versioning
-- =========
CREATE TABLE IF NOT EXISTS checklist_template (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NOT NULL REFERENCES app_workspace(id) ON DELETE CASCADE,
  slug text NOT NULL,
  name text NOT NULL,
  description text,
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(workspace_id, slug)
);

CREATE TABLE IF NOT EXISTS checklist_template_version (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id uuid NOT NULL REFERENCES checklist_template(id) ON DELETE CASCADE,
  version text NOT NULL,                -- e.g. "v1.0", "v1.1-draft"
  is_published boolean NOT NULL DEFAULT false,
  published_at timestamptz,
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(template_id, version)
);

-- Nodes store the tree (infinite depth)
CREATE TABLE IF NOT EXISTS checklist_node (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  template_version_id uuid NOT NULL REFERENCES checklist_template_version(id) ON DELETE CASCADE,

  parent_id uuid REFERENCES checklist_node(id) ON DELETE CASCADE,
  sort_order int NOT NULL DEFAULT 0,

  node_type text NOT NULL CHECK (node_type IN ('group','item')),

  -- shared fields
  title text NOT NULL,
  description text,

  -- item-only fields (nullable for groups)
  item_type text CHECK (item_type IN ('manual','automatic','hybrid')),
  severity text CHECK (severity IN ('info','warning','error','blocking')),
  blocks_action boolean NOT NULL DEFAULT false,
  scope_type text CHECK (scope_type IN ('diagram','schema','table','column','relationship','migration_step')),

  -- how to apply the check (automatic items)
  check_id text,             -- built-in registry ID OR "SQL_TEMPLATE"
  sql_template text,         -- optional for SQL template mode
  result_mapping jsonb,      -- maps returned columns -> target ref
  fix_action jsonb,          -- suggestedFix {label,actionId,payload}
  run_policy jsonb           -- when to run (refresh/apply/scheduled)
);

CREATE INDEX IF NOT EXISTS idx_checklist_node_parent ON checklist_node(parent_id);
CREATE INDEX IF NOT EXISTS idx_checklist_node_version ON checklist_node(template_version_id);

-- =========
-- Checklist Instances (runs tied to a scope)
-- =========
CREATE TABLE IF NOT EXISTS checklist_instance (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NOT NULL REFERENCES app_workspace(id) ON DELETE CASCADE,

  template_version_id uuid NOT NULL REFERENCES checklist_template_version(id),
  connection_id uuid NOT NULL REFERENCES app_connection(id),
  diagram_id uuid REFERENCES app_diagram(id),

  environment text NOT NULL DEFAULT 'dev', -- dev|staging|prod
  scope_type text NOT NULL CHECK (scope_type IN ('diagram','schema','migration_step')),
  scope_ref jsonb NOT NULL DEFAULT '{}'::jsonb, -- {schemas:[...]} or {migrationPlanId:...}

  status text NOT NULL DEFAULT 'incomplete', -- pass|warning|fail|blocked|incomplete
  counts jsonb NOT NULL DEFAULT '{}'::jsonb, -- {blocking:0, warning:0, fail:0, pass:0}

  last_run_at timestamptz,
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_instance_workspace ON checklist_instance(workspace_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_instance_conn ON checklist_instance(connection_id);

-- =========
-- Per-node results (flattened per run)
-- =========
CREATE TABLE IF NOT EXISTS checklist_instance_result (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  instance_id uuid NOT NULL REFERENCES checklist_instance(id) ON DELETE CASCADE,
  node_id uuid NOT NULL REFERENCES checklist_node(id) ON DELETE CASCADE,

  status text NOT NULL DEFAULT 'unchecked', -- unchecked|pass|warning|fail|blocked
  severity text CHECK (severity IN ('info','warning','error','blocking')),

  code text,            -- e.g. FK_NOT_INDEXED
  title text,
  detail text,

  target_ref jsonb,     -- TargetRef (diagram/table/column/relationship)
  deep_link jsonb,      -- where UI should jump (ERD focus params)
  suggested_fix jsonb,  -- suggestedFix payload (if available)

  evidence jsonb,       -- optional proof/note
  checked_by uuid,
  checked_at timestamptz,

  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(instance_id, node_id)
);

CREATE INDEX IF NOT EXISTS idx_result_instance_status ON checklist_instance_result(instance_id, status);

-- =========
-- Migrations (visual diff output + apply logs)
-- =========
CREATE TABLE IF NOT EXISTS migration_plan (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id uuid NOT NULL REFERENCES app_workspace(id) ON DELETE CASCADE,
  connection_id uuid NOT NULL REFERENCES app_connection(id),
  diagram_id uuid REFERENCES app_diagram(id),

  dialect text NOT NULL,
  risk text NOT NULL DEFAULT 'low', -- low|medium|high
  warnings jsonb NOT NULL DEFAULT '[]'::jsonb,
  steps jsonb NOT NULL DEFAULT '[]'::jsonb, -- MigrationStep[]
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS migration_run (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_id uuid NOT NULL REFERENCES migration_plan(id) ON DELETE CASCADE,
  environment text NOT NULL DEFAULT 'dev',
  status text NOT NULL DEFAULT 'queued', -- queued|running|succeeded|failed
  started_at timestamptz,
  finished_at timestamptz,
  applied_sql text,
  error_text text,
  preflight_report jsonb, -- store preflight results
  created_by uuid,
  created_at timestamptz NOT NULL DEFAULT now()
);
```

---

# 1.1.01c) Indexes + invariants you must enforce (rules)

**Template versions**
- Published versions are immutable (enforce in API)

**Instance results**
- `UNIQUE(instance_id, node_id)` prevents duplicates

**Secrets**
- `secret_ref` only (never store raw creds)

---

# 1.1.01d) Define the JSON contracts (what goes into payload/model)

You already defined these shapes in your ERD spec.

- CatalogSnapshot (introspection payload)
- DiagramModel (layout + draft edits)
- TargetRef (diagram/table/column/relationship)

If you’re using `@db-gui/shared`, store the exact types there.

---

# Done criteria for 1.1.01

✅ App DB migration applies cleanly  
✅ You can create workspace + connection rows  
✅ You can store a catalog snapshot JSON payload  
✅ You can store a diagram JSON model payload  
✅ You can create a checklist template version + nodes  
✅ You can create an instance and write results for nodes  
✅ You can create a migration plan + run log

---
