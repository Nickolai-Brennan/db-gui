```txt
apps/web/src/
├─ api/
│  ├─ client.ts
│  ├─ hooks.ts
│  └─ types.ts
├─ erd/
│  ├─ graph.ts
│  ├─ anchors.ts
│  ├─ ErdCanvas.tsx
│  ├─ TableNode.tsx
│  └─ InspectorPanel.tsx
├─ pages/
│  └─ ErdPage.tsx
├─ stores/
│  └─ erdStore.ts
└─ main.tsx (wire router + query client)
```

## 1) Install deps

```bash
pnpm --filter web add zustand @tanstack/react-query react-router-dom
```

---

## 2) `src/api/types.ts`

```ts
export type PgSnapshot = {
  generatedAt: string;
  schemas: string[];
  tables: PgTable[];
  columns: PgColumn[];
  primaryKeys: PgPrimaryKey[];
  uniqueConstraints: PgUniqueConstraint[];
  foreignKeys: PgForeignKey[];
  indexes: PgIndex[];
};

export type PgTable = {
  schema: string;
  name: string;
  oid: number;
  kind: 'table' | 'partitioned_table';
  rowEstimate: number | null;
  totalBytes: number | null;
  tableBytes: number | null;
  indexBytes: number | null;
};

export type PgColumn = {
  schema: string;
  table: string;
  name: string;
  ordinal: number;
  dataType: string;
  isNullable: boolean;
  defaultExpr: string | null;
  isIdentity: boolean;
};

export type PgPrimaryKey = { schema: string; table: string; name: string; columns: string[] };
export type PgUniqueConstraint = {
  schema: string;
  table: string;
  name: string;
  columns: string[];
  isPrimary: boolean;
};

export type PgForeignKey = {
  name: string;
  childSchema: string;
  childTable: string;
  childCols: string[];
  parentSchema: string;
  parentTable: string;
  parentCols: string[];
  onDelete: string;
  onUpdate: string;
  deferrable: boolean;
  initiallyDeferred: boolean;
};

export type PgIndex = {
  schema: string;
  table: string;
  name: string;
  method: string;
  isUnique: boolean;
  isPrimary: boolean;
  isValid: boolean;
  columns: string[];
  predicate: string | null;
  definition: string;
};

export type ErdAnnotations = {
  instanceId: string;
  tables: { schema: string; table: string; severity: string; count: number }[];
  relationships: {
    childSchema: string;
    childTable: string;
    childCols: string[];
    parentSchema?: string;
    parentTable?: string;
    parentCols?: string[];
    fkName?: string;
    severity: string;
    count: number;
  }[];
};
```

---

## 3) `src/api/client.ts`

```ts
const API_BASE = import.meta.env.VITE_API_BASE ?? 'http://localhost:3001';

async function request<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`, {
    headers: { 'content-type': 'application/json', ...(init?.headers ?? {}) },
    ...init,
  });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`API ${res.status}: ${text || res.statusText}`);
  }
  return (await res.json()) as T;
}

export async function postSnapshot(body: { targetDatabaseUrl: string; schemas: string[] }) {
  return request<{ snapshot: any }>('/api/v1/introspect/postgres/snapshot', {
    method: 'POST',
    body: JSON.stringify(body),
  });
}

export async function getAnnotations(instanceId: string) {
  return request<any>(`/api/v1/checklist-instances/${instanceId}/annotations`);
}
```

---

## 4) `src/api/hooks.ts`

```ts
import { useQuery } from '@tanstack/react-query';
import { getAnnotations, postSnapshot } from './client';
import type { ErdAnnotations, PgSnapshot } from './types';

export function usePgSnapshot(enabled: boolean, input: { targetDatabaseUrl: string; schemas: string[] } | null) {
  return useQuery({
    queryKey: ['pgSnapshot', input?.targetDatabaseUrl, input?.schemas?.join(',')].filter(Boolean),
    enabled: enabled && !!input,
    queryFn: async () => {
      const res = await postSnapshot(input!);
      return res.snapshot as PgSnapshot;
    },
    staleTime: 30_000,
  });
}

export function useAnnotations(instanceId: string, enabled: boolean) {
  return useQuery({
    queryKey: ['annotations', instanceId],
    enabled: enabled && !!instanceId,
    queryFn: async () => (await getAnnotations(instanceId)) as ErdAnnotations,
    staleTime: 10_000,
  });
}
```

---

## 5) `src/stores/erdStore.ts`

```ts
import { create } from 'zustand';

export type Viewport = { x: number; y: number; zoom: number };
export type Selected =
  | { type: 'table'; key: string }
  | { type: 'relationship'; key: string }
  | { type: null };

export type Rect = { x: number; y: number; w: number; h: number };
type Layout = Record<string, Rect>;

type ErdStore = {
  viewport: Viewport;
  setViewport: (vp: Partial<Viewport>) => void;
  resetViewport: () => void;

  selected: Selected;
  setSelected: (sel: Selected) => void;

  layout: Layout;
  setTableRect: (key: string, rect: Partial<Rect>) => void;
  ensureLayout: (tableKeys: string[]) => void;
  autoLayout: (tableKeys: string[], schemaByKey: Record<string, string>) => void;

  ui: { inspectorOpen: boolean };
  toggleInspector: () => void;

  focusTarget: { type: 'table' | 'relationship'; key: string } | null;
  focusOn: (t: { type: 'table' | 'relationship'; key: string } | null) => void;
};

export const useErdStore = create<ErdStore>((set, get) => ({
  viewport: { x: 40, y: 40, zoom: 1 },
  setViewport: (vp) => set({ viewport: { ...get().viewport, ...vp } }),
  resetViewport: () => set({ viewport: { x: 40, y: 40, zoom: 1 } }),

  selected: { type: null },
  setSelected: (selected) => set({ selected }),

  layout: {},
  setTableRect: (key, rect) =>
    set((s) => ({
      layout: {
        ...s.layout,
        [key]: { ...(s.layout[key] ?? { x: 0, y: 0, w: 280, h: 220 }), ...rect },
      },
    })),

  ensureLayout: (tableKeys) => {
    const layout = { ...get().layout };
    let changed = false;
    for (const k of tableKeys) {
      if (!layout[k]) {
        layout[k] = { x: 0, y: 0, w: 280, h: 220 };
        changed = true;
      }
    }
    if (changed) set({ layout });
  },

  autoLayout: (tableKeys, schemaByKey) => {
    // Simple lanes-by-schema layout (v1)
    const schemas = Array.from(new Set(tableKeys.map((k) => schemaByKey[k] ?? 'public'))).sort();
    const perSchema: Record<string, string[]> = {};
    for (const s of schemas) perSchema[s] = [];
    for (const k of tableKeys) perSchema[schemaByKey[k] ?? 'public'].push(k);

    const layout: Layout = { ...get().layout };
    const laneW = 360;
    const padX = 80;
    const padY = 80;
    const cardH = 240;
    const cardW = 300;
    const gapY = 70;

    schemas.forEach((schema, laneIdx) => {
      const keys = perSchema[schema];
      keys.sort();
      keys.forEach((k, i) => {
        layout[k] = {
          x: padX + laneIdx * laneW,
          y: padY + i * (cardH + gapY),
          w: cardW,
          h: cardH,
        };
      });
    });

    set({ layout });
  },

  ui: { inspectorOpen: true },
  toggleInspector: () => set((s) => ({ ui: { inspectorOpen: !s.ui.inspectorOpen } })),

  focusTarget: null,
  focusOn: (focusTarget) => set({ focusTarget }),
}));
```

---

## 6) `src/erd/graph.ts`

```ts
import type { ErdAnnotations, PgSnapshot } from '../api/types';

export type TableKey = string; // `${schema}.${table}`

export type TableNode = {
  key: TableKey;
  schema: string;
  table: string;
  columns: { name: string; dataType: string; isNullable: boolean }[];
  pkCols: string[];
  indexes: { name: string; columns: string[]; isUnique: boolean; isPrimary: boolean; isValid: boolean }[];
  badge?: { severity: string; count: number };
};

export type EdgeKey = string; // stable signature v1
export type Edge = {
  key: EdgeKey;
  name: string;
  childKey: TableKey;
  parentKey: TableKey;
  childCols: string[];
  parentCols: string[];
  severity?: string;
  count?: number;
};

export function tableKey(schema: string, table: string): TableKey {
  return `${schema}.${table}`;
}

export function edgeKeyFromFk(fk: { childSchema: string; childTable: string; childCols: string[]; parentSchema: string; parentTable: string; parentCols: string[]; name?: string }): EdgeKey {
  const c = `${fk.childSchema}.${fk.childTable}(${fk.childCols.join(',')})`;
  const p = `${fk.parentSchema}.${fk.parentTable}(${fk.parentCols.join(',')})`;
  return `${c}->${p}`;
}

export function buildGraph(snapshot: PgSnapshot, annotations?: ErdAnnotations) {
  const colsByTable = new Map<TableKey, TableNode['columns']>();
  for (const c of snapshot.columns) {
    const k = tableKey(c.schema, c.table);
    const list = colsByTable.get(k) ?? [];
    list.push({ name: c.name, dataType: c.dataType, isNullable: c.isNullable });
    colsByTable.set(k, list);
  }

  const pkByTable = new Map<TableKey, string[]>();
  for (const pk of snapshot.primaryKeys) pkByTable.set(tableKey(pk.schema, pk.table), pk.columns);

  const idxByTable = new Map<TableKey, TableNode['indexes']>();
  for (const idx of snapshot.indexes) {
    const k = tableKey(idx.schema, idx.table);
    const list = idxByTable.get(k) ?? [];
    list.push({ name: idx.name, columns: idx.columns ?? [], isUnique: idx.isUnique, isPrimary: idx.isPrimary, isValid: idx.isValid });
    idxByTable.set(k, list);
  }

  const badgeByTable = new Map<TableKey, { severity: string; count: number }>();
  if (annotations?.tables) {
    for (const t of annotations.tables) {
      badgeByTable.set(tableKey(t.schema, t.table), { severity: t.severity, count: t.count });
    }
  }

  const nodes: TableNode[] = snapshot.tables.map((t) => {
    const key = tableKey(t.schema, t.name);
    const cols = (colsByTable.get(key) ?? []).sort((a, b) => a.name.localeCompare(b.name));
    const idx = (idxByTable.get(key) ?? []).sort((a, b) => a.name.localeCompare(b.name));
    return {
      key,
      schema: t.schema,
      table: t.name,
      columns: cols,
      pkCols: pkByTable.get(key) ?? [],
      indexes: idx,
      badge: badgeByTable.get(key),
    };
  });

  const edgeAnn = new Map<EdgeKey, { severity: string; count: number }>();
  if (annotations?.relationships) {
    for (const r of annotations.relationships) {
      if (!r.parentSchema || !r.parentTable) continue;
      const k = edgeKeyFromFk({
        childSchema: r.childSchema,
        childTable: r.childTable,
        childCols: r.childCols,
        parentSchema: r.parentSchema,
        parentTable: r.parentTable,
        parentCols: r.parentCols ?? [],
      });
      edgeAnn.set(k, { severity: r.severity, count: r.count });
    }
  }

  const edges: Edge[] = snapshot.foreignKeys.map((fk) => {
    const key = edgeKeyFromFk({
      childSchema: fk.childSchema,
      childTable: fk.childTable,
      childCols: fk.childCols,
      parentSchema: fk.parentSchema,
      parentTable: fk.parentTable,
      parentCols: fk.parentCols,
      name: fk.name,
    });
    const ann = edgeAnn.get(key);
    return {
      key,
      name: fk.name,
      childKey: tableKey(fk.childSchema, fk.childTable),
      parentKey: tableKey(fk.parentSchema, fk.parentTable),
      childCols: fk.childCols,
      parentCols: fk.parentCols,
      severity: ann?.severity,
      count: ann?.count,
    };
  });

  const schemaByKey: Record<string, string> = {};
  for (const n of nodes) schemaByKey[n.key] = n.schema;

  return { nodes, edges, schemaByKey };
}
```

---

## 7) `src/erd/anchors.ts`

```ts
import type { Rect } from '../stores/erdStore';

export function centerLeft(r: Rect) {
  return { x: r.x, y: r.y + r.h / 2 };
}
export function centerRight(r: Rect) {
  return { x: r.x + r.w, y: r.y + r.h / 2 };
}

export function bezierPath(a: { x: number; y: number }, b: { x: number; y: number }) {
  const dx = Math.max(60, Math.abs(b.x - a.x) * 0.35);
  const c1 = { x: a.x + dx, y: a.y };
  const c2 = { x: b.x - dx, y: b.y };
  return `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
}
```

---

## 8) `src/erd/TableNode.tsx`

```tsx
import React from 'react';
import { useErdStore } from '../stores/erdStore';
import type { TableNode } from './graph';

function severityLabel(sev?: string) {
  if (!sev) return null;
  if (sev === 'blocking') return 'BLOCK';
  if (sev === 'error') return 'FAIL';
  if (sev === 'warning') return 'WARN';
  return sev.toUpperCase();
}

export function TableNodeCard({ node }: { node: TableNode }) {
  const layout = useErdStore((s) => s.layout[node.key]);
  const setRect = useErdStore((s) => s.setTableRect);
  const selected = useErdStore((s) => s.selected);
  const setSelected = useErdStore((s) => s.setSelected);

  const isSelected = selected.type === 'table' && selected.key === node.key;

  const onPointerDown = (e: React.PointerEvent) => {
    // start drag only from header area (top 44px)
    const localY = e.nativeEvent.offsetY;
    if (localY > 44) return;

    e.stopPropagation();
    (e.currentTarget as any).setPointerCapture?.(e.pointerId);

    setSelected({ type: 'table', key: node.key });

    const startX = e.clientX;
    const startY = e.clientY;
    const startRect = layout ?? { x: 0, y: 0, w: 280, h: 220 };

    const move = (ev: PointerEvent) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      setRect(node.key, { x: startRect.x + dx, y: startRect.y + dy });
    };
    const up = () => {
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
    };

    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  };

  if (!layout) return null;

  return (
    <div
      onPointerDown={onPointerDown}
      onClick={(e) => {
        e.stopPropagation();
        setSelected({ type: 'table', key: node.key });
      }}
      style={{
        position: 'absolute',
        left: layout.x,
        top: layout.y,
        width: layout.w,
        height: layout.h,
      }}
      className={[
        'rounded-2xl bg-white shadow-sm border',
        isSelected ? 'border-black' : 'border-zinc-200',
        'overflow-hidden select-none',
      ].join(' ')}
    >
      <div className="h-11 px-3 flex items-center justify-between border-b border-zinc-200">
        <div className="min-w-0">
          <div className="text-sm font-semibold truncate">{node.table}</div>
          <div className="text-[11px] text-zinc-500 truncate">{node.schema}</div>
        </div>

        {node.badge ? (
          <div className="flex items-center gap-2">
            <span className="text-[11px] font-semibold px-2 py-0.5 rounded-full border border-zinc-200">
              {severityLabel(node.badge.severity)} · {node.badge.count}
            </span>
          </div>
        ) : null}
      </div>

      <div className="p-3 text-xs">
        <div className="text-[11px] font-semibold text-zinc-700 mb-2">Columns</div>
        <div className="space-y-1 max-h-[150px] overflow-auto pr-1">
          {node.columns.slice(0, 14).map((c) => (
            <div key={c.name} className="flex items-center justify-between gap-2">
              <div className="truncate">
                <span className="font-medium">{c.name}</span>
                {node.pkCols.includes(c.name) ? (
                  <span className="ml-2 text-[10px] px-1.5 py-0.5 rounded border border-zinc-200">PK</span>
                ) : null}
              </div>
              <div className="text-zinc-500 truncate">{c.dataType}</div>
            </div>
          ))}
          {node.columns.length > 14 ? (
            <div className="text-zinc-500">+{node.columns.length - 14} more…</div>
          ) : null}
        </div>
      </div>
    </div>
  );
}
```

---

## 9) `src/erd/InspectorPanel.tsx`

```tsx
import { useMemo } from 'react';
import { useErdStore } from '../stores/erdStore';
import type { Edge, TableNode } from './graph';

export function InspectorPanel({ nodes, edges }: { nodes: TableNode[]; edges: Edge[] }) {
  const selected = useErdStore((s) => s.selected);

  const table = useMemo(() => {
    if (selected.type !== 'table') return null;
    return nodes.find((n) => n.key === selected.key) ?? null;
  }, [selected, nodes]);

  const rel = useMemo(() => {
    if (selected.type !== 'relationship') return null;
    return edges.find((e) => e.key === selected.key) ?? null;
  }, [selected, edges]);

  return (
    <aside className="w-[360px] shrink-0 border-l border-zinc-200 bg-white">
      <div className="p-4 border-b border-zinc-200">
        <div className="text-sm font-semibold">Inspector</div>
        <div className="text-xs text-zinc-500">Select a table or relationship</div>
      </div>

      <div className="p-4 space-y-4 overflow-auto h-[calc(100vh-57px)]">
        {table ? (
          <>
            <div>
              <div className="text-lg font-semibold">{table.table}</div>
              <div className="text-sm text-zinc-500">{table.schema}</div>
            </div>

            <div>
              <div className="text-xs font-semibold text-zinc-700 mb-2">Primary Key</div>
              {table.pkCols.length ? (
                <div className="text-sm">{table.pkCols.join(', ')}</div>
              ) : (
                <div className="text-sm text-zinc-500">None</div>
              )}
            </div>

            <div>
              <div className="text-xs font-semibold text-zinc-700 mb-2">Indexes</div>
              <div className="space-y-2">
                {table.indexes.slice(0, 8).map((ix) => (
                  <div key={ix.name} className="rounded-xl border border-zinc-200 p-2">
                    <div className="text-sm font-medium">{ix.name}</div>
                    <div className="text-xs text-zinc-500">{ix.columns.join(', ') || '(expression)'}</div>
                    <div className="text-[11px] text-zinc-500 mt-1">
                      {ix.isPrimary ? 'PRIMARY ' : ''}
                      {ix.isUnique ? 'UNIQUE ' : ''}
                      {ix.isValid ? '' : 'INVALID'}
                    </div>
                  </div>
                ))}
                {!table.indexes.length ? <div className="text-sm text-zinc-500">No indexes found</div> : null}
              </div>
            </div>
          </>
        ) : rel ? (
          <>
            <div>
              <div className="text-lg font-semibold">{rel.name}</div>
              <div className="text-sm text-zinc-500">{rel.childKey} → {rel.parentKey}</div>
            </div>

            <div className="rounded-xl border border-zinc-200 p-3">
              <div className="text-xs font-semibold text-zinc-700 mb-1">Join</div>
              <div className="text-sm">
                ({rel.childCols.join(', ')}) → ({rel.parentCols.join(', ')})
              </div>
              {rel.severity ? (
                <div className="text-xs text-zinc-500 mt-2">
                  Annotation: {rel.severity} {rel.count ? `· ${rel.count}` : ''}
                </div>
              ) : null}
            </div>
          </>
        ) : (
          <div className="text-sm text-zinc-500">Nothing selected.</div>
        )}
      </div>
    </aside>
  );
}
```

---

## 10) `src/erd/ErdCanvas.tsx`

```tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useErdStore } from '../stores/erdStore';
import type { Edge, TableNode } from './graph';
import { bezierPath, centerLeft, centerRight } from './anchors';
import { TableNodeCard } from './TableNode';

export function ErdCanvas({ nodes, edges }: { nodes: TableNode[]; edges: Edge[] }) {
  const viewport = useErdStore((s) => s.viewport);
  const setViewport = useErdStore((s) => s.setViewport);
  const resetViewport = useErdStore((s) => s.resetViewport);
  const layout = useErdStore((s) => s.layout);
  const ensureLayout = useErdStore((s) => s.ensureLayout);
  const setSelected = useErdStore((s) => s.setSelected);
  const selected = useErdStore((s) => s.selected);
  const focusTarget = useErdStore((s) => s.focusTarget);
  const focusOn = useErdStore((s) => s.focusOn);

  const stageRef = useRef<HTMLDivElement | null>(null);
  const [panning, setPanning] = useState<{ startX: number; startY: number; startVpX: number; startVpY: number } | null>(null);

  useEffect(() => {
    ensureLayout(nodes.map((n) => n.key));
  }, [nodes, ensureLayout]);

  // Focus handling: center viewport on table
  useEffect(() => {
    if (!focusTarget) return;
    if (focusTarget.type === 'table') {
      const r = layout[focusTarget.key];
      if (r) {
        const cx = r.x + r.w / 2;
        const cy = r.y + r.h / 2;
        // center in view
        const vw = stageRef.current?.clientWidth ?? 1200;
        const vh = stageRef.current?.clientHeight ?? 800;
        setViewport({ x: vw / 2 - cx * viewport.zoom, y: vh / 2 - cy * viewport.zoom });
        setSelected({ type: 'table', key: focusTarget.key });
      }
    }
    focusOn(null);
  }, [focusTarget, layout, setViewport, viewport.zoom, setSelected, focusOn]);

  const onWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    const delta = -e.deltaY;
    const zoom = viewport.zoom;
    const nextZoom = Math.min(2.2, Math.max(0.35, zoom * (delta > 0 ? 1.08 : 0.92)));

    // zoom around cursor
    const rect = (e.currentTarget as HTMLDivElement).getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    const worldX = (cx - viewport.x) / zoom;
    const worldY = (cy - viewport.y) / zoom;

    const nextX = cx - worldX * nextZoom;
    const nextY = cy - worldY * nextZoom;

    setViewport({ zoom: nextZoom, x: nextX, y: nextY });
  };

  const onPointerDownBg = (e: React.PointerEvent) => {
    // only pan if click background (not node)
    e.preventDefault();
    setSelected({ type: null });
    setPanning({ startX: e.clientX, startY: e.clientY, startVpX: viewport.x, startVpY: viewport.y });
  };

  useEffect(() => {
    if (!panning) return;

    const move = (ev: PointerEvent) => {
      const dx = ev.clientX - panning.startX;
      const dy = ev.clientY - panning.startY;
      setViewport({ x: panning.startVpX + dx, y: panning.startVpY + dy });
    };
    const up = () => setPanning(null);

    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
    return () => {
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
    };
  }, [panning, setViewport]);

  const edgePaths = useMemo(() => {
    const paths: { key: string; d: string; severity?: string }[] = [];
    for (const e of edges) {
      const child = layout[e.childKey];
      const parent = layout[e.parentKey];
      if (!child || !parent) continue;

      const a = centerRight(child);
      const b = centerLeft(parent);

      paths.push({ key: e.key, d: bezierPath(a, b), severity: e.severity });
    }
    return paths;
  }, [edges, layout]);

  const stageStyle: React.CSSProperties = {
    transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.zoom})`,
    transformOrigin: '0 0',
    width: 6000,
    height: 6000,
    position: 'relative',
  };

  return (
    <div className="relative flex-1 bg-zinc-50 overflow-hidden">
      {/* top-right controls */}
      <div className="absolute top-3 right-3 z-20 flex items-center gap-2">
        <button
          className="px-3 py-1.5 rounded-xl border border-zinc-200 bg-white text-sm"
          onClick={resetViewport}
        >
          Reset view
        </button>
        <div className="px-3 py-1.5 rounded-xl border border-zinc-200 bg-white text-sm">
          {Math.round(viewport.zoom * 100)}%
        </div>
      </div>

      {/* subtle grid background */}
      <div
        className="absolute inset-0"
        style={{
          backgroundImage:
            'linear-gradient(to right, rgba(0,0,0,0.05) 1px, transparent 1px), linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px)',
          backgroundSize: '40px 40px',
        }}
      />

      <div
        ref={stageRef}
        className="absolute inset-0"
        onWheel={onWheel}
        onPointerDown={onPointerDownBg}
      >
        <div style={stageStyle}>
          {/* Edges layer */}
          <svg
            width={6000}
            height={6000}
            style={{ position: 'absolute', left: 0, top: 0, pointerEvents: 'none' }}
          >
            {edgePaths.map((p) => {
              const isSel = selected.type === 'relationship' && selected.key === p.key;
              const stroke = isSel ? 'black' : 'rgba(0,0,0,0.25)';
              const strokeWidth = isSel ? 2.5 : p.severity ? 2 : 1.25;
              return (
                <path key={p.key} d={p.d} fill="none" stroke={stroke} strokeWidth={strokeWidth} />
              );
            })}
          </svg>

          {/* Nodes layer */}
          {nodes.map((n) => (
            <TableNodeCard key={n.key} node={n} />
          ))}
        </div>
      </div>
    </div>
  );
}
```

---

## 11) `src/pages/ErdPage.tsx`

```tsx
import { useEffect, useMemo, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useAnnotations, usePgSnapshot } from '../api/hooks';
import { buildGraph } from '../erd/graph';
import { ErdCanvas } from '../erd/ErdCanvas';
import { InspectorPanel } from '../erd/InspectorPanel';
import { useErdStore } from '../stores/erdStore';

function loadConnFromStorage() {
  const raw = localStorage.getItem('erd_conn');
  if (!raw) return null;
  try {
    return JSON.parse(raw) as { targetDatabaseUrl: string; schemas: string[] };
  } catch {
    return null;
  }
}

export default function ErdPage() {
  const { wsId, instanceId } = useParams();
  const [conn, setConn] = useState<{ targetDatabaseUrl: string; schemas: string[] } | null>(loadConnFromStorage());
  const [showConn, setShowConn] = useState(!conn);

  const snapQ = usePgSnapshot(!!conn && !showConn, conn);
  const annQ = useAnnotations(instanceId!, !!conn && !showConn);

  const autoLayout = useErdStore((s) => s.autoLayout);

  const graph = useMemo(() => {
    if (!snapQ.data) return null;
    return buildGraph(snapQ.data, annQ.data);
  }, [snapQ.data, annQ.data]);

  useEffect(() => {
    if (graph?.nodes?.length) {
      autoLayout(graph.nodes.map((n) => n.key), graph.schemaByKey);
    }
  }, [graph?.nodes?.length]); // intentionally minimal

  return (
    <div className="h-screen flex flex-col bg-white">
      {/* Top bar */}
      <div className="h-14 border-b border-zinc-200 flex items-center justify-between px-4">
        <div className="min-w-0">
          <div className="text-sm font-semibold truncate">ERD</div>
          <div className="text-xs text-zinc-500 truncate">
            workspace {wsId} · instance {instanceId}
          </div>
        </div>

        <div className="flex items-center gap-2">
          <button
            className="px-3 py-1.5 rounded-xl border border-zinc-200 text-sm"
            onClick={() => setShowConn(true)}
          >
            Connection
          </button>

          {graph ? (
            <button
              className="px-3 py-1.5 rounded-xl border border-zinc-200 text-sm"
              onClick={() => autoLayout(graph.nodes.map((n) => n.key), graph.schemaByKey)}
            >
              Auto layout
            </button>
          ) : null}
        </div>
      </div>

      {/* Body */}
      <div className="flex flex-1 min-h-0">
        <div className="flex-1 min-w-0">
          {snapQ.isLoading ? (
            <div className="p-6 text-sm text-zinc-600">Loading snapshot…</div>
          ) : snapQ.isError ? (
            <div className="p-6 text-sm text-red-600">{String(snapQ.error)}</div>
          ) : !graph ? (
            <div className="p-6 text-sm text-zinc-600">No snapshot loaded.</div>
          ) : (
            <ErdCanvas nodes={graph.nodes} edges={graph.edges} />
          )}
        </div>

        {graph ? <InspectorPanel nodes={graph.nodes} edges={graph.edges} /> : null}
      </div>

      {/* Connection modal */}
      {showConn ? (
        <ConnectionModal
          initial={conn}
          onClose={() => setShowConn(false)}
          onSave={(next) => {
            localStorage.setItem('erd_conn', JSON.stringify(next));
            setConn(next);
            setShowConn(false);
          }}
        />
      ) : null}
    </div>
  );
}

function ConnectionModal({
  initial,
  onClose,
  onSave,
}: {
  initial: { targetDatabaseUrl: string; schemas: string[] } | null;
  onClose: () => void;
  onSave: (c: { targetDatabaseUrl: string; schemas: string[] }) => void;
}) {
  const [url, setUrl] = useState(initial?.targetDatabaseUrl ?? '');
  const [schemas, setSchemas] = useState((initial?.schemas ?? ['public']).join(','));

  return (
    <div className="fixed inset-0 bg-black/30 flex items-center justify-center z-50">
      <div className="w-[720px] max-w-[92vw] rounded-2xl bg-white shadow-sm border border-zinc-200">
        <div className="p-4 border-b border-zinc-200 flex items-center justify-between">
          <div>
            <div className="text-sm font-semibold">Target connection</div>
            <div className="text-xs text-zinc-500">v1: stored in localStorage</div>
          </div>
          <button className="px-3 py-1.5 rounded-xl border border-zinc-200 text-sm" onClick={onClose}>
            Close
          </button>
        </div>

        <div className="p-4 space-y-3">
          <label className="block">
            <div className="text-xs font-semibold text-zinc-700 mb-1">Target Database URL</div>
            <input
              value={url}
              onChange={(e) => setUrl(e.target.value)}
              placeholder="postgresql://user:pass@host:5432/db"
              className="w-full px-3 py-2 rounded-xl border border-zinc-200 text-sm"
            />
          </label>

          <label className="block">
            <div className="text-xs font-semibold text-zinc-700 mb-1">Schemas</div>
            <input
              value={schemas}
              onChange={(e) => setSchemas(e.target.value)}
              placeholder="public,stats"
              className="w-full px-3 py-2 rounded-xl border border-zinc-200 text-sm"
            />
          </label>

          <div className="pt-2 flex justify-end">
            <button
              className="px-4 py-2 rounded-xl bg-black text-white text-sm"
              onClick={() => {
                const list = schemas
                  .split(',')
                  .map((s) => s.trim())
                  .filter(Boolean);
                onSave({ targetDatabaseUrl: url.trim(), schemas: list.length ? list : ['public'] });
              }}
            >
              Save & Load
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

---

## 12) Wire Router + Query Client (`src/main.tsx`)

If you already have a router setup, just merge the key bits.

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter, Route, Routes, Navigate } from 'react-router-dom';
import './index.css';
import ErdPage from './pages/ErdPage';

const qc = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={qc}>
      <BrowserRouter>
        <Routes>
          <Route
            path="/workspaces/:wsId/instances/:instanceId/erd"
            element={<ErdPage />}
          />
          <Route path="*" element={<Navigate to="/workspaces/default/instances/demo/erd" replace />} />
        </Routes>
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>,
);
```

---

## Run it

```bash
pnpm --filter web dev
```

Open:
`/workspaces/<wsId>/instances/<instanceId>/erd`

---

## Next upgrade (most important)

Right now edges aren’t clickable (SVG is pointerEvents none). If you want **edge hover + click selection** + severity styling, say **“edge selection”** and I’ll patch `ErdCanvas` to:

* render edges in an interactive SVG layer
* click sets `selected: relationship`
* highlight on hover/selection
